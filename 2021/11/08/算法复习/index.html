<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="img/love.jpg"/>
	<link rel="shortcut icon" href="img/love.jpg">
	
			    <title>
    Aoki_Umi
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <span id="busuanzi_container_site_pv">��վ�ܷ�����<span id="busuanzi_value_site_pv"></span>��</span>
    <meta name="keywords" content="Aoki_Umi" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<link rel="alternate" href="atom.xml" title="Aoki_Umi" type="application/atom+xml">
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">AOKI_UMI</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">HOME</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">CATEGORIES</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="../categories/CS/">CS</a></li><li><a class="category-link" href="../categories/CS/C-C/">C&C++</a></li><li><a class="category-link" href="../categories/CS/PYTHON/">PYTHON</a></li><li><a class="category-link" href="../categories/CS/SIGNAL-PROCESSING/">SIGNAL_PROCESSING</a></li><li><a class="category-link" href="../categories/OI/">OI</a></li><li><a class="category-link" href="../categories/OI/ALGORITHM/">ALGORITHM</a></li><li><a class="category-link" href="../categories/OI/Algorithm/">Algorithm</a></li><li><a class="category-link" href="../categories/OI/Algorithm/Tree/">Tree</a></li><li><a class="category-link" href="../categories/OI/Character-String/">Character String</a></li><li><a class="category-link" href="../categories/OI/Congratulation/">Congratulation</a></li><li><a class="category-link" href="../categories/OI/Contest/">Contest</a></li><li><a class="category-link" href="../categories/OI/DATA-STRUCTURE/">DATA STRUCTURE</a></li><li><a class="category-link" href="../categories/OI/DP/">DP</a></li><li><a class="category-link" href="../categories/OI/GRAPH-THERY/">GRAPH THERY</a></li><li><a class="category-link" href="../categories/OI/Graph-Theory/">Graph Theory</a></li><li><a class="category-link" href="../categories/OI/Maths/">Maths</a></li><li><a class="category-link" href="../categories/OI/Search/">Search</a></li><li><a class="category-link" href="../categories/OI/Simulation/">Simulation</a></li><li><a class="category-link" href="../categories/STUDY/">STUDY</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">ARCHIVES</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="../archives/2021/11/">November 2021</a></li><li><a class="archive-link" href="../archives/2021/04/">April 2021</a></li><li><a class="archive-link" href="../archives/2021/01/">January 2021</a></li><li><a class="archive-link" href="../archives/2020/11/">November 2020</a></li><li><a class="archive-link" href="../archives/2020/10/">October 2020</a></li><li><a class="archive-link" href="../archives/2020/08/">August 2020</a></li><li><a class="archive-link" href="../archives/2020/06/">June 2020</a></li><li><a class="archive-link" href="../archives/2020/05/">May 2020</a></li><li><a class="archive-link" href="../archives/2020/04/">April 2020</a></li><li><a class="archive-link" href="../archives/2020/02/">February 2020</a></li><li><a class="archive-link" href="../archives/2018/11/">November 2018</a></li><li><a class="archive-link" href="../archives/2018/10/">October 2018</a></li><li><a class="archive-link" href="../archives/2018/09/">September 2018</a></li><li><a class="archive-link" href="../archives/2018/08/">August 2018</a></li><li><a class="archive-link" href="../archives/2018/07/">July 2018</a></li><li><a class="archive-link" href="../archives/2018/05/">May 2018</a></li><li><a class="archive-link" href="../archives/2018/04/">April 2018</a></li><li><a class="archive-link" href="../archives/2018/03/">March 2018</a></li><li><a class="archive-link" href="../archives/2018/01/">January 2018</a></li><li><a class="archive-link" href="../archives/1924/07/">July 1924</a>
	                    </ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="ABOUT">
		                ABOUT
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="FRIENDS">
		                FRIENDS
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="GALLERY">
		                GALLERY
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="TAG">
		                TAG
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/AokiUmi" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/images/0031.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >算法复习</h2></a>
         
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">

                <h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><h2 id="链表-List"><a href="#链表-List" class="headerlink" title="链表(List)"></a>链表(List)</h2><p>记录头尾指针代表链表的开始和结束，中间用next表示前后关系的线性结构。</p>
<h3 id="支持的操作与其复杂度"><a href="#支持的操作与其复杂度" class="headerlink" title="支持的操作与其复杂度"></a>支持的操作与其复杂度</h3><p>· 头尾插入元素$O(1)$，删除尾部$O(n)$</p>
<p>· 其他位置插入删除都是$O(n)$（先要找到这个元素再在前后插入，知道位置只用$O(1)$)</p>
<p>双向链表就是多记录了一个$pre$，没啥大区别</p>
<h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><p><img src="/2021/11/08/算法复习/1.png" alt=""></p>
<p>尾进尾出的结构，一般只需要一个指针，画成竖直状态比较方便理解</p>
<p>具体运用：逆波兰表达式，树的深度优先遍历</p>
<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><p>尾进头出的结构，有头尾两个指针的线性结构</p>
<p><img src="/2021/11/08/算法复习/2.png" alt=""></p>
<p>环形队列</p>
<p><img src="/2021/11/08/算法复习/3.png" alt=""></p>
<h2 id="哈希表-Hash-List"><a href="#哈希表-Hash-List" class="headerlink" title="哈希表(Hash List)"></a>哈希表(Hash List)</h2><p>自定义一种哈希方式，得到对应的哈希数，然后放在对应的数组格子里面。</p>
<p>但如果对应格子已经满了，就采用线性或者更跳跃的方式往后找空余的格子</p>
<p>线性探查(probe)——直接一个一个往后找</p>
<p>二次探查——$ (k+k*k)/2$     1，2，4，7，11 优点为花费时间更少</p>
<h2 id="树-Trees"><a href="#树-Trees" class="headerlink" title="树(Trees)"></a>树(Trees)</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>深度(depth)：<strong>根节点记为深度0</strong>，树的高度指最大深度</li>
<li>父亲(parent)与孩子(children)节点：从根节点往下遍历，由一条边相连的两个节点互为父亲与孩子节点，深度小的为父亲</li>
<li>度数(degree)：父亲节点的孩子数量</li>
<li>叶子节点(leaf)：孩子数量为0即度数为0的节点</li>
<li>根节点(root)：没有父亲的节点</li>
<li>祖先(ancestor)与子孙(descendant)：<strong>此概念均包括节点自己</strong>，子孙指以该节点为根的子树里所有的节点，祖先指从该节点到根节点路径上经过的所有节点</li>
</ul>
<h3 id="遍历方法-traversal"><a href="#遍历方法-traversal" class="headerlink" title="遍历方法(traversal)"></a>遍历方法(traversal)</h3><h4 id="广度优先遍历-Breadth-First-Traversal-BFS"><a href="#广度优先遍历-Breadth-First-Traversal-BFS" class="headerlink" title="广度优先遍历(Breadth-First Traversal) BFS"></a>广度优先遍历(Breadth-First Traversal) BFS</h4><p><img src="/2021/11/08/算法复习/8.png" alt=""></p>
<p>很显然的遍历，运用queue队列来进行，每次先pop对头节点，再push进去当前对头节点所有的孩子</p>
<h4 id="深度优先搜索-Depth-first-Traversal-DFS"><a href="#深度优先搜索-Depth-first-Traversal-DFS" class="headerlink" title="深度优先搜索(Depth-first Traversal) DFS"></a>深度优先搜索(Depth-first Traversal) DFS</h4><p>每次pop出栈头节点，push进去其孩子节点（<strong>从右到左</strong>）</p>
<p>用栈stack来实现</p>
<p><img src="/2021/11/08/算法复习/9.png" alt=""></p>
<h3 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h3><p>一种孩子最多只有两个的结构</p>
<h4 id="二叉树的深度遍历"><a href="#二叉树的深度遍历" class="headerlink" title="二叉树的深度遍历"></a>二叉树的深度遍历</h4><ul>
<li>前序遍历(pre-order)：根左右</li>
<li>中序遍历(in-order)：左根右</li>
<li>后序遍历(post-order)：左右根</li>
</ul>
<p><strong>都是以根的位置而记忆的</strong></p>
<h4 id="易混淆概念"><a href="#易混淆概念" class="headerlink" title="易混淆概念"></a>易混淆概念</h4><ul>
<li>满二叉树(full binary tree)：只要有孩子就必须满足两个，要么就没有</li>
</ul>
<p>​       性质：$n $ 个叶子节点，$2n-1$ 所有节点</p>
<ul>
<li><p>完美二叉树(perfect binary tree)：每层的节点全部是满的</p>
<p>性质：节点为$n=2^{h+1}-1$，高度为$h=\Theta(lnn)$，该层有$2^h$个叶子节点</p>
</li>
<li><p>完全二叉树(complete binary tree)：倒数第二层前都满足完美二叉树性质，最后一层可以不满</p>
<p>性质：节点为n，高度为$h=\lfloor lg(n) \rfloor$ </p>
</li>
</ul>
<h1 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h1><p><img src="/2021/11/08/算法复习/4.png" alt=""></p>
<p><img src="/2021/11/08/算法复习/5.png" alt=""></p>
<h1 id="算法复习"><a href="#算法复习" class="headerlink" title="算法复习"></a>算法复习</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>逆序对定义：原先数组内和排序后数组顺序相反的数对</p>
<p>计算逆序对：用归并排序</p>
<h3 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h3><p>将序列分为有序序列和无序序列两段，每次将无序序列开头的数插入前面的有序序列中，直到所有数都有序</p>
<p>复杂度：最坏$O(n^2)$,平均$O(n+d)$，原地排序，稳定排序</p>
<p>若有$d$对逆序对，则时间为$\Theta (n+d)$ </p>
<p>若$d=O(n)$，时间为$\Theta(n)$</p>
<h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h3><p>从前到后比较相邻两个数的大小，交换逆序对</p>
<p>同时分带不带flag判断，带的话有最优复杂度，不带就没有</p>
<p>复杂度：最坏$O(n^2)$ 最优$O(n)$ ，原地排序，稳定排序</p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h3><p>归并思路，合并两个子数列的时候就是利用队列合并，所以需要新开一个数组来合并序列</p>
<p>复杂度：$O(nlogn)$ 非原地排序，空间$O(n)$，稳定排序</p>
<p>计算逆序对，直接在$b_j&lt;a_i$时候$ans+=mid-i+1$</p>
<h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h3><p>每次选一个pivot找到他正确的位置，然后以pivot为中心再分为两个子序列，于是剩下的就是分治思路。</p>
<p>找位置的方法是，从pivot开始从左到右找第一个比pivot大的数，从右到左找第一个比pivot小的数</p>
<p>同时每次把pivot找到的正确位置之后，就是建立一颗二叉搜索树。</p>
<p>从这个角度思考复杂度$a_i,a_j$会被比较到的概率为$2/j-i+1$，只有互为孩子父亲才会被比较到</p>
<p>故复杂度就为所有数对的可能性相加  $2n(lnn+1)$</p>
<p>复杂度：平均$O(nlogn)$ 最坏$O(n^2)$，原地排序，非稳定排序</p>
<h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h3><p>先把数据建成大根堆，每次再将堆头和最末尾的元素交换，然后pop掉这个最大的元素，再重新调成大根堆结构，这样保证每次操作都能找到现在无序序列中最大的元素，依次把大根堆规模变小，使无序序列长度逐渐变小为0。</p>
<p>复杂度：$O(nlogn)$，非原地排序，非稳定排序</p>
<h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h3><p>每次从前往后找出无序序列中最小的一个数和无序序列第一个数交换位置，暴力找，很慢。</p>
<p>复杂度：$O(n^2)$，原地排序，非稳定排序</p>
<h3 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h3><p>一个在归并算法中运用的求复杂度的理论<br>$$<br>T(n)=aT(\frac{n}{b})+f(n),T(0)=0,T(1)=\Theta(1)<br>$$<br>a代表子问题的数量，n/b指子问题的大小，f(n)是divide and combine</p>
<p><img src="/2021/11/08/算法复习/6.png" alt=""></p>
<p>这个理论运用的实例：求矩阵乘法</p>
<p><img src="/2021/11/08/算法复习/7.png" alt=""></p>
<h2 id="哈夫曼编码-Huffman-Coding"><a href="#哈夫曼编码-Huffman-Coding" class="headerlink" title="哈夫曼编码(Huffman Coding)"></a>哈夫曼编码(Huffman Coding)</h2><p>一种按字符出现频率来实现编码的方式，以此来节省空间，利用二叉树，优先队列来存储</p>
<p>先用优先队列记录每个字符的出现频率，频率越高在优先队列中优先级越低，就放在队列越后面</p>
<p><img src="/2021/11/08/算法复习/11.png" alt=""></p>
<p>建树过程使从前到后两两合并，得到的子树顺次插入序列，期中单字符优先级大于多个字符</p>
<p><img src="/2021/11/08/算法复习/12.png" alt=""></p>
<h2 id="二叉堆与优先队列-Heap"><a href="#二叉堆与优先队列-Heap" class="headerlink" title="二叉堆与优先队列(Heap)"></a>二叉堆与优先队列(Heap)</h2><p>优先队列就是队头固定最大最小值的数组，感觉就是排好序的数列</p>
<p>二叉堆的性质：大根堆就是父亲节点大于左右孩子，但左右孩子大小关系不确定，小根堆就是大小关系反一下</p>
<p>堆是一个完全二叉树，将数据储存在数组里的，利用下标一个父亲节点为$n$则左孩子为$2n$，右孩子$2n+1$</p>
<h3 id="操作与复杂度"><a href="#操作与复杂度" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><ul>
<li><p>push：直接先新节点顺次加入树的最后一个节点，然后执行percolate操作，我的理解是向上翻，每次比较第$\lceil n/2 \rceil(n&gt;&gt;1)$节点和自己的大小，若不符合定义就交换。</p>
</li>
<li><p>pop：将需要pop的节点与当前堆最后一个元素交换，直接抛弃现在最后一个元，再执行percolate操作，在这里是下沉，再从根节点往下比较自己孩子$(2n,2n+1)$与自己的大小，不符合定义就交换。</p>
</li>
<li><p>build：push每个元素或者用Floyd’s Method $O(nlogn)$</p>
<p>大体看push和pop都当成$O(nlogn)$</p>
</li>
</ul>
<p>空间都是$O(n)$</p>
<p><img src="/2021/11/08/算法复习/10.png" alt=""></p>
<p>Floyd’s Method将小根堆调成为大根堆（或者将普通堆调整），就是思路是先从上往下找到所有不符合定义的根节点，从编号最大的节点依次往上做percolate操作调成，依次调整完就行。</p>
<h2 id="二叉搜索树-Binary-Search-Trees"><a href="#二叉搜索树-Binary-Search-Trees" class="headerlink" title="二叉搜索树(Binary Search Trees)"></a>二叉搜索树(Binary Search Trees)</h2><p>满足根节点的左子树所有值都小于自己，右子树所有值都大于自己的二叉数</p>
<p>理解：$BST$的结构主要和插入元素的顺序有关，优不优化完全取决顺序，所以才有了$AVL$树</p>
<h3 id="操作与复杂度-1"><a href="#操作与复杂度-1" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><ul>
<li>Insert：总的来说就是顺着根节点往下比较，每次看是比当前节点大还是小，小就往左边走，大就往右边走，知道找到一个空位置就行</li>
<li>Find：和插入同理，顺着树往下走就完了</li>
<li>Erase：这个分三种情况，若该节点为叶子节点直接删除就行，如果有一个子树，把这个子树接上去就行，如果有两个子树，找到右子树中最小的元素和根换位置再删掉根就行，这样能保证现在右子树所有值还是大于根（最小元素），左子树所有值也小于根。同时这个最小的值一定只有一个子树或者右节点可以证明，因为使最小的不可能有左子树</li>
</ul>
<p>由于所有操作都等于$O(h)$，但高度决定于顺序所以没有定值，但最优$O(lognn)$，最坏$O(n)$</p>
<p><strong>一些进阶设计</strong></p>
<p>设计$next$边：如果该节点有右子树，根向右子树最小的值连next边</p>
<p>设计$previous$边：如果该节点没有右子树，找到第一个大于自己的节点向他连一条边</p>
<p>这个课件里没有讲有啥用，我感觉就和AC自动机一样，但不知道有啥实际运用</p>
<p>感觉是next在删除中比较有用吧</p>
<p>用$BST$找第k大：直接看根节点左右子树大小，若左子树大小$l=k$，就是root。若$l&gt;k$继续在左子树中找最大的，否则在右子树中找$k-l-1$大的，就是一个递归思路</p>
<h2 id="二叉平衡搜索树-AVL-Trees"><a href="#二叉平衡搜索树-AVL-Trees" class="headerlink" title="二叉平衡搜索树(AVL Trees)"></a>二叉平衡搜索树(AVL Trees)</h2><p><del>就你是我以前天天写到吐的玩意是吧！</del></p>
<p>就是$BST$升级版，需要保证左右子树高度差距不大于1，于是所有操作的复杂度就能在$O(logn)$了</p>
<p>完全二叉搜索树=平衡树</p>
<p>计算满足高度为h的最小平衡树$F(h)$：可得此为斐波那契数列</p>
<p><img src="/2021/11/08/算法复习/13.png" alt=""></p>
<p>得到$F(h)\approx 1.8994\phi ^h-1,\phi \approx 1.6180$</p>
<p>$F(h)=\Theta (\phi ^h)$</p>
<p>所以可得高度为h的最大平衡树$log_{\phi}{(\frac{n+1}{1.8944})}=log_{\phi}{(n+1)-1.3277}=1.4404*lg(n+1)-1.3277$</p>
<h3 id="操作与复杂度-2"><a href="#操作与复杂度-2" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><p>所有操作和$BST$一样，只是插入和删除都多了一个维和操作，这里具体分析如何维护也就是$Splay$核心，同时维护都是$O(1)$</p>
<p>基本操作分为左旋和右旋</p>
<p>右旋</p>
<p><img src="/2021/11/08/算法复习/15.jpg" alt=""></p>
<p>左旋</p>
<p><img src="/2021/11/08/算法复习/16.jpg" alt=""></p>
<p>核心是找到处于不平衡状态的根，看是怎么样子不平衡</p>
<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p>左子树大于右子树两个高度，直接右旋一次就行</p>
<p><img src="/2021/11/08/算法复习/14.jpg" alt=""></p>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p>右子树大于左子树两个高度，直接左旋一次就行</p>
<p><img src="/2021/11/08/算法复习/17.jpg" alt=""></p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p>将新的节点插入到了 n 的左孩子的右子树上导致的不平衡的情况。这时我们需要的是先对 i 进行一次左旋再对 n 进行一次右旋。</p>
<p><img src="/2021/11/08/算法复习/18.jpg" alt=""></p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p>和LR同理不知道为啥没有图给我偷了（</p>
<p>总之是将新的节点插入到了 n 的右孩子的左子树上导致的不平衡的情况。这时我们需要的是先对 i 进行一次右旋再对 n 进行一次左旋。</p>
<p>再来看基本操作</p>
<ul>
<li>Insertion 只可能需要一次维护 $O(1)$</li>
<li>Erase 可能需要$O(h)$次数，需要沿着删除的节点从下到上沿着到根节点的路径往上检查节点是否需要为维护 故复杂度$O(log n)$</li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 valine -->
<div id="comment">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#comment' ,
        notify: false,
        verify: false,
        app_id: 'fUtpOauFo2JhcWoBFEnnppJW-gzGzoHsz',
        app_key: 'gFTwG42ACHuyrmwhMfgxcRQQ',
        placeholder: '留下你的评论吧~~',
        pageSize: '10',
        avatar: '',
        avatar_cdn: 'https://gravatar.loli.net/avatar/'
    });
</script>
</div>
<style>
   #comment{
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2021总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":125,"height":250},"mobile":{"show":false},"log":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":125,"height":250},"mobile":{"show":false},"log":false});</script></body>




 	

    </script>
</html>
