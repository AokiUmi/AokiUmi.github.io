<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="img/love.jpg"/>
	<link rel="shortcut icon" href="img/love.jpg">
	
			    <title>
    Aoki_Umi
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <span id="busuanzi_container_site_pv">��վ�ܷ�����<span id="busuanzi_value_site_pv"></span>��</span>
    <meta name="keywords" content="Aoki_Umi" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<link rel="alternate" href="atom.xml" title="Aoki_Umi" type="application/atom+xml">
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">AOKI_UMI</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">HOME</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">CATEGORIES</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="../categories/CS/">CS</a></li><li><a class="category-link" href="../categories/CS/AI/">AI</a></li><li><a class="category-link" href="../categories/CS/ALGORITHM/">ALGORITHM</a></li><li><a class="category-link" href="../categories/CS/ASSEMBLY-LANGUAGE/">ASSEMBLY_LANGUAGE</a></li><li><a class="category-link" href="../categories/CS/C-C/">C&C++</a></li><li><a class="category-link" href="../categories/CS/CA/">CA</a></li><li><a class="category-link" href="../categories/CS/PYTHON/">PYTHON</a></li><li><a class="category-link" href="../categories/CS/SIGNAL-PROCESSING/">SIGNAL_PROCESSING</a></li><li><a class="category-link" href="../categories/OI/">OI</a></li><li><a class="category-link" href="../categories/OI/ALGORITHM/">ALGORITHM</a></li><li><a class="category-link" href="../categories/OI/Algorithm/">Algorithm</a></li><li><a class="category-link" href="../categories/OI/Algorithm/Tree/">Tree</a></li><li><a class="category-link" href="../categories/OI/Character-String/">Character String</a></li><li><a class="category-link" href="../categories/OI/Congratulation/">Congratulation</a></li><li><a class="category-link" href="../categories/OI/Contest/">Contest</a></li><li><a class="category-link" href="../categories/OI/DATA-STRUCTURE/">DATA STRUCTURE</a></li><li><a class="category-link" href="../categories/OI/DP/">DP</a></li><li><a class="category-link" href="../categories/OI/GRAPH-THERY/">GRAPH THERY</a></li><li><a class="category-link" href="../categories/OI/Graph-Theory/">Graph Theory</a></li><li><a class="category-link" href="../categories/OI/Maths/">Maths</a></li><li><a class="category-link" href="../categories/OI/Search/">Search</a></li><li><a class="category-link" href="../categories/OI/Simulation/">Simulation</a></li><li><a class="category-link" href="../categories/STUDY/">STUDY</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">ARCHIVES</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="../archives/2022/10/">October 2022</a></li><li><a class="archive-link" href="../archives/2022/06/">June 2022</a></li><li><a class="archive-link" href="../archives/2022/01/">January 2022</a></li><li><a class="archive-link" href="../archives/2021/11/">November 2021</a></li><li><a class="archive-link" href="../archives/2021/04/">April 2021</a></li><li><a class="archive-link" href="../archives/2021/01/">January 2021</a></li><li><a class="archive-link" href="../archives/2020/11/">November 2020</a></li><li><a class="archive-link" href="../archives/2020/10/">October 2020</a></li><li><a class="archive-link" href="../archives/2020/08/">August 2020</a></li><li><a class="archive-link" href="../archives/2020/06/">June 2020</a></li><li><a class="archive-link" href="../archives/2020/05/">May 2020</a></li><li><a class="archive-link" href="../archives/2020/04/">April 2020</a></li><li><a class="archive-link" href="../archives/2020/02/">February 2020</a></li><li><a class="archive-link" href="../archives/2018/11/">November 2018</a></li><li><a class="archive-link" href="../archives/2018/10/">October 2018</a></li><li><a class="archive-link" href="../archives/2018/09/">September 2018</a></li><li><a class="archive-link" href="../archives/2018/08/">August 2018</a></li><li><a class="archive-link" href="../archives/2018/07/">July 2018</a></li><li><a class="archive-link" href="../archives/2018/05/">May 2018</a></li><li><a class="archive-link" href="../archives/2018/04/">April 2018</a></li><li><a class="archive-link" href="../archives/2018/03/">March 2018</a></li><li><a class="archive-link" href="../archives/2018/01/">January 2018</a>
	                    </ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="ABOUT">
		                ABOUT
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="FRIENDS">
		                FRIENDS
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="GALLERY">
		                GALLERY
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="TAG">
		                TAG
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/AokiUmi" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/images/0031.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >算法复习</h2></a>
         
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">

                <p>参考博客：<a href="https://www.zhihu.com/people/aokihao" target="_blank" rel="noopener">背包</a> <a href="https://www.shangmayuan.com/a/6c325edebbc54ef0a85917a9.html" target="_blank" rel="noopener">N,NP,NPC</a> <a href="https://zhuanlan.zhihu.com/p/54510444" target="_blank" rel="noopener">A*</a>这几个比较难所有参考比较多</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Poly-time: There exists constants $c &gt; 0$ and $d &gt; 0 $such that on every input of size N, its running time is bounded by $cN^d$ steps</p>
<h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><h2 id="链表-List"><a href="#链表-List" class="headerlink" title="链表(List)"></a>链表(List)</h2><p>记录头尾指针代表链表的开始和结束，中间用next表示前后关系的线性结构。</p>
<h3 id="支持的操作与其复杂度"><a href="#支持的操作与其复杂度" class="headerlink" title="支持的操作与其复杂度"></a>支持的操作与其复杂度</h3><p>· 头尾插入元素$O(1)$，删除尾部$O(n)$</p>
<p>· 其他位置插入删除都是$O(n)$（先要找到这个元素再在前后插入，知道位置只用$O(1)$)</p>
<p>双向链表就是多记录了一个$pre$，没啥大区别</p>
<h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><p><img src="/2021/11/08/算法复习/1.png" alt="  "></p>
<p>尾进尾出的结构，一般只需要一个指针，画成竖直状态比较方便理解</p>
<p>具体运用：逆波兰表达式，树的深度优先遍历</p>
<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><p>尾进头出的结构，有头尾两个指针的线性结构</p>
<p><img src="/2021/11/08/算法复习/2.png" alt=""></p>
<p>环形队列</p>
<p><img src="/2021/11/08/算法复习/3.png" alt=""></p>
<h2 id="哈希表-Hash-List"><a href="#哈希表-Hash-List" class="headerlink" title="哈希表(Hash List)"></a>哈希表(Hash List)</h2><p>自定义一种哈希方式，得到对应的哈希数，然后放在对应的数组格子里面。</p>
<p>但如果对应格子已经满了，就采用线性或者更跳跃的方式往后找空余的格子</p>
<p>线性探查(probe)——直接一个一个往后找</p>
<p>二次探查——$ (k+k*k)/2$     1，2，4，7，11 优点为花费时间更少</p>
<h2 id="树-Trees"><a href="#树-Trees" class="headerlink" title="树(Trees)"></a>树(Trees)</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>深度(depth)：<strong>根节点记为深度0</strong>，树的高度指最大深度</li>
<li>父亲(parent)与孩子(children)节点：从根节点往下遍历，由一条边相连的两个节点互为父亲与孩子节点，深度小的为父亲</li>
<li>度数(degree)：父亲节点的孩子数量</li>
<li>叶子节点(leaf)：孩子数量为0即度数为0的节点</li>
<li>根节点(root)：没有父亲的节点</li>
<li>祖先(ancestor)与子孙(descendant)：<strong>此概念均包括节点自己</strong>，子孙指以该节点为根的子树里所有的节点，祖先指从该节点到根节点路径上经过的所有节点</li>
</ul>
<h3 id="遍历方法-traversal"><a href="#遍历方法-traversal" class="headerlink" title="遍历方法(traversal)"></a>遍历方法(traversal)</h3><h4 id="广度优先遍历-Breadth-First-Traversal-BFS"><a href="#广度优先遍历-Breadth-First-Traversal-BFS" class="headerlink" title="广度优先遍历(Breadth-First Traversal) BFS"></a>广度优先遍历(Breadth-First Traversal) BFS</h4><p><img src="/2021/11/08/算法复习/8.png" alt=""></p>
<p>很显然的遍历，运用queue队列来进行，每次先pop对头节点，再push进去当前 对头节点所 </p>
<p>j</p>
<p>‘’有的孩子</p>
<h4 id="深度优先搜索-Depth-first-Traversal-DFS"><a href="#深度优先搜索-Depth-first-Traversal-DFS" class="headerlink" title="深度优先搜索(Depth-first Traversal) DFS"></a>深度优先搜索(Depth-first Traversal) DFS</h4><p>每次pop出栈头节点，push进去其孩子节点（<strong>从右到左</strong>）</p>
<p>用栈stack来实现</p>
<p><img src="/2021/11/08/算法复习/9.png" alt=""></p>
<h3 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h3><p>一种孩子最多只有两个的结构</p>
<h4 id="二叉树的深度遍历"><a href="#二叉树的深度遍历" class="headerlink" title="二叉树的深度遍历"></a>二叉树的深度遍历</h4><ul>
<li>前序遍历(pre-order)：根左右</li>
<li>中序遍历(in-order)：左根右</li>
<li>后序遍历(post-order)：左右根</li>
</ul>
<p><strong>都是以根的位置而记忆的</strong></p>
<h4 id="易混淆概念"><a href="#易混淆概念" class="headerlink" title="易混淆概念"></a>易混淆概念</h4><ul>
<li>满二叉树(full binary tree)：只要有孩子就必须满足两个，要么就没有</li>
</ul>
<p>​       性质：$n $ 个叶子节点，$2n-1$ 所有节点</p>
<ul>
<li><p>完美二叉树(perfect binary tree)：每层的节点全部是满的</p>
<p>性质：节点为$n=2^{h+1}-1$，高度为$h=\Theta(lnn)$，该层有$2^h$个叶子节点</p>
</li>
<li><p>完全二叉树(complete binary tree)：倒数第二层前都满足完美二叉树性质，最后一层可以不满</p>
<p>性质：节点为n，高度为$h=\lfloor lg(n) \rfloor$ </p>
</li>
</ul>
<h1 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h1><h2 id="三种复杂度表示的定义和证明"><a href="#三种复杂度表示的定义和证明" class="headerlink" title="三种复杂度表示的定义和证明"></a>三种复杂度表示的定义和证明</h2><p>• Upper bounds. T(n) is $ O(f(n))$ if there exist constants c &gt; 0 and $n_0 \geq  0$ such that for all $n \geq n_0$we have$ T(n) \leq c・f(n)$</p>
<p>• Lower bounds. T(n) is $Ω(f(n))$ if there exist constants $ c &gt; 0 $and $ n_0 \geq 0 $such that for all $n \geq n_0$ we have $T(n) \geq c・f(n)$</p>
<p>• Tight bounds. T(n) is $ Θ(f(n))$ if T(n) is both $ O(f(n))$ and $ Ω(f(n))$.</p>
<p>• Exist constants$ c_1, c_2, n_0$, such that$ c_1f(n) \leq T(n) \leq c_2f(n) $for all$ n \geq n_0$</p>
<p><img src="/2021/11/08/算法复习/24.png" alt=""></p>
<p><img src="/2021/11/08/算法复习/4.png" alt=""></p>
<p><img src="/2021/11/08/算法复习/5.png" alt=""></p>
<p><strong>关于复杂度的加法原则</strong></p>
<p><img src="/2021/11/08/算法复习/25.png" alt=""></p>
<p>多项式的一些复杂度定理：</p>
<p><img src="/2021/11/08/算法复习/26.png" alt=""></p>
<p>$O(k^2n^k/k!)=O(n^k)$</p>
<h1 id="数据结构相关算法"><a href="#数据结构相关算法" class="headerlink" title="数据结构相关算法"></a>数据结构相关算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>逆序对定义：原先数组内和排序后数组顺序相反的数对</p>
<p>计算逆序对：用归并排序</p>
<h3 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h3><p>将序列分为有序序列和无序序列两段，每次将无序序列开头的数插入前面的有序序列中，直到所有数都有序</p>
<p>复杂度：最坏$O(n^2)$,平均$O(n+d)$，原地排序，稳定排序</p>
<p>若有$d$对逆序对，则时间为$\Theta (n+d)$ </p>
<p>若$d=O(n)$，时间为$\Theta(n)$</p>
<h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h3><p>从前到后比较相邻两个数的大小，交换逆序对</p>
<p>同时分带不带flag判断，带的话有最优复杂度，不带就没有</p>
<p>复杂度：最坏$O(n^2)$ 最优$O(n)$ ，原地排序，稳定排序</p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h3><p>归并思路，合并两个子数列的时候就是利用队列合并，所以需要新开一个数组来合并序列</p>
<p>复杂度：$O(nlogn)$ 非原地排序，空间$O(n)$，稳定排序</p>
<p>计算逆序对，直接在$b_j&lt;a_i$时候$ans+=mid-i+1$</p>
<h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h3><p>每次选一个pivot找到他正确的位置，然后以pivot为中心再分为两个子序列，于是剩下的就是分治思路。</p>
<p>找位置的方法是，从pivot开始从左到右找第一个比pivot大的数，从右到左找第一个比pivot小的数</p>
<p>同时每次把pivot找到的正确位置之后，就是建立一颗二叉搜索树。</p>
<p>从这个角度思考复杂度$a_i,a_j$会被比较到的概率为$2/j-i+1$，只有互为孩子父亲才会被比较到</p>
<p>故复杂度就为所有数对的可能性相加  $2n(lnn+1)$</p>
<p>复杂度：平均$O(nlogn)$ 最坏$O(n^2)$，原地排序，非稳定排序</p>
<h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h3><p>先把数据建成大根堆，每次再将堆头和最末尾的元素交换，然后pop掉这个最大的元素，再重新调成大根堆结构，这样保证每次操作都能找到现在无序序列中最大的元素，依次把大根堆规模变小，使无序序列长度逐渐变小为0。</p>
<p>复杂度：$O(nlogn)$，非原地排序，非稳定排序</p>
<h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h3><p>每次从前往后找出无序序列中最小的一个数和无序序列第一个数交换位置，暴力找，很慢。</p>
<p>复杂度：$O(n^2)$，原地排序，非稳定排序</p>
<h3 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h3><p>一个在归并算法中运用的求复杂度的理论<br>$<br>T(n)=aT(\frac{n}{b})+f(n),T(0)=0,T(1)=\Theta(1)<br>$<br>a代表子问题的数量，n/b指子问题的大小，f(n)是divide and combine</p>
<p><img src="/2021/11/08/算法复习/6.png" alt=""></p>
<p>这个理论运用的实例：求矩阵乘法</p>
<p><img src="/2021/11/08/算法复习/7.png" alt=""></p>
<h2 id="哈夫曼编码-Huffman-Coding"><a href="#哈夫曼编码-Huffman-Coding" class="headerlink" title="哈夫曼编码(Huffman Coding)"></a>哈夫曼编码(Huffman Coding)</h2><p>一种按字符出现频率来实现编码的方式，以此来节省空间，利用二叉树，优先队列来存储</p>
<p>先用优先队列记录每个字符的出现频率，频率越高在优先队列中优先级越低，就放在队列越后面</p>
<p><img src="/2021/11/08/算法复习/11.png" alt=""></p>
<p>建树过程使从前到后两两合并，得到的子树顺次插入序列，期中单字符优先级大于多个字符</p>
<p><img src="/2021/11/08/算法复习/12.png" alt=""></p>
<h2 id="二叉堆与优先队列-Heap"><a href="#二叉堆与优先队列-Heap" class="headerlink" title="二叉堆与优先队列(Heap)"></a>二叉堆与优先队列(Heap)</h2><p>优先队列就是队头固定最大最小值的数组，感觉就是排好序的数列</p>
<p>二叉堆的性质：大根堆就是父亲节点大于左右孩子，但左右孩子大小关系不确定，小根堆就是大小关系反一下</p>
<p>堆是一个完全二叉树，将数据储存在数组里的，利用下标一个父亲节点为$n$则左孩子为$2n$，右孩子$2n+1$</p>
<h3 id="操作与复杂度"><a href="#操作与复杂度" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><ul>
<li><p>push：直接先新节点顺次加入树的最后一个节点，然后执行percolate操作，我的理解是向上翻，每次比较第$\lceil n/2 \rceil(n&gt;&gt;1)$节点和自己的大小，若不符合定义就交换。</p>
</li>
<li><p>pop：将需要pop的节点与当前堆最后一个元素交换，直接抛弃现在最后一个元，再执行percolate操作，在这里是下沉，再从根节点往下比较自己孩子$(2n,2n+1)$与自己的大小，不符合定义就交换。</p>
</li>
<li><p>build：push每个元素或者用Floyd’s Method $O(nlogn)$</p>
<p>大体看push和pop都当成$O(nlogn)$</p>
</li>
</ul>
<p>空间都是$O(n)$</p>
<p><img src="/2021/11/08/算法复习/10.png" alt=""></p>
<p>Floyd’s Method将小根堆调成为大根堆（或者将普通堆调整），就是思路是先从上往下找到所有不符合定义的根节点，从编号最大的节点依次往上做percolate操作调成，依次调整完就行。</p>
<h2 id="斐波那契堆-Fibonacci-Heap"><a href="#斐波那契堆-Fibonacci-Heap" class="headerlink" title="斐波那契堆(Fibonacci Heap)"></a>斐波那契堆(Fibonacci Heap)</h2><p><img src="/2021/11/08/算法复习/19.jpg" alt=""></p>
<p>$FibNode$是斐波那契堆的节点类，它包含的信息较多。$key$是用于比较节点大小的，$degree$是记录节点的度，$left$和$right$分别是指向节点的左右兄弟，$child$是节点的第一个孩子，$parent$是节点的父节点，$marked$是记录该节点是否被删除第1个孩子($marked$在删除节点时有用)。</p>
<p>$FibHeap$是斐波那契堆对应的类。$min$是保存当前堆的最小节点，$keyNum$用于记录堆中节点的总数，$maxDegree$用于记录堆中最大度，而$cons$在删除节点时来暂时保存堆数据的临时空间。<br>不具体介绍每部操作如何实现<a href="https://blog.csdn.net/qq_40061421/article/details/81571132" target="_blank" rel="noopener">教学指路</a></p>
<table>
<thead>
<tr>
<th>过程</th>
<th>二叉堆</th>
<th>斐波那契堆</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT</td>
<td>$O(logn)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>MINIMUM</td>
<td>$O(logn)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>UNION</td>
<td>$O(logn)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>DELETE</td>
<td>$O(logn)$</td>
<td>$O(logn)$</td>
</tr>
</tbody>
</table>
<h2 id="二叉搜索树-Binary-Search-Trees"><a href="#二叉搜索树-Binary-Search-Trees" class="headerlink" title="二叉搜索树(Binary Search Trees)"></a>二叉搜索树(Binary Search Trees)</h2><p>满足根节点的左子树所有值都小于自己，右子树所有值都大于自己的二叉数</p>
<p>理解：$BST$的结构主要和插入元素的顺序有关，优不优化完全取决顺序，所以才有了$AVL$树</p>
<h3 id="操作与复杂度-1"><a href="#操作与复杂度-1" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><ul>
<li>Insert：总的来说就是顺着根节点往下比较，每次看是比当前节点大还是小，小就往左边走，大就往右边走，知道找到一个空位置就行</li>
<li>Find：和插入同理，顺着树往下走就完了</li>
<li>Erase：这个分三种情况，若该节点为叶子节点直接删除就行，如果有一个子树，把这个子树接上去就行，如果有两个子树，找到右子树中最小的元素和根换位置再删掉根就行，这样能保证现在右子树所有值还是大于根（最小元素），左子树所有值也小于根。同时这个最小的值一定只有一个子树或者右节点可以证明，因为使最小的不可能有左子树</li>
</ul>
<p>由于所有操作都等于$O(h)$，但高度决定于顺序所以没有定值，但最优$O(lognn)$，最坏$O(n)$</p>
<p><strong>一些进阶设计</strong></p>
<p>设计$next$边：如果该节点有右子树，根向右子树最小的值连next边</p>
<p>设计$previous$边：如果该节点没有右子树，找到第一个大于自己的节点向他连一条边</p>
<p>这个课件里没有讲有啥用，我感觉就和AC自动机一样，但不知道有啥实际运用</p>
<p>感觉是next在删除中比较有用吧</p>
<p>用$BST$找第k大：直接看根节点左右子树大小，若左子树大小$l=k$，就是root。若$l&gt;k$继续在左子树中找最大的，否则在右子树中找$k-l-1$大的，就是一个递归思路</p>
<h2 id="二叉平衡搜索树-AVL-Trees"><a href="#二叉平衡搜索树-AVL-Trees" class="headerlink" title="二叉平衡搜索树(AVL Trees)"></a>二叉平衡搜索树(AVL Trees)</h2><p><del>就你是我以前天天写到吐的玩意是吧！</del></p>
<p>就是$BST$升级版，需要保证左右子树高度差距不大于1，于是所有操作的复杂度就能在$O(logn)$了</p>
<p>完全二叉搜索树=平衡树</p>
<p>计算满足高度为h的最小平衡树$F(h)$：可得此为斐波那契数列</p>
<p><img src="/2021/11/08/算法复习/13.png" alt=""></p>
<p>得到$F(h)\approx 1.8994\phi ^h-1,\phi \approx 1.6180$</p>
<p>$F(h)=\Theta (\phi ^h)$</p>
<p>所以可得高度为h的最大平衡树$log_{\phi}{(\frac{n+1}{1.8944})}=log_{\phi}{(n+1)-1.3277}=1.4404*lg(n+1)-1.3277$</p>
<h3 id="操作与复杂度-2"><a href="#操作与复杂度-2" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><p>所有操作和$BST$一样，只是插入和删除都多了一个维和操作，这里具体分析如何维护也就是$Splay$核心，同时维护都是$O(1)$</p>
<p>基本操作分为左旋和右旋</p>
<p>右旋</p>
<p><img src="/2021/11/08/算法复习/15.jpg" alt=""></p>
<p>左旋</p>
<p><img src="/2021/11/08/算法复习/16.jpg" alt=""></p>
<p>核心是找到处于不平衡状态的根，看是怎么样子不平衡</p>
<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p>左子树大于右子树两个高度，直接右旋一次就行</p>
<p><img src="/2021/11/08/算法复习/14.jpg" alt=""></p>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p>右子树大于左子树两个高度，直接左旋一次就行</p>
<p><img src="/2021/11/08/算法复习/17.jpg" alt=""></p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p>将新的节点插入到了 n 的左孩子的右子树上导致的不平衡的情况。这时我们需要的是先对 i 进行一次左旋再对 n 进行一次右旋。</p>
<p><img src="/2021/11/08/算法复习/18.jpg" alt=""></p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p>和LR同理不知道为啥没有图给我偷了（</p>
<p>总之是将新的节点插入到了 n 的右孩子的左子树上导致的不平衡的情况。这时我们需要的是先对 i 进行一次右旋再对 n 进行一次左旋。</p>
<p>再来看基本操作</p>
<ul>
<li>Insertion 只可能需要一次维护 $O(1)$</li>
<li>Erase 可能需要$O(h)$次数，需要沿着删除的节点从下到上沿着到根节点的路径往上检查节点是否需要为维护 故复杂度$O(log n)$</li>
</ul>
<h2 id="并查集-Disjoint-Set"><a href="#并查集-Disjoint-Set" class="headerlink" title="并查集(Disjoint Set)"></a>并查集(Disjoint Set)</h2><h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h3><p>主要操作是$findf()$和$union$，每次$union就是把两个节点接到一颗树上，findf就是找到这个节点对应的根节点。</p>
<p>关于这个add的方式主要分为两种</p>
<p>例子$union(A,B)，root(A)=C,root(B)=D$</p>
<p>1.Only with path compression</p>
<p>指只看前后顺序来merge，把D接在C下面</p>
<p>2、Only with union-by-size optimization(又称rank优化)</p>
<p>指当两颗子树高度一直时按前后顺序加，若不同就把高度更低的加到高度高的树根下面</p>
<p>如果$height(C)&gt;height(D)$，把D接在C下面，否则和1相同</p>
<p>还有一种size优化，是比较每颗子树的size来合并，但没有rank好</p>
<p>一般写代码会用到路径压缩的方式，即所有子树高度都压缩到1，就是最常见的写法。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findf</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token punctuation">)</span><span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">findf</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">dij_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fx<span class="token operator">=</span><span class="token function">findf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fy<span class="token operator">=</span><span class="token function">findf</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fx<span class="token operator">==</span>fy<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">;</span>
    fa<span class="token punctuation">[</span>fx<span class="token punctuation">]</span><span class="token operator">=</span>fy<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>若不使用路径压缩，我们通过并查集得到的树有一下结论。</p>
<p><img src="/2021/11/08/算法复习/17.png" alt=""></p>
<p>假如这颗树高度为$h$，有节点数$\sum_{k=0}^{h}\dbinom{h}{k}=2^h=n$</p>
<p>深度$\sum_{k=0}^{h}k\dbinom{h}{k}=h2^{h-1}$</p>
<p>平均深度$\frac{h2^{h-1}}{2^h}=\frac{h}{2}=\frac{lg(n)}{2}$</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$findf$：优化前$O(n)$，rank优化+路径压缩后$O(log^*n)$</p>
<p><img src="/2021/11/08/算法复习/18.png" alt=""></p>
<table>
<thead>
<tr>
<th>n</th>
<th>log* n</th>
</tr>
</thead>
<tbody>
<tr>
<td>(−∞, 1]</td>
<td>0</td>
</tr>
<tr>
<td>(1, 2]</td>
<td>1</td>
</tr>
<tr>
<td>(2, 4]</td>
<td>2</td>
</tr>
<tr>
<td>(4, 16]</td>
<td>3</td>
</tr>
<tr>
<td>(16, 65536]</td>
<td>4</td>
</tr>
<tr>
<td>(65536, 2^65536]</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>总之这个$log^*n$优于$logn$</p>
<hr>
<hr>
<p>以上为数据结构的相关算法，接下来是图论。</p>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>有向图(Directed graph)：点之间的边指定方向。如由A→B最大边数$|E|\le O(2|V|^2)=O(|V|^2)$</li>
<li>无向图(Undirected graph)：点之间的边不指定方向。最大边数$|E|\le O(|V|^2)$</li>
<li>度(Degree)： 出度(Out)入度(In)针对有向图，计数从一个点出去的边数和接受的边数。对于无向图就是一个点连了多少条边</li>
<li>子图(Sub-graph)：从原图中选取部分边和点</li>
<li>顶点导出子图(Vertex-induced sub-graphs)：所有的点都选，边部分不选</li>
<li>路径(Path)：两点之间遍历到的点集合</li>
<li>最简路径(Simple path)：点边不可重复走</li>
<li>最简回路(Simple cycle)：（除去头尾）点边不可重复走的环</li>
<li>联通(Connectedness)：两点之间存在路径则联通</li>
<li>树(Tree)：每两点间都只有一条独立的路径</li>
<li>森林(Forest)：没有任何回路的图，树的合集</li>
<li>联通分量(Connected Components)：连通的子图</li>
</ul>
<h2 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h2><ul>
<li><p>邻接矩阵(Adjacency Matrix)：空间$O(|V|^2)$，遍历所有邻接的点$\Theta(|V|)$</p>
</li>
<li><p>邻接表(Adjacency List)：空间$\Theta (|V|+|E|)$，遍历所有邻接的点$\Theta(|E|/|V|)$ 更适合于</p>
</li>
</ul>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul>
<li>深度优先搜索（用栈）：递归或者栈，一次性一条路走到底，若到底则返回遍历，继续往下找</li>
<li>广度优先搜索（用队列）每次push进去邻接的点，pop出去的点就是遍历顺序</li>
</ul>
<p>两种遍历都可以检查图的联通性</p>
<p><strong>关于二分图：</strong></p>
<p>如果某个图为二分图，那么它至少有两个顶点，且其所有回路的长度均为偶数，任何无回路的的图均是二分图。</p>
<p>算法判定：用二分图染色</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="最小生成树-Minimum-Spanning-Tree"><a href="#最小生成树-Minimum-Spanning-Tree" class="headerlink" title="最小生成树(Minimum Spanning Tree)"></a>最小生成树(Minimum Spanning Tree)</h3><p>总之是求图上构造一棵树是所有点连通，并且边的权值之和最小。</p>
<p>默认是邻接矩阵实现</p>
<p><strong>prim算法</strong></p>
<ul>
<li>首先初始化距离为INF</li>
<li>随机从一个点开始，先遍历他邻接的点更新一下初始距离，再遍历所有的点找到一个距离最短的点，并记录下来 $O(|V|^2)$,相当于pop小根堆堆顶的点</li>
<li>再从这个点开始遍历邻接所有的点，更新距离$O(|E|)$，相当于加入小根堆</li>
<li>直到遍历到所有点</li>
</ul>
<p>此算法需要储存邻接的边信息，比如需要前向星</p>
<p>故总的时间复杂度$O(|V|^2+|E|)=O(|V|^2)$</p>
<p>用邻接表$O(|V|ln|V|+|E|ln|V|)=O(|E|ln|V|)$</p>
<p>斐波那契堆$O(|V|ln|V|+|E|)$二叉堆$O(|V|ln|V|+|E|ln|V|)=O(|E|ln|V|)$</p>
<p><strong>Kruskal</strong>算法</p>
<ul>
<li>先将边按照权值排序（从小到大）$O(ln|E|)$</li>
<li>遍历所有的边，对于每条边的连接的两点$u,v$，对其进行一次并查集的判断，看这两个点是否联通，如果联通则放弃，不连通则加入生成树$O(|E|ln|V|)$</li>
</ul>
<p>复杂度$O(ln|E|+|E|ln|V|)=O(|E|ln|V|)$</p>
<p>不需要前向星只需要结构体</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>就是根据图上每个点的入度来排序的算法，每次找到所有点中入度为0的点，将其pop出队列，然后将这个点所邻接的点的入度–，更新后重新寻找入度为0的点。</p>
<p>一些结论：</p>
<ul>
<li>DAG一定有拓扑排序，有拓扑排序一定是DAG（有向无环图）</li>
<li>DAG一定至少有一个入度为0的点</li>
<li>DAG的子图一定是DAG</li>
<li>不是DAG一定没有拓扑排序</li>
</ul>
<p><strong>复杂度：</strong></p>
<p>$O(|V|+|V|^2)=O(|V|^2)$不使用堆，每次遍历所有的点找入度为0的点</p>
<p>若使用堆优化$O(|V|+|E|)$邻接表，$O(|V|^2)$邻接矩阵</p>
<p>若某次操作后，所有剩下的点没有入度为0的点，则有环，因此可以用拓扑排序判环</p>
<p>用拓扑排序找critical path</p>
<p>总之描述是每个点带一个时间权值，当入度都为0的时候可以同时进行操作，求所有任务完成的最短时间和路径。</p>
<p>就用拓扑排序，每次记录一下前一个点是哪个就可以了，删除点的时候顺便更新邻接点的最短时间就可以了</p>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>声明：所有最短路算法遇到负环均没有答案</p>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>方法是先将所有点的距离都赋值为INF，从起点开始，每次找到距离最短的点，从这个点来更新邻接的点的距离</p>
<p>$dis[u]=min(dis[u],dis[v]+w(u,v))$</p>
<p><strong>注意：</strong></p>
<ul>
<li>$dijkstra$不能计算有副边边权的最短路</li>
<li>有向图无向图都一样</li>
</ul>
<p><strong>复杂度：</strong></p>
<p>邻接矩阵：$O(|V|(|V|+|V|))=O(|V|^2)$</p>
<p>邻接表：$O(|V|^2+|E|)=O(|V|^2)$</p>
<p>堆优化+邻接表：二叉堆 $O(|V|ln|V|+|E|ln|V|)=O(|E|ln|V|)$</p>
<p>斐波那契堆 $O(|V|ln|V|+|E|)$</p>
<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>我认为十分垃圾的算法，总之唯一优点是可以处理负边</p>
<p><img src="/2021/11/08/算法复习/19.png" alt=""></p>
<p>最后的循环是用来判断负环</p>
<p><strong>复杂度：</strong></p>
<p>$O(|V|+|V||E|)=O(|V||E|)$</p>
<h3 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h3><p>Bellman-Ford 的队列优化 和Dijkstra就是孪生兄弟</p>
<p>基本写法只有vis数组的更新以及堆和队列区别，一旦入队，vis变为1，出队就变为0，松弛的时候遇到不在队列里的点就进队，在队列里面就只是更新距离</p>
<p>Dijkstra是一旦出堆一次就不会再进去</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//队列存的是待更新的点</span>
queue⬅st
<span class="token keyword">while</span><span class="token punctuation">(</span>queue不空<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Ⅰ<span class="token punctuation">.</span>t<span class="token operator">=</span>queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取出队首元素</span>
       q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Ⅱ<span class="token punctuation">.</span>更新t的所有出边 t→b（权值为w）
       <span class="token comment" spellcheck="true">//如果更新成功的话，就把b加入队列，b就是待更新的点，先判断b是否已经被更新过了，如果已经更新过了</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一般情况下时间复杂度：$O ( |E| )$，最坏的情况下是：$O(|V||E|)$</p>
<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>当$|E|=\Theta(|V|^2)$，用$Dijkstra$求所有点对的最短路$O(|V|^3ln|V|)$太拉了所以用Floyd</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
  dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意：</strong>如果是无向图，第二层只需要遍历$k+1-n$，时间节约约1/2</p>
<p>可以用Flody判断联通性以及负环，跑完后只要有负值就是负环</p>
<h3 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h3><p>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</p>
<p>其原理也很简单。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p>
<p><img src="/2021/11/08/算法复习/1.gif" alt=""></p>
<p>启发式搜索，为每个点添加一个优先级函数</p>
<p>A*算法通过下面这个函数来计算每个节点的优先级。</p>
<p>$f(n)=g(n)+h(n)$</p>
<p>其中：</p>
<ul>
<li>$f(n)$是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</li>
<li>$g(n) $是节点n距离起点的代价。</li>
<li>$h(n)$是节点n距离终点的预计代价，这也就是A*算法的启发函数。关于启发函数我们在下面详细讲解。</li>
</ul>
<p>A*算法在运算过程中，每次从优先队列中选取$f(n)$值最小（优先级最高）的节点作为下一个待遍历的节点。</p>
<pre><code>* 初始化open_set和close_set；
* 将起点加入open_set中，并设置优先级为0（优先级最高）；
* 如果open_set不为空，则从open_set中选取优先级最高的节点n：
    * 如果节点n为终点，则：
        * 从终点开始逐步追踪parent节点，一直达到起点；
        * 返回找到的结果路径，算法结束；
    * 如果节点n不是终点，则：
        * 将节点n从open_set中删除，并加入close_set中；
        * 遍历节点n所有的邻近节点：
            * 如果邻近节点m在close_set中，则：
                * 跳过，选取下一个邻近节点
            * 如果邻近节点m也不在open_set中，则：
                * 设置节点m的parent为节点n
                * 计算节点m的优先级
                * 将节点m加入open_set中
</code></pre><p>close_set：储存出队的节点，open_set：目前队列，已$f(n)$为依据的小根堆，parent用来记录路径</p>
<p><strong>一些结论：</strong></p>
<ul>
<li>在极端情况下，当启发函数$h(n)$始终为0，则将由$g(n)$决定节点的优先级，此时算法就退化成了$Dijkstra$算法。</li>
<li>如果$h(n)$始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当$h(n)$的值越小，算法将遍历越多的节点，也就导致算法越慢。</li>
<li>如果$h(n)$完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</li>
<li>如果$h(n)$的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。</li>
<li>在另外一个极端情况下，如果$h(n)$相较于$g(n)$大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。</li>
</ul>
<p>Tree Search：不设置vis数组，不考虑节点有无被遍历过</p>
<p>Graph Search：设置vis数组，每次出堆的时候就标记visited，每次只遍历邻接的unvisited的点</p>
<p>$h(n)$又称heuristic distance，关于这个距离有两个性质</p>
<ul>
<li>Admissible Heuristics，就是$h(n)$始终小于等于节点n到终点的代价</li>
</ul>
<p><strong>Theorem: If <em>h(n)</em> is admissible, A* using TREE-SEARCH is optimal </strong></p>
<ul>
<li>Consistent Heuristics</li>
</ul>
<p><img src="/2021/11/08/算法复习/20.png" alt=""></p>
<p>A heuristic is consistent if for every node <em>n</em>, every successor <em>n’</em> of <em>n</em></p>
<p>generated by any action <em>a</em>, we have <strong>h(n) ≤ c(n,a,n’) + h(n’)</strong></p>
<p>If <em>h</em> is consistent, we have</p>
<p>f(n’) = g(n’) + h(n’) =g(n) + c(n,a,n’) + h(n’) (g(n’)=g(n)+c(n.a.n’)) </p>
<p>≥ h(n) + h(n) = f(n) (consistency)</p>
<p>f(n’) ≥ f(n)</p>
<p>这个性质只针对两个点，基本就看$h(n),h(n’)+w(n,n’)$</p>
<p><strong>Theorem: If <em>h(n)</em> is consistent, A* using GRAPH-SEARCH is optimal</strong></p>
<h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>主要列举一下证明，反证法</p>
<p><img src="/2021/11/08/算法复习/27.png" alt=""></p>
<h3 id="Inversions"><a href="#Inversions" class="headerlink" title="Inversions"></a>Inversions</h3><p>An inversion in schedule S is a pair of jobs i and j such that: i &lt; j but j scheduled before i</p>
<p><img src="/2021/11/08/算法复习/28.png" alt=""></p>
<p>贪心没有inversions，inversions一定相邻</p>
<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>这个就不说理论了，直接上例题</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ul>
<li><p>01背包</p>
<p>$dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]),j &gt;= w[i]$</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>
f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>完全背包</p>
<p>$dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) ,j &gt;= w[i]$</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>多重背包</p>
<p>前面不同就是每种物品是有限个$n[i]$</p>
<p>$dp[i][j] = max{(dp[i-1][j − k<em>w[i]] + k</em>v[i]) for every k},k &lt;= min(n[i], j/w[i])$</p>
</li>
</ul>
<p>其他情形：</p>
<ul>
<li><p>恰好装满：</p>
</li>
<li><p>背包问题有时候还有一个限制就是必须恰好装满背包，此时基本思路没有区别，只是在初始化的时候有所不同。</p>
<p>如果没有恰好装满背包的限制，我们将dp全部初始化成0就可以了。因为任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。如果有恰好装满的限制，那只应该将$dp[0,1,..N][0]$初始为0，其它dp值均初始化为<code>-inf</code>，因为此时只有容量为0的背包可以在什么也不装情况下被“恰好装满”，其它容量的背包初始均没有合法的解，应该被初始化为<code>-inf</code>。</p>
</li>
<li><p>求方案数量：$dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]]) // j &gt;= w[i]$</p>
</li>
</ul>
<h4 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h4><ol>
<li>Partition Equal Subset Sum（分割等和子集）</li>
</ol>
<p>题目给定一个只包含正整数的非空数组。问是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>由于所有元素的和sum已知，所以两个子集的和都应该是sum/2（所以前提是sum不能是奇数），即题目转换成从这个数组里面选取一些元素使这些元素和为sum/2。如果我们将所有元素的值看做是物品的重量，每件物品价值都为1，所以这就是一个恰好装满的01背包问题。</p>
<ol start="2">
<li>Coin Change（零钱兑换）</li>
</ol>
<p>题目给定一个价值amount和一些面值，假设每个面值的硬币数都是无限的，问我们最少能用几个硬币组成给定的价值。</p>
<p>如果我们将面值看作是物品，面值金额看成是物品的重量，每件物品的价值均为1，这样此题就是是一个恰好装满的完全背包问题了。不过这里不是求最多装入多少物品而是求最少，我们只需要将完全背包的转态转移方程中的max改成min即可，又由于是恰好装满，所以除了dp[0]，其他都应初始化为<code>INT_MAX</code>。</p>
<ol start="3">
<li>Target Sum（目标和）</li>
</ol>
<p>这道题给了我们一个数组（元素非负），和一个目标值，要求给数组中每个数字前添加正号或负号所组成的表达式结果与目标值S相等，求有多少种情况。</p>
<p>假设所有元素和为sum，所有添加正号的元素的和为A，所有添加负号的元素和为B，则有<code>sum = A + B</code> 且 <code>S = A - B</code>，解方程得<code>A = (sum + S)/2</code>。即题目转换成：从数组中选取一些元素使和恰好为<code>(sum + S) / 2</code>。可见这是一个恰好装满的01背包问题，要求所有方案数，将1.2节状态转移方程中的max改成求和即可。需要注意的是，虽然这里是恰好装满，但是dp初始值不应该是<code>inf</code>，因为这里求的不是总价值而是方案数，应该全部初始为0（除了dp[0]初始化为1）。</p>
<p><strong>一些其他的dp问题</strong></p>
<ul>
<li><p>最长公共子串</p>
<p>$dp[i][j]$表示比较到$A[i],B[j]$时候的最长公共子串，且此时$A[i],B[j]$为最长公共子串的最后一个元素，故要求$A[i]=B[j]$</p>
<p>当$A[i]=B[j],dp[i][j]=dp[i-1][j-1]+1$，当$A[i]!=B[j],dp[i][j]=0$</p>
<p>答案是每次更新以后，记一个最大值就是答案</p>
</li>
<li><p>最长公共子序列</p>
<p>$dp[i][j]$表示比较到$A[i],B[j]$时候的最长公共子序列</p>
<p>当$A[i]=B[j],dp[i][j]=dp[i-1][j-1]+1$，$A[i]!=B[j],dp[i][j]=max(dp[i-1][j],dp[i][j-1])$</p>
</li>
<li><p>最长回文子序列</p>
<p>$dp[i][j]$表示字串从i到j的最长回文子序列长度</p>
<p>当$s[i]=s[j],dp[i][j]=dp[i+1][j-1]+2$，当$s[i]!=s[j],dp[i][j]=max(dp[i+1][j],dp[i][j-1])$注意i从n到1枚举，j从i+1到n枚举</p>
</li>
<li><p>最长回文子串</p>
<p>$dp[i][j]$表示$S_i,…,S_j$是否回文子串，1为是，0为否</p>
<p>当$s[i]=s[j],dp[i][j]=dp[i+1][j-1]+2$，当$s[i]!=s[j],dp[i][j]=0$</p>
<p> 但枚举方式有区别，不能直接像回文序列一样枚举，因为不能保证$dp[i+1][j-1]$已经被计算过，故我们采取按回文子串长度来枚举，用一个数记录L最长长度</p>
<p>先初始化$dp[i][i]=1,dp[i][i+1]=1 (s[i]=s[i+1])$</p>
<p>之后从L从3到n，i从1到i+L-1&lt;n枚举就行</p>
</li>
</ul>
<h2 id="N-NP-NPC-NP-hard"><a href="#N-NP-NPC-NP-hard" class="headerlink" title="N,NP,NPC,NP-hard"></a>N,NP,NPC,NP-hard</h2><h3 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h3><ul>
<li>P Problem：这个应该最易理解，就是一个问题能够在Polynominal的时间的获得解决，固然，是对于任意input size。</li>
<li>NP Problem：对于一类问题，咱们可能没有一个已知的快速的方法获得问题的答案，可是若是给咱们一个candidate answer，咱们可以在polynominal的时间内验证这个candidate answer究竟是不是咱们已知问题的答案，这类问题叫作NP problem。因此很显然 P Problem是NP problem的一个子集。</li>
<li>NP-hard Problem：对于这一类问题，用一句话归纳他们的特征就是“at least as hard as the hardest problems in NP Problem”， 就是NP-hard问题至少和NP问题同样难。</li>
<li>NP-Complete Problem：对于这一类问题，他们知足两个性质，一个就是在polynomial时间内能够验证一个candidate answer是否是真正的解，另外一个性质就是咱们能够把任何一个NP问题在polynomial的时间内把他的input转化，使之成为一个NP-complete问题（即<strong>规约</strong>）。NP-Complete Problem问题能够互相转换 (在多项式时间内)，只要其中一个问题能够在多项式时间内解决，那么其余问题也都将能够在多项式时间内解决。</li>
</ul>
<p><img src="/2021/11/08/算法复习/21.png" alt=""></p>
<h3 id="规约——一种技巧"><a href="#规约——一种技巧" class="headerlink" title="规约——一种技巧"></a>规约——一种技巧</h3><ol>
<li>把P的输入转化到Q的输入；</li>
<li>把Q的输出转化到P的输出。</li>
<li>下图展现了上述规约过程。其中 $T_1 $在多项式时间将 P的输入 $P_{input }$转化成Q的输入 $Q_{input}$ ; T2 在多项式时间将 Q的输出$ Q_{output} $转化成P的输出$ P_{output} $。也就是说NP-hard问题 P 能够依赖于对问题 Q 的解决而解决。那么 Q 至少比 P 要难，即 P&lt;=Q 。</li>
</ol>
<p><img src="/2021/11/08/算法复习/22.png" alt=""></p>
<h3 id="如何对问题证实"><a href="#如何对问题证实" class="headerlink" title="如何对问题证实"></a>如何对问题证实</h3><p>下面来列出了一些常见的证实问题及其证实套路。</p>
<ul>
<li><p><strong>证实NP问题</strong>：这个容易，即给你一个结果，你能在polynomial的时间内验证该结果的正确性。</p>
</li>
<li><p><strong>证实NP-hard问题</strong>：咱们要证实一个问题是NP-hard的时候，咱们一般要作的是找到一个已被证实了的NPC问题，并把这个NPC问题归约到该问题上去（即NPC&lt;=NP-hard）。</p>
</li>
<li><p><strong>证实NP-Complete问题</strong></p>
<p>分如下两步：</p>
<ol>
<li>第一步证实这个问题属于NP；</li>
<li>第二步，证实这个问题是NP-hard的。也就是找一个NPC问题把它规约过去</li>
</ol>
</li>
</ul>
<p><img src="/2021/11/08/算法复习/23.png" alt=""></p>
<p>下图列出了几个已被发现NP-Complete问题，及其规约关系。能够看出全部的<strong>NP</strong>问题均可以规约到<strong>SAT</strong>(即<strong>NP</strong>&lt;=<strong>SAT</strong>)，也就是说<strong>SAT</strong>至少与<strong>NP</strong>问题同样难，或者若是解决了<strong>3SAT</strong>问题，全部的NP问题就解决了。一样的，<strong>SAT</strong>&lt;=<strong>3SAT</strong>，<strong>3SAT</strong>&lt;=<strong>Independent Set</strong>，<strong>Independent Set</strong>&lt;=<strong>Vertex Cover</strong> OR <strong>Clique</strong>。算法</p>
<p>规约关系具备传递性，因此有<strong>3SAT</strong>&lt;=<strong>Vertex Cover</strong>，<strong>NP</strong>&lt;=<strong>NP-Complete</strong>。 事实上，因为<strong>NP-Complete</strong> ⊂ <strong>NP</strong> 且 <strong>NP</strong>&lt;=<strong>NP-Complete</strong>，能够推导出 全部的<strong>NP-Complete</strong> 能够相互规约，也就是全部的<strong>NP-Complete</strong>都是等价的。</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 valine -->
<div id="comment">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#comment' ,
        notify: false,
        verify: false,
        app_id: 'fUtpOauFo2JhcWoBFEnnppJW-gzGzoHsz',
        app_key: 'gFTwG42ACHuyrmwhMfgxcRQQ',
        placeholder: '留下你的评论吧~~',
        pageSize: '10',
        avatar: '',
        avatar_cdn: 'https://gravatar.loli.net/avatar/'
    });
</script>
</div>
<style>
   #comment{
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2023总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":125,"height":250},"mobile":{"show":false},"log":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":125,"height":250},"mobile":{"show":false},"log":false});</script></body>




 	

    </script>
</html>
