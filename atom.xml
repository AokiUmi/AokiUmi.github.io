<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki_Umi</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-10-08T03:58:01.392Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Aoki Umi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2023/10/06/CS320%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2023/10/06/CS320%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-06T21:03:33.874Z</published>
    <updated>2023-10-08T03:58:01.392Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> CS320学习笔记<span class="token key atrule">date</span><span class="token punctuation">:</span> 2023/10/7 19<span class="token punctuation">:</span><span class="token datetime number">11:08</span><span class="token key atrule">tags</span><span class="token punctuation">:</span><span class="token punctuation">-</span> python<span class="token punctuation">-</span> study_notes<span class="token key atrule">categories</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> CS<span class="token punctuation">-</span> PYTHON<span class="token punctuation">-</span> ALGORITHM<span class="token key atrule">thumbnail</span><span class="token punctuation">:</span> /images/0051.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Reproducibility"><a href="#Reproducibility" class="headerlink" title="Reproducibility"></a>Reproducibility</h1><p><strong>reproducibility</strong>: others can run our analysis code and get same results</p><p>Each process owns address space (one huge list)</p><p>Multiple lists start at different address in address space; normally, append is faster than pop, since pop need to move all next items forward 4 bytes.</p><p>Use ASCII to store strings, use specific <strong>ISA to store codes</strong>.</p><p>CPU interact with memory: </p><ul><li><p>keep track of what instruction we’re on</p></li><li><p>understand instruction codes</p></li></ul><p>A CPU can <strong>only run programs</strong> that <strong>use instructions it understands</strong>.</p><p><strong>CPU:</strong> chip that executes instructions, tracks position in code</p><p>process: a running program</p><h2 id="Interpreters"><a href="#Interpreters" class="headerlink" title="Interpreters"></a>Interpreters</h2><p>make it easier to run the same code on different machines</p><p>A compiler is another tool for running the same code on different CPUs</p><p>Interpreter <strong>translates Python code</strong> into machine code for a give CPU instruction set, </p><p>hiding details about the <strong>CPU’s instruction</strong> set from the programmer.</p><p>Translate from the instructions of one CPU architecture to instructions of a different CPU architecture.</p><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>OS jobs: Allocate and Abstract Resources, software that <strong>manage computer hardware and software resources</strong>, providing a stable and consistent interface for users and applications to interact with the computer system.</p><p>Only one process can run on CPU at a time  (or a few things if the CPU has multiple “cores”)</p><ul><li><p>process management</p></li><li><p>memory management</p></li></ul><p>The Python interpreter mostly lets you [Python Programmer] ignore the CPU you run on.</p><p>But you still need to work a bit to “fit” the code to the OS.</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>version control system tools</p><p>features:</p><ul><li><p>it allows people to create snapshots of their work even while offline</p></li><li><p>it allows programmers to document the changes they made</p></li><li><p>it allows multiple version of history in the same repo</p></li><li><p>it sometimes automatically resolves conflicts</p></li><li><p><del>it automatically creates commits at regular intervals, it automatically creates commits when files change</del></p></li></ul><p><strong>git branch:</strong> list your branches. a * will appear next to the currently active branch</p><p><strong>git checkout:</strong> switch to another branch and check it out into your working directory</p><p><strong>HEAD:</strong> wherever you currently are (only one of these) , * means where your HEAD is</p><p><strong>tag:</strong> label tied to a specific commit number  </p><p><strong>branch:</strong> label tied to end of chain (moves upon new commits</p><p><strong>commit:</strong> a snapshot of files at a point in time</p><p><strong>merge:</strong> to combine changes on another branch into the current branch  </p><p><strong>conflict:</strong> differences that cannot automatically be merged</p><p><strong>headless:</strong> HEAD does not point to any branch</p><p><strong>Detached HEAD:</strong> refers to a situation where the <strong>HEAD</strong> pointer (which usually points to a branch reference) <strong>directly points to a specific commit</strong>, <strong>rather than pointing to the latest commit of a branch</strong>. </p><p>In simpler terms, when you’re working in a normal branch (say, “master” or “main”), the HEAD points to the name of that branch, and that branch name points to the latest commit. </p><p>Any new commits you make will advance the branch to point to the newer commit, and HEAD follows along because it’s pointing to the branch name.</p><p><img src="/2023/10/06/CS320学习笔记/1.png" alt=""></p><p>As you can see, HEAD points to the controller branch, which points to the last commit. Everything looks perfect. After running <strong>git checkout 87ec91d,</strong> the repo looks like this:</p><p><img src="/2023/10/06/CS320学习笔记/2.png" alt=""></p><p>This is the detached HEAD state; HEAD is pointing directly to a commit instead of a branch.</p><p>git demonstration</p><p><img src="/2023/10/06/CS320学习笔记/3.png" alt=""></p><p>If you’re on branch <strong>x</strong> and run ‘git merge y’, then you will point to new branch named <strong>x</strong></p><p>When making a git commit, the head is recommend to point to <strong>branch</strong>, otherwise may cause detached HEAD problem</p><p><strong>checkout:</strong></p><ul><li><p>output is <strong>bytes</strong>, not string</p></li><li><p><code>checkout([&quot;git&quot;,&quot;commit&quot;,cwd=&quot;directory_name&quot;)</code></p></li></ul><h1 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h1><p>Things that affect performance:</p><ul><li>speed of the computer (CPU, etc)  </li><li>speed of Python (quality+efficiency of interpretation)  </li><li>algorithm: strategy for solving the problem  </li><li>input size: how much data do we have?</li></ul><p>when analyze complexity, only care about big inputs</p><p><img src="/2023/10/06/CS320学习笔记/4.png" alt=""></p><p>A step is any unit of work with boudned execution time. (“bounded” does not mean “fixed”)</p><h2 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h2><p>If $f(N) \leq C * g(N)$, then $f(N) \in O(g(N))$</p><p><strong>Common complexity for list operation:</strong></p><ul><li><p>$O(1)$: <code>len(L),L[-1],L[-10],L.append(x),L.pop(-1)</code></p></li><li><p>$O(N)$: <code>L.insert(0,x),L.pop(0),max(L),min(L),sum(L),L2.extend(L1),found x in L</code></p></li></ul><p><strong>Special case:</strong></p><p>for <code>deque</code>(双端队列): $O(1)$<code>deque.popleft(0),deque.pop()</code></p><p>for <code>heapq</code>(小根堆): $O(1)$ <code>heapq.heappop()</code></p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>看图说话</p><p><img src="/2023/10/06/CS320学习笔记/5.png" alt=""></p><p><img src="/2023/10/06/CS320学习笔记/6.png" alt=""></p><p><img src="/2023/10/06/CS320学习笔记/7.png" alt=""></p><h1 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object Oriented Programming"></a>Object Oriented Programming</h1><p><img src="/2023/10/06/CS320学习笔记/8.png" alt=""></p><p><code>Dog.speak(fido,5)</code>is NOT an example of type-based dispatch</p><p><code>fido.speak(5)</code>is preferred</p><p><code>def __init__(dog,name,age):</code> <code>self</code> is better than <code>dog</code> for the receiver parameter</p><h2 id="Special-Methods"><a href="#Special-Methods" class="headerlink" title="Special Methods"></a>Special Methods</h2><p>Not all <code>__some__</code> is special methods</p><p><strong>implicitly</strong> called</p><h3 id="str-vs-repr"><a href="#str-vs-repr" class="headerlink" title="__str__ vs__repr__"></a><code>__str__</code> vs<code>__repr__</code></h3><p> <code>__str__</code>, <code>__repr__</code>, control how an object looks when we print it or see it in <code>Out[N]</code> <code>print(),str()</code>方法会调用到<code>__str__</code>方法，<code>print(),str(),repr()</code>方法会调用<code>__repr__</code>方法。从下面的例子可以看出，当两个方法同时定义时，Python会优先搜索并调用<code>__str__</code>方法。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Str</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">"__str__ called"</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">"__repr__ called"</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> Str<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>__str__ called<span class="token operator">>></span><span class="token operator">></span> repr<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token string">'__repr__ called'</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token string">'__str__ called'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>__repr__</code></strong></p><ul><li>The <code>__repr__</code> method is used to define the “official” string representation of an object. It is used by the <code>repr()</code> built-in function and by backticks (<code>`</code>) in Python 2.x.</li><li>The string returned by <code>__repr__</code> should be a valid Python expression that, when evaluated, would create an object with the same state as the original object. In other words, it should be unambiguous and precise.</li><li>This method is <strong>primarily used for debugging and development purposes</strong>.</li></ul><p><strong><code>__str__</code>:</strong></p><ul><li>The <code>__str__</code> method is used to define the <strong>“informal” or “user-friendly”</strong> string representation of an object. It is used by the <code>str()</code> built-in function and by the <code>print()</code> function.</li><li>The string returned by <code>__str__</code> should be readable and understandable to users.</li><li>If <code>__str__</code> is not defined, the <code>__repr__</code> method will be used as a fallback.</li></ul><p>In summary, <code>__repr__</code> is more for <strong>developers</strong>, providing <strong>a detailed and unambiguous representation*</strong> of an object, while <code>__str__</code> is for <strong>users</strong>, presenting a <strong>more user-friendly and readable representation</strong> of the object. It’s common to implement <code>__repr__</code> and optionally <code>__str__</code> for your custom classes to enhance their debuggability and usability.</p><p><code>__repr_html__</code>, generate HTML to create more visual representaitons of objects in Jupyter.</p><p><code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__ge__</code>,<code>__le__</code>, <code>__ge__</code>,define how ==, !=, &lt;, &gt;, &lt;=, &gt;= behaves for two different objects, for <code>sorted</code>, must implement <code>__lt__</code></p><p><code>__len__</code>, <code>__getitem__</code>, build our own sequences that we <code>index</code>, <code>slice</code>, and <code>loop</code> over. </p><p><code>__enter__</code>, <code>__exit__</code>, context managers, (like automatically close file)</p><p>with语句，先调用<code>__enter__</code>在<code>__init__</code>之后，在with结束后调用<code>__exit__</code></p><p>positional arguments includes <code>self</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">getgrade</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">""" This function computes a grade given a score"""</span>    <span class="token keyword">if</span> score <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">:</span>        grade <span class="token operator">=</span> <span class="token string">'A'</span>    <span class="token keyword">elif</span> <span class="token number">80</span> <span class="token operator">></span> score <span class="token operator">></span> <span class="token number">70</span><span class="token punctuation">:</span>        grade <span class="token operator">=</span> <span class="token string">'B'</span>    <span class="token keyword">elif</span> <span class="token number">70</span> <span class="token operator">></span> score <span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">:</span>        grade <span class="token operator">=</span> <span class="token string">'C'</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        grade <span class="token operator">=</span> <span class="token string">'D'</span>    <span class="token keyword">return</span> name <span class="token operator">+</span> <span class="token string">" had grade: "</span> <span class="token operator">+</span> grade getgrade<span class="token punctuation">(</span><span class="token string">'prince'</span><span class="token punctuation">,</span> <span class="token number">78</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># To call this function using positional arguments:</span>getgrade<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'prince'</span><span class="token punctuation">,</span> score<span class="token operator">=</span><span class="token number">78</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># using keyword arguments:  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>positional arguments就是不带=，带=就是keyword</p><p>Attributes are the individual data items or characteristics associated with an object.</p><ul><li><p>class attribute </p></li><li><p>instance attribute</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">:</span>    class_attribute <span class="token operator">=</span> <span class="token number">42</span>  <span class="token comment" spellcheck="true"># 'class_attribute' is a class attribute</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value  <span class="token comment" spellcheck="true"># 'value' is an instance attribute</span>obj1 <span class="token operator">=</span> MyClass<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>value<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Out put 10</span><span class="token keyword">print</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>class_attribute<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Output: 42</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Assume <code>Car</code> is one of the child class of <code>Vehicle</code>. Which of the following allows me to call the <code>drive()</code> method defined in the <code>Vehicle</code> class within the <code>Car</code> class? </p><ul><li><p><code>super().drive()</code></p></li><li><p><code>Vehicle.drive(self)</code></p></li></ul><p>The X class is a parent of the Y class; both have an <code>__init__</code>method. Both <code>__init__</code> methods are guaranteed to run when a new instance of Y is created, regardless of the code in Y’s <code>__init__</code> method.</p><ul><li>False</li></ul><p>htop shows <strong>how much memory is being used</strong></p><p>TextIOWrapper is for <strong>converting bytes to str</strong></p><p>What is the benefit of reading a CSV inside a .zip file directly from Python, without unzipping it from the command line first?</p><ul><li>to save storage space </li></ul><p>What is the benefit of using <code>csv.DictReader</code> instead of <code>pd.read_csv</code> ?</p><ul><li>save memory space</li></ul><h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><h2 id="Call-graph"><a href="#Call-graph" class="headerlink" title="Call graph"></a>Call graph</h2><p><img src="/2023/10/06/CS320学习笔记/9.png" alt=""></p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>global frams hold all global variables</p><p>stack frams <strong>hold local variables</strong></p><p>Each function can have <strong>multiple</strong> frames on the stack at a time.</p><p><img src="/2023/10/06/CS320学习笔记/10.png" alt=""></p><p><img src="/2023/10/06/CS320学习笔记/11.png" alt=""></p><h1 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h1><p>左儿子比自己小，右儿子比自己大，建树和输入顺序有关系</p><p>randomly input 会让树更balanced</p><p>insert 复杂度 $O(H)$ 最坏$O(N)$ 最好$O(logN)$ <img src="/2023/10/06/CS320学习笔记/12.png" alt=""></p><h1 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h1><p>DAG : 有向无环图</p><p>Strongly connected: 强连通图，考虑direction，所有节点都能相互走到</p><p>Weakly connected：弱联通，忽略方向，所有节点都能互相到达</p><p>Acyclic：无环</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>用stack栈，每次加入节点的孩子，先加大的再小的（保证尾巴先出来的是小的），尾进尾出</p><p>对于环，遇到已经加到栈的孩子仍然新加一个相同的</p><p>A</p><p>H B</p><p>H E C</p><p>H E D</p><p>H E</p><p>H G F</p><p>H G</p><p>H</p><p>M I</p><p>M L K J</p><p>M L</p><p>M</p><p>A, B, C, D, E, F, G, H, I, J, K, L ,M</p><p><img src="/2023/10/06/CS320学习笔记/14.png" alt=""></p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>用deque双端队列，每次加入节点的孩子，先加小的再大的，头进尾出</p><p>A</p><p>H B</p><p>G D C H</p><p>I G D C </p><p>I G D</p><p>F E I G</p><p>F E I</p><p>K J F E</p><p>K J F</p><p>K J</p><p>K</p><p>A, B, H, C, D, G, I, E, F, J, K</p><p><img src="/2023/10/06/CS320学习笔记/13.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-yaml&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;&lt;span class=&quot;token key atrule&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;token punctuatio</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ECE252学习笔记</title>
    <link href="http://yoursite.com/2023/09/18/ECE252%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2023/09/18/ECE252%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-19T00:11:08.000Z</published>
    <updated>2023-10-09T00:12:44.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Week01"><a href="#Week01" class="headerlink" title="Week01"></a>Week01</h1><h2 id="Universal-Turing-Machine"><a href="#Universal-Turing-Machine" class="headerlink" title="Universal Turing Machine"></a>Universal Turing Machine</h2><p>A programmable computer is effectively a <strong>Universal Turing Machine</strong> (minus infinite memory)</p><ul><li><p>A <strong>“program”</strong> describes <strong>a computation</strong></p></li><li><p>One that can <strong>“simulate” any other Turing machine</strong> by in putting a description of that machine’s behavior rules</p></li><li><p>The behavior is <strong>no longer “hard-coded”</strong>!</p></li></ul><p>In theory, a computer can compute anything that’s possible to compute…</p><ul><li>Given enough <strong>memory and time</strong></li></ul><h2 id="Technology"><a href="#Technology" class="headerlink" title="Technology"></a>Technology</h2><h3 id="Moore’s-law"><a href="#Moore’s-law" class="headerlink" title="Moore’s law"></a>Moore’s law</h3><ul><li><p>Predicted doubling of capacity every 24 months -&gt; Cost halves every two years.</p></li><li><p>Has generally held true</p></li></ul><h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><ul><li><p>Executes applicationsthat have been brokendown into sequencesof simple instructions</p></li><li><p>Use digital logic circuits, made up of transistors</p></li></ul><h2 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h2><p>hardware/software</p><p>ISA  is the boundary</p><p>hardware: ISA, Microarchitecture，Logic Circuits，Devices</p><p>software：Problem Statement，Algorithm，Program</p><p><img src="/2023/09/18/ECE252学习笔记/1.png" alt=""></p><h3 id="Layers"><a href="#Layers" class="headerlink" title="Layers"></a>Layers</h3><p><img src="/2023/09/18/ECE252学习笔记/2.png" alt=""></p><p>越在上层越抽象 more higher layer more abstraction </p><p><strong>Problem Statement</strong></p><ul><li><p><strong>natural language</strong></p></li><li><p>ambiguous，imprecise</p></li></ul><p>—— <strong>Software Design</strong>: Choose algorithms&amp;data structures tosolve the problem</p><p><strong>Algorithm</strong></p><ul><li><p>step-by-step <strong>procedure</strong>，guaranteed to finishi</p></li><li><p>Definiteness, effective computability, finiteness</p></li></ul><p>—– <strong>Programming</strong>: Use a programming language to implement design</p><p><strong>Program</strong></p><ul><li><p>Express the algorithm <strong>using a computer language</strong></p></li><li><p>High-level language, low-level language</p></li></ul><p><strong>区分不同level看hardware还是software</strong></p><p>low-level language: assembler, based on ISA</p><p>high-level language: complier, based on PS</p><p>—– <strong>Compilation</strong>: Use a compiler to convert the program to machine instructions</p><hr><p><strong>ISA</strong></p><ul><li><p>Specifies the <strong>set of instructions</strong> the computer can perform</p></li><li><p>Data types, addressing modes</p></li></ul><p>—– <strong>Processor Design</strong>: Choose high-level organization and structures to implement ISA</p><p><strong>Microarchitecture</strong></p><ul><li><p><strong>Detailed organization</strong> of a processor <strong>implementation</strong></p></li><li><p>Different implementations of a single ISA</p></li></ul><p>—– <strong>Logic/Circuit Design</strong>: Choose gates and other low-level structures to implement components</p><p><strong>Logic Circuits</strong></p><ul><li><p><strong>Combine basic operations</strong> to realize microarchitecture</p></li><li><p>Many <strong>different ways to implement a single function</strong>(e.g., addition)</p></li></ul><p>—– <strong>Implement &amp; Fabricate</strong>: Transform logic circuits into masks for transistors and other layers, then fabricate</p><p><strong>Devices</strong></p><ul><li><p>Transistor-based implementation of logic circuits</p></li><li><p>Chip layout masks</p></li><li><p>Properties of materials, manufacturability</p></li></ul><p><strong>Abstraction to Manage Complexity</strong></p><p>higher level of abstraction = more abstract</p><h2 id="Electrical-Information"><a href="#Electrical-Information" class="headerlink" title="Electrical Information"></a>Electrical Information</h2><p>Almost all computing systems are <strong>digital</strong></p><p>Analog：Continuous range of values</p><p>Digital：Discrete set of values （more abstract）</p><p>Digital <strong>is an Abstraction of</strong> Analog</p><p><strong>Binary Information</strong><br>Any data processed by a digital computer is represented by sequences of 1s and Os</p><h1 id="Week02"><a href="#Week02" class="headerlink" title="Week02"></a>Week02</h1><h2 id="Positional-Notation"><a href="#Positional-Notation" class="headerlink" title="Positional Notation"></a>Positional Notation</h2><p>Digits represent powers of the base(radix)<br>Each digit D in radix r is restricted to $0≤D&lt; r$</p><p>N-digit non-negative integer with radix r:<br>$D_{N-1}….D_1D_0= D_{N-1}×r^{N-1} + …+ D_1×r^1 + D_0×r^0$</p><p>Binary (Base 2) Octal (Base 8) Hexadecimal (Base 16)</p><p><strong>Each position</strong> represents <strong>a power of base</strong></p><p><strong>Digit value</strong> says <strong>how many</strong> of that power of base</p><h3 id="Value-vs-Number"><a href="#Value-vs-Number" class="headerlink" title="Value vs. Number"></a>Value vs. Number</h3><p>A <strong>value</strong> is a particular quantity</p><p>A <strong>number</strong> is a way to represent a value</p><p>To know the value indicated by a number, you need to know the <strong>format!</strong></p><p>The contribution of each digit to a number’s value is determined by <strong>its position and the base</strong></p><h2 id="Conversion"><a href="#Conversion" class="headerlink" title="Conversion"></a>Conversion</h2><p>Decimal to others: divide by base, the remainders are the digits</p><p>Binary to Hex: Directly substitute a hex digit fora <strong>4-bit</strong> binary number (or vice versa!)</p><p><img src="/2023/09/18/ECE252学习笔记/3.png" alt=""></p><p>Binary to Octal: Directly substitute a hex digit fora <strong>3-bit</strong> binary number (or vice versa!)</p><p><img src="/2023/09/18/ECE252学习笔记/4.png" alt=""></p><p>Octal to Hex: </p><p><img src="/2023/09/18/ECE252学习笔记/5.png" alt=""></p><p>Use binary as an intermediate form!</p><p>Decimal to Octal, Decimal to Hex: use Binary as an intermediate form</p><p>left: most significant, right: less significant</p><p>Multiply: move to left, Multiplying a base $R$ number by $R^N$ “shifts” the number left by $N$ positions</p><p>Divide: move to right, Dividing a base $R$ number by $R^N$ “shifts” the number right by $N$ positions</p><h2 id="Signed-Number"><a href="#Signed-Number" class="headerlink" title="Signed Number"></a>Signed Number</h2><p>In decimal, we show a number’s <strong>sign</strong> using asymbol (+ or -) in front of its <strong>magnitude</strong> Hence the name “signed-magnitude”…</p><h3 id="2’s-Complement-Representation"><a href="#2’s-Complement-Representation" class="headerlink" title="2’s-Complement Representation"></a>2’s-Complement Representation</h3><p><strong>Positive</strong> numbers start with 0</p><p>The rest of the bits work the same as unsigned binary</p><p><strong>Negative</strong> numbers start with 1</p><p>The interpretation is more complex</p><p>十进制负数 到 二补数：-5 到 5 -&gt; 0101 -&gt; 1010 + 1 = 1011</p><p>二补数负数 到 十进制负数1101 -&gt; 0010 + 1= 0011 -&gt; 3 -&gt; -3</p><h3 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h3><p>Addition works the way it does for unsigned binary numbers</p><h3 id="Subtraction"><a href="#Subtraction" class="headerlink" title="Subtraction"></a>Subtraction</h3><p>Instead of subtraction with borrowing, we <strong>add the negation</strong> of the value we wish to subtract</p><p>This method simplifies computer hardware</p><h3 id="Operand-Result-Bitwidths-Match"><a href="#Operand-Result-Bitwidths-Match" class="headerlink" title="Operand/Result Bitwidths Match"></a>Operand/Result Bitwidths Match</h3><p>Operands and results must have the same number of bits for the math to work correctly</p><p>operand是符号两边的数字</p><h2 id="Signed-Extension"><a href="#Signed-Extension" class="headerlink" title="Signed Extension"></a>Signed Extension</h2><p>前面是0就补0，是1就补1</p><p>每种表达的范围，超出范围就overflow</p><p>unsigned number:  $[0,2^{n}-1]$</p><p>signed number: $ [-(2^{n-1}-1),2^{n-1}-1 ]$</p><p>2’s-complement number: $[-2^{n-1},2^{n-1}-1]$</p><p>最小的数为1+n-1个0，最大是0+n-1个1，$[1000,0111]$</p><h2 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h2><p><strong>不管哪种方式，只要大于以上表达数的范围就overflow，表现为显示答案错误，sign错误</strong></p><p>The result cannot be correctly represented in the required number of bits.</p><p>lf adding two <strong>negative 2’s-complement numbers overflows</strong>, the sign of the result will appear to be <strong>non-negative</strong>.</p><p>1101 -3 |1001 -7</p><p>1100 -4 |1100 -4</p><p>————————</p><p>1001 -7 |0101 5 overflow</p><p>lf the result of adding <strong>two positive 2’s-complement numbers</strong> appears to be <strong>positive</strong>, then the operation <strong>did not overflow</strong>.</p><p>lf adding <strong>two unsigned numbers overflows</strong> , the result will appear to be<br><strong>smaller than it should be</strong>. </p><h1 id="Week03"><a href="#Week03" class="headerlink" title="Week03"></a>Week03</h1><h2 id="Fixed-Floating"><a href="#Fixed-Floating" class="headerlink" title="Fixed Floating"></a>Fixed Floating</h2><p>When the format defines a “fixed” position for the radix point within the number’s digits, it is called <strong>fixed-point</strong> </p><p><img src="/2023/09/18/ECE252学习笔记/7.png" alt=""> </p><h2 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating-Point"></a>Floating-Point</h2><p>Floating-point: the format defines a way toe ncode the radix point location into the number(i.e., the position <strong>is not “fixed” in one place</strong>)</p><ul><li><p>More flexibility than fixed-point… and more complexity!</p></li><li><p>Scientific Notation is floating-point</p></li></ul><h2 id="IEEE-32-Bit-Floating-Point"><a href="#IEEE-32-Bit-Floating-Point" class="headerlink" title="IEEE 32-Bit Floating-Point"></a>IEEE 32-Bit Floating-Point</h2><p><img src="/2023/09/18/ECE252学习笔记/6.png" alt="">  </p><p>$(-1)^{sign} <em> 1.signficand </em> 2 ^{exponent-127}$</p><h2 id="Format-Comparison"><a href="#Format-Comparison" class="headerlink" title="Format Comparison"></a>Format Comparison</h2><p><img src="/2023/09/18/ECE252学习笔记/8.png" alt="">  </p><p><strong>Range</strong>: from the leftmost to the rightmostrepresentable values on the number line</p><p><strong>Precision</strong>: number of significant digits</p><p>Integer: $XXXX XXXX$ </p><ul><li><p>precision: 8 bits</p></li><li><p>range: $[0,2^8-1]$</p></li></ul><p>Fixed: $XXXX.XXXX$</p><ul><li><p>precision: 8 bits</p></li><li><p>range: $[0,2^4-1+ 1- 2^{-4}]$</p></li></ul><p>Float: $1.XXXX * 2^{XXXX}$</p><ul><li><p>precision: <strong>5 bits</strong> notes（不需要转成十进制） precision=1+significand</p></li><li><p>range: $[1,(1+1-2^{-4} )* 2^{2^4-1}]$</p></li></ul><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>A computer stores text in memory as <strong>binary</strong></p><p>It uses <strong>8 binary-bits, 2 hex-bits (has been extended)</strong> to represent <strong>128</strong> different characters </p><p>Alphanumeric characters A-Z, a-z,0-9, encoded to allow easy sorting and transformation</p><h1 id="Week04"><a href="#Week04" class="headerlink" title="Week04"></a>Week04</h1><h2 id="Logic-Functions"><a href="#Logic-Functions" class="headerlink" title="Logic Functions"></a>Logic Functions</h2><h3 id="Ones-and-Zeros"><a href="#Ones-and-Zeros" class="headerlink" title="Ones and Zeros"></a>Ones and Zeros</h3><ul><li><p>Digital circuits manipulate voltage levels that weconsider more abstractly to be <strong>ones and zeros</strong></p></li><li><p>We call these circuits <strong>logic circuits</strong> because they operate on and produce <strong>Boolean</strong> results</p></li><li><p>Boolean variables have only two possible values<br>TRUE (corresponding to “one”)<br>FALSE (corresponding to “zero”)</p></li></ul><h3 id="Logic-Operator"><a href="#Logic-Operator" class="headerlink" title="Logic Operator"></a>Logic Operator</h3><p>AND: $A \cdot B$</p><p>OR: $A + B$</p><p>NOT: $\bar{A}$</p><p>XOR: $A \oplus B$ 相同是0，不同是1</p><h3 id="The-Odd-Function"><a href="#The-Odd-Function" class="headerlink" title="The Odd Function"></a>The Odd Function</h3><p>ex:$(A \oplus B) \oplus C$</p><p>output is 1 only when an odd # of the inputs are 1</p><h3 id="Bitwise-Logic-Functions"><a href="#Bitwise-Logic-Functions" class="headerlink" title="Bitwise Logic Functions"></a>Bitwise Logic Functions</h3><p>A <strong>bitwise</strong> operation computes each bit of an N-bit result based on the value(s) in the<br>corresponding position of the N-bit operand(s) 按位运算</p><h2 id="Combinational-Logic"><a href="#Combinational-Logic" class="headerlink" title="Combinational Logic"></a>Combinational Logic</h2><p>we think of logic circuits as having Boolean input values and <strong>producing Boolean results</strong><br>In reality, they are built from transistors that connecteach output to power or ground based on the design ofthe circuit and the <strong>voltage level</strong> of each input</p><ul><li><p>Logic circuits are at <strong>a higher level of abstraction</strong></p></li><li><p>Each transistor acts like a <strong>switch</strong>…</p></li></ul><h3 id="Transistors"><a href="#Transistors" class="headerlink" title="Transistors"></a>Transistors</h3><p><img src="/2023/09/18/ECE252学习笔记/9.png" alt="">  </p><p>A logic gate is an electric circuit that contains transistors that connect the output to power or ground based on the input voltage(s)</p><ul><li><p>power -&gt; voltage interpreted as logic 1</p></li><li><p>ground -&gt; voltage interpreted as loaic 0</p><p>  NOT gate use 2 transistors</p></li></ul><h3 id="Logic-Gates"><a href="#Logic-Gates" class="headerlink" title="Logic Gates"></a>Logic Gates</h3><p><img src="/2023/09/18/ECE252学习笔记/10.png" alt="">  </p><p>The shape of the gate allows us to visually determine all of these.</p><p>The inputs of these gates don’t need to be labeled because in these functions, the order of inputs doesn’t matter.</p><h2 id="Combinational-Blocks"><a href="#Combinational-Blocks" class="headerlink" title="Combinational Blocks"></a>Combinational Blocks</h2><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>Converts an <strong>n-bit</strong> input codeword into a unique m-bit output value, where $m=2^n$</p><p><strong>Exactly one</strong> output can be true at any given time</p><p>Here we are only concerned with how the decoder <strong>behaves</strong>, not how it is constructed internally</p><p>If the input value is N, the output is N</p><p>When we represent a logic structure with a block, the internal details are hidden. When using the block in a logic circuit, we only need to know <strong>what the block does</strong>.</p><p>Inside the block’s symbol, we label each pin to indicate <strong>the pin’s function in the underlying logic structure</strong>.</p><p>When we draw signal names or Boolean values on the outside of the block near the pins, they indicate <strong>what is externally connected to the block</strong> (the Boolean value or signal name.</p><p>We label each decoder output with a decimal number that <strong>is equal to the input code value that causes that output to be 1</strong>.</p><p><img src="/2023/09/18/ECE252学习笔记/11.png" alt="">  </p><h3 id="Multiplexers-Muxes"><a href="#Multiplexers-Muxes" class="headerlink" title="Multiplexers(Muxes)"></a>Multiplexers(Muxes)</h3><p>Selection: based on the select input(s), choose one of the data inputs to drive the output</p><ul><li><p>Output is equal to <strong>one</strong> of the data inputs</p></li><li><p><strong>Select inputs</strong> indicate which data input</p></li></ul><p>n select lines, $2^n$ input lines</p><p>The output of a multiplexer always has the same value as one of its <strong>data inputs</strong>.</p><p>The multiplexer’s <strong>select inputs</strong> control which of its <strong>data inputs</strong> is sent to the output.</p><p><img src="/2023/09/18/ECE252学习笔记/12.png" alt="">  </p><p>Data inputs must <strong>be labeled</strong> to indicate which input is chosen for <strong>a given select value</strong><br>Select inputs must <strong>be labeled</strong> so we know <strong>the ordering of bits</strong> within the select value We need to interpret the select as a binary number</p><p>Exception: a 2:1 mux has only one select signal so it does not need a label</p><h3 id="Adders"><a href="#Adders" class="headerlink" title="Adders"></a>Adders</h3><h4 id="Full-adder"><a href="#Full-adder" class="headerlink" title="Full adder:"></a>Full adder:</h4><p>A structure that performs <strong>the addition for one bit position of a multi-bit binary addition</strong> operation.</p><p><strong>Accept three inputs</strong>: a bit from each addend and a carry value from bit position to the right<br><strong>Produce two outputs</strong>: the sum bit at that position, and a carry value to send to the bit position to the left</p><p>A full adder performs addition for <strong>a single bit position</strong></p><p>Cout,Cin: 进位</p><h4 id="Ripple-Carry-Adder"><a href="#Ripple-Carry-Adder" class="headerlink" title="Ripple Carry Adder"></a>Ripple Carry Adder</h4><p>A series of full adders, where each full adder performs the addition for a single bit position.</p><p><img src="/2023/09/18/ECE252学习笔记/13.png" alt="">  </p><h1 id="Week05"><a href="#Week05" class="headerlink" title="Week05"></a>Week05</h1><h2 id="Combinational-Logic-1"><a href="#Combinational-Logic-1" class="headerlink" title="Combinational Logic"></a>Combinational Logic</h2><p>So far, all of the logic circuits we have talked about have been combinational</p><ul><li><p>Circuit outputs only depend on current input values</p></li><li><p>Adder, Mux, Decoder,</p></li></ul><h2 id="Sequential-Circuits"><a href="#Sequential-Circuits" class="headerlink" title="Sequential Circuits"></a>Sequential Circuits</h2><p>The behavior of a <strong>sequential logic circuit</strong> is determined by <strong>both its current and past input values</strong>.</p><ul><li><p>Some systems need to store information about <strong>past behavior</strong> to know how to react to inputs</p></li><li><p>Sometimes just need to store data for later access</p></li></ul><p>A circuit’s <strong>current state</strong> is the binary number that is currently stored in the circuit’s flip-flops.</p><p>The <strong>state</strong> of a sequential logic circuit can change, <strong>only at the triggering (active) edge of its clock signal</strong>.</p><h2 id="Flip-Flop"><a href="#Flip-Flop" class="headerlink" title="Flip-Flop"></a>Flip-Flop</h2><p>It has <strong>one bit</strong> of data input, <strong>one bit</strong> of data output<br>It also has a “clock” input that controls when the value carried by the input signal is stored into the flip-flop</p><p>The value held by a flip-flop cannot change until the clock allows it(or power is lost to the system…)</p><p>The flip-flop’s output is always equal to the value it is storing</p><p><img src="/2023/09/18/ECE252学习笔记/14.png" alt="">  </p><h3 id="Clock-signal"><a href="#Clock-signal" class="headerlink" title="Clock signal"></a>Clock signal</h3><p>A clock is a special signal that oscillates between 1and 0 at a specific frequency</p><p><img src="/2023/09/18/ECE252学习笔记/15.png" alt=""> </p><p>This D flip-flop updates when the clock transitions from 0 to 1(rising edge)</p><p>The flip-flop input is only stored at the rising clock edge(“triggering” edge)</p><h3 id="Counter-Circuit"><a href="#Counter-Circuit" class="headerlink" title="Counter Circuit"></a>Counter Circuit</h3><p>约等于每次给自己加1</p><p><img src="/2023/09/18/ECE252学习笔记/23.png" alt="">  </p><h2 id="Finite-State-Machine"><a href="#Finite-State-Machine" class="headerlink" title="Finite State Machine"></a>Finite State Machine</h2><p>Any practical sequential circuit is a Finite State Machine (FSM)</p><p>State: current “status” -&gt; the contents of the flip-flops</p><ul><li><p>state diagram of a Flip-Flop only 2 state</p></li><li><p>counter state diagram only 4 state</p></li></ul><p>Each state in an FSM is assigned <strong>a binary code</strong></p><ul><li><p>The FSM contains <strong>one flip-flop per bit</strong> of state</p></li><li><p>During operation, the code stored in the FSM’s flip-flopstells us (and the machine) which is the <strong>current state</strong>.</p></li><li><p>The next state becomes the current state when the flip-flop contents are updated</p></li></ul><p>The FSM’s behavior depends both upon the <strong>current state and the input(s)</strong></p><ul><li>The next state is <strong>a function of the current state and current input values</strong></li></ul><p>A state diagram describes the <strong>behavior</strong> of a state machine by showing for each state, <strong>what it should do in response to the inputs</strong>.</p><p>A given row of the state table lists the output value(s) it will produce for that row’s <strong>current state</strong>.</p><h3 id="Hardware-Design"><a href="#Hardware-Design" class="headerlink" title="Hardware Design"></a>Hardware Design</h3><p>A register is a group of flip-flops used to storemulti-bit binary values</p><p><img src="/2023/09/18/ECE252学习笔记/16.png" alt=""> </p><h2 id="Register-Memory"><a href="#Register-Memory" class="headerlink" title="Register Memory"></a>Register Memory</h2><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>A register is a group of flip-flops used to <strong>store multi-bit binary values</strong></p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>Use adders and registers</p><p><img src="/2023/09/18/ECE252学习笔记/24.png" alt=""> </p><h3 id="Enable"><a href="#Enable" class="headerlink" title="Enable"></a>Enable</h3><p>Sometimes we want a flip-flop to “hold” its value for multiple clock cycles, regardless of its input</p><ul><li>But a flip-flop always stores the input value at the triggering edge of the clock…</li></ul><p>Solution: add logic so that we can choose to store a new value or the value already in the flip-flop</p><ul><li>Selection <strong>based on the value of a special input signal</strong> called an enable</li></ul><p><img src="/2023/09/18/ECE252学习笔记/18.png" alt=""></p><p><img src="/2023/09/18/ECE252学习笔记/19.png" alt=""> </p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>$M$-bits number specifies $2^M$ locations</p><p>Each location stores a single N-bit word</p><p>$N$ is the data size of the memory</p><p>The capacity of a memory is: $2^M * N$</p><p>A memory is conceptually like <strong>an array of registers</strong> </p><p><strong>Only one location</strong> can be accessed at a time,either to write (store) a value or read a value</p><p>To access a register, we index into the array using the address for that register</p><p>set WE to 1 for write, WE to 1 for read</p><p><strong>In a memory :</strong></p><ul><li><p>$n$-bits address for $2^n$ locatioins </p></li><li><p>the number of address bits dictates <strong>the maximum number</strong> of addressable locations in the memory</p></li></ul><p>Address selects which register supplies data out using <strong>muxs</strong></p><p>Address selects which register using <strong>decoders</strong></p><p><img src="/2023/09/18/ECE252学习笔记/20.png" alt=""> </p><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p>using mux to select output location from read</p><p>no inputs and we</p><p><img src="/2023/09/18/ECE252学习笔记/21.png" alt=""> </p><h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>input data, using decoder to select address to write, we enable</p><p>no mux and output</p><p><img src="/2023/09/18/ECE252学习笔记/22.png" alt=""> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Week01&quot;&gt;&lt;a href=&quot;#Week01&quot; class=&quot;headerlink&quot; title=&quot;Week01&quot;&gt;&lt;/a&gt;Week01&lt;/h1&gt;&lt;h2 id=&quot;Universal-Turing-Machine&quot;&gt;&lt;a href=&quot;#Universal-Tur</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="CA" scheme="http://yoursite.com/categories/CS/CA/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="数字电路" scheme="http://yoursite.com/tags/数字电路/"/>
    
  </entry>
  
  <entry>
    <title>托福学术写作例文</title>
    <link href="http://yoursite.com/2023/09/01/%E6%96%B0%E4%BD%9C%E6%96%87%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2023/09/01/%E6%96%B0%E4%BD%9C%E6%96%87%E7%BB%83%E4%B9%A0/</id>
    <published>2023-09-02T04:44:20.000Z</published>
    <updated>2023-09-03T07:17:19.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Which-—-两者选一个"><a href="#Which-—-两者选一个" class="headerlink" title="Which —- 两者选一个"></a>Which —- 两者选一个</h1><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p>l agree with Kelly. In my opinion, graduates would have a better work experience in large and older companies. Firstly, new start-up companies are unexperienced for the whole business market so they are more likely to make bad decisions. As a result, the new company becomes impoverished very soon. Then graduates who join the company can lose their jobs rapidly. Graduates urgently need a stable job to cover the cost of house lease, basic necessities, and utility bills, so fresh small company is a bad choice. Secondly, the older companies are well-established with more effective networking strategies and more reliable sources of funding, where graduates can have better guidance under their excellent working conditions. lf one graduate join a big company, he can learn much about how to work properly, how to deal with the relationship with their partners, and they can be led by experienced mentors, which is of great significance to their future development. In a nutshell, l strongly maintain that older and large companies are better choices for university graduates.</p><p><strong>修改</strong></p><p>I agree with Kelly, believing that university graduates should choose to work at large and older companies. Firstly, new start-up companies are <strong>inexperienced</strong> for lack of a global view on the market, so they are more likely to make <strong>uninformed</strong> decisions. Consequently, these new companies may fail to hold their competitiveness and even go <strong>bankrupt</strong>, leading to a high possibility that university graduates as new members to the corporate community lose their jobs soon. This is disastrous since they are in urgent need of a stable job and a <strong>decent salary</strong> size to cover the cost of housing, basic necessities, and utility bills. In this sense, start-ups are not a good choice for new graduates. </p><h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p>l believe that cinemas will disappear in the future and people will come to cinemas less frequently than before. From my perspective, the internet is very popular and well-developed now, demonstrating that people can get access to the movies and films at home very easily. People can watch these films on their telephones, televisions, and computer screens, which is more convenient compared with going out for a long time to watch them at cinemas.Therefore, if people can watch them on their electronic devices, they can enjoy movies whenever and wherever they are. In other words, there is no need to go to a certain place to watch movies. Furthermore, many people don’t enjoy watching movies surrounded by other strangers. Watching films at home on one’s own devices is more private and comfortable; people will not be disturbed by others’ comments or noises. As a result, I maintain that cinemas will cease to exist in the future.</p><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>l strongly insist that people will spend less time on working and have more leisure time in the future.From my perspective, with the development of artificial intelligence, twenty years later, the applications of AI will become widespread and popular among all fields of human life. Especially when people are at work, Al can help them work in a more efficient way than recent days.Take the example of police officers, imagine they are hunting for criminals who have escaped from jail. It can be difficult to catch the criminals that they will send a lot of people to investigate and track the trail of criminals. However, with the help of Al in the future, Al can build a network to track criminals all over the world, people can just type the information into such strong system, then monitors in the streets and corners can find the criminals just in few seconds; police will know where they gone and arrest them very soon. That can be much faster than today so police will work less and have more time to relax. In all, l believe people will work less in the future.</p><h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><p>I agree with Andrew, being an excellent communicator is more important than having profound background in particular industry technology. From my perspective, being a leader is not only about giving ambitious speech in front of his employees to motivate and encourage them, it is also about negotiating with rivals and communicating with commercial partners. Expert in technical background can be not enough for understanding the key point of communication. Talking with your opponents and someone dislike you requires specific communication skills. A president of company should know the weakness and disadvantages of his adversary and express them in a polite and precise way, to make others aware of their shortages without making them embarrassed, which is the art of communication. In all, I believe that a leader with excellent communication skill is more signicant to lead the whole team to success.</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>l believe that it is better for the city governments to use a piece of available land as a green space. Many critics who disagree with the greenland choice hold the opinion that building commercial building such as shopping malls, movie theaters and grocery stores can lead to the development of city economy. Nevertheless, building a natural city park can also bring wealth. A natural and well-designed city park can attract many visitors to pay a visit to the city where it locates, which improves the tourism. More travelers means more needs for shopping and hotel-living, which can earn a lot of money too. In addition, although the city park itself is free, visitors who come to the park need to find a parking place for their cars. Setting paid parking places around the park and building a new parking structure near the greenland can a useful way to have a economic improvement.In a nutshell, l maintain that building a greenland is better than using it for other purposes.</p><h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><p>I disagree with Paul, believing that public transportation should not be free to all. Building pubilc transportation requires a large amount of money and time, even for the whole country, the cost for establishing such huge transportation system is too large. ln addtion, the maintenance and operation system needs workers and sercuity guards, it takes money to ensure that the whole system works regularly and fine. In my own country, public transportation such as subways, buses and airplanes all requires personal payment, people who takes such ride won’t complain about the fees. The payment charges for the subways are very small so it is really reasonable to pay for a convenient and cheap transportation. On the other hand, taxes paid by citzens can be used for other infrastructure development and medical enhancement, which is more important. In all, I maintain that public transportation should not be free to all. </p><h1 id="What-—-most-best-提出第三方，反驳其他两者"><a href="#What-—-most-best-提出第三方，反驳其他两者" class="headerlink" title="What —- most/best 提出第三方，反驳其他两者"></a>What —- most/best 提出第三方，反驳其他两者</h1><h2 id="1-television-effects"><a href="#1-television-effects" class="headerlink" title="1 television effects"></a>1 television effects</h2><h3 id="思路一：同意反方，先写确实会导致肥胖，但肥胖并非直接由看电视导致，看电视最普遍和重要的问题是：近视"><a href="#思路一：同意反方，先写确实会导致肥胖，但肥胖并非直接由看电视导致，看电视最普遍和重要的问题是：近视" class="headerlink" title="思路一：同意反方，先写确实会导致肥胖，但肥胖并非直接由看电视导致，看电视最普遍和重要的问题是：近视"></a>思路一：同意反方，先写确实会导致肥胖，但肥胖并非直接由看电视导致，看电视最普遍和重要的问题是：近视</h3><p>It is hard to deny that watching televisions too much is one of the main reasons that causes obesity. When children watch television, they often sit on the sofa and eat snacks while watching cartoons or television shows for a long time. Sitting for a long time will cause less exercise, consuming too much junk food will lead to harder digestion for fat. As a result, children will gain a lot of weights with the combination of these two causes. Therefore, actually watching television is not the original reason to be overweight, it is people’s idolence and voracity that leads to obesity. From my perspective, the most significant effect of watching television is causing myopia. When people are watching tv, they stare at the electronic screens; using eyes excessively hurts eyes deeply, which distorts lenses in eyes, it cannot be cured easily. In addition, the radiation from electronic screens can be harmful to the health of eyes. In all, nearsightedness is the most important influence that television has on people.</p><h3 id="思路二：同意正方，看电视能拓宽视野，但是人们看电视主要是为了放松，享受一个轻松的氛围"><a href="#思路二：同意正方，看电视能拓宽视野，但是人们看电视主要是为了放松，享受一个轻松的氛围" class="headerlink" title="思路二：同意正方，看电视能拓宽视野，但是人们看电视主要是为了放松，享受一个轻松的氛围"></a>思路二：同意正方，看电视能拓宽视野，但是人们看电视主要是为了放松，享受一个轻松的氛围</h3><p>I partly agree with Paul that television programs can help people broaden their horizons and learn more about the natural world that people cannot pay a visit to. While watching such educational programs demonstrated on televisions, people can learn about the formation of outer universe, the history of Big Bang, the possibility of aliens existing on other planets and so on. Nevertheless, although people can learn a lot through watching educational shows, the most significant purpose of enjoying televisions for people is relaxation and entertainment. After an entire day of tired and busy work, people will lie on the sofa and watch some comedies or variety shows to relax and put all the worries aside; people won’t open an educational channel to learn something with an exhausted body and a drained heart. Amusement is all they want, only entertainment programs and soap operas can meet such demands. In a nutshell, I maintain that entertaining and leisure time is the most important effect of watching television.</p><h3 id="思路三：两者都不同意，看电视最重要的是接触广告宣传，商业宣传，老年人接触广告产品，推销"><a href="#思路三：两者都不同意，看电视最重要的是接触广告宣传，商业宣传，老年人接触广告产品，推销" class="headerlink" title="思路三：两者都不同意，看电视最重要的是接触广告宣传，商业宣传，老年人接触广告产品，推销"></a>思路三：两者都不同意，看电视最重要的是接触广告宣传，商业宣传，老年人接触广告产品，推销</h3><p>I believe that the most significant effect of televisions on people is TV commercials. Whatever program people watch, even the educational programs, advertisement is an inevitable part of television shows. Any television program need to cover the cost of recording expense and putting programs on television also charges seat fees, the most important way to earn money for this is advertising implantation. Thus, People cannot watch the whole program without breaks for advertising; one program will always be split into several parts to be displayed on televisions. Therefore, people have to watch the advertisement during the waiting time, which is often short and lasts for only a few minutes, so many people will still focus on the television and watch the advertisement carefully as well. In addition, TV stars often endorse products and such advertisements will be shown during the break time; people who are fans of such program would be interested in its actors and the products they endorsed as well, which makes people pay more attention to the advertisement and be influenced by such advertising more possibly. In all, TV commercials is the most significant influence of televisions.</p><h2 id="28"><a href="#28" class="headerlink" title="28"></a>28</h2><p>l believe the biggest problem is that people usually don’t consider their needs carefully and make decisions too fast so that they buy a wrong technological device which don’t really fit them well. Take the example of myself, when l was a first-year university student, l wanted to buy a new computer for myself. For l made this decision in a hurry, I had to buy it in a very short time. To select a suitable computer, l asked many friends to help me choose some brands that were their preferences and didn’t consider it carefully from my own heart, as l didn’t have any experience to select computers. At that time, the only thing l thought was that l just needed a computer for coding and learning. Therefore, I bought a computer having no independent display card that couldn’t run any 3A games. As a consequece, I realized it was the biggest mistake l have made because just after l received that computer, I fell in love with games and my computer couldn’t afford it at all; even the brand I didn’t like neither. In all, making decisions too fast and buying an unsuitable device is the biggest mistake.</p><h1 id="词汇练习"><a href="#词汇练习" class="headerlink" title="词汇练习"></a>词汇练习</h1><p>例子：<br>the peony, the plum blossom and other plants competing for the title of the National Flower</p><p>juice, bubble tea, coke, and other drinks </p><p><strong>sugary beverages</strong> 含糖食品饮料<br>dinosaurs, dodos, and other <del>prehistoric animals</del></p><p><strong>extinct species</strong><br>books, magazines and other paper medias</p><p><strong>printed or electronic publications</strong><br>buses, subways and other transportation</p><p><strong>means/modes/types/forms of public transportation</strong><br>tests, quizzes and other acadamic evaluations</p><p><strong>forms of student/achievement/performance evaluation</strong><br>charity workers, unpaid museum guides and similar volunteers</p><p><strong>voluntary/volunteering roles</strong><br>pens, erasers and other stationery</p><p><strong>types of stationery</strong><br>saturated fat, added sugar and other </p><p><strong>essential nutrients</strong><br>theme parks, cinemas and similar entertainments</p><p><strong>recreational sites</strong><br>science fictions, romances and other novels</p><p><strong>other movie and literature genres</strong></p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>People working under tremendous pressure are likely to suffer from slumber shortage, serious fever, and severe/frequent headache. These <strong>stress-related</strong> physical problems could be coped with by taking a variety of measures such as doing regular exercises, enjoying natural sceneries and consuming delicious/balanced feasts/diets and even seeking/consulting advice from professional nutritionists and psychologist</p><p>hair lost obesity</p><p>engaging in outdoor/sun-bathed sports</p><p>1、 利用语义关系：上下义词</p><p>2、 利用构词法：词性转换—后缀</p><p>3、 利用构词法：合成词 sound-proof/museum visitors/diet-related</p><p>4、适当省略；适当短句</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Which-—-两者选一个&quot;&gt;&lt;a href=&quot;#Which-—-两者选一个&quot; class=&quot;headerlink&quot; title=&quot;Which —- 两者选一个&quot;&gt;&lt;/a&gt;Which —- 两者选一个&lt;/h1&gt;&lt;h2 id=&quot;14&quot;&gt;&lt;a href=&quot;#14&quot; c</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="TOEFL" scheme="http://yoursite.com/tags/TOEFL/"/>
    
  </entry>
  
  <entry>
    <title>AI复习总结</title>
    <link href="http://yoursite.com/2022/10/29/AI%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/10/29/AI%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-29T23:21:04.000Z</published>
    <updated>2022-12-29T13:22:28.974Z</updated>
    
    <content type="html"><![CDATA[<p>参考有很多，不一一列举，还有很多懒得找了（</p><p><a href="https://blog.csdn.net/weixin_43407273/article/details/110856123" target="_blank" rel="noopener">MCMC采样详解_、寄生于黑暗中的光，的博客-CSDN博客_mcmc采样</a></p><p><a href="https://www.cnblogs.com/wt869054461/p/9899929.html" target="_blank" rel="noopener">马尔可夫毯（Markov Blanket） - 夕月一弯 - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/436214290" target="_blank" rel="noopener">D-separation： 判断贝叶斯网络中的变量是否独立</a></p><p><a href="https://zhuanlan.zhihu.com/p/102014899" target="_blank" rel="noopener"> 概率图模型(PGMs)-马尔可夫网络(Markov Nets)</a></p><p><a href="https://zhuanlan.zhihu.com/p/521329634" target="_blank" rel="noopener">人工智能导论考前复习笔记</a></p><h1 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h1><h2 id="树搜索与图搜索"><a href="#树搜索与图搜索" class="headerlink" title="树搜索与图搜索"></a>树搜索与图搜索</h2><p>Tree Search：不设置vis数组，不考虑节点有无被遍历过</p><p><strong>搜索树（search trees）</strong> </p><p>对于一个状态出现的次数没有限制。</p><p>通过移除一个与部分计划对应的节点（用给定的策略来选择）并用它所有的子节点代替它，我们不断地<strong>扩展expand</strong>我们的边缘。用子节点代缘上的元素,相当于丢弃一个长度为n的计划并考虑所有源于它的长度为（n+1）的计划。我们继续这一操作，直到最终将目标从边缘移除为止。</p><p>Graph Search：设置vis数组，每次出堆的时候就标记visited，每次只遍历邻接的unvisited的点</p><p><strong>图搜索（graph search）</strong></p><p>跟踪哪些状态已经扩展过，确保每一个节点在扩展前不在这个集合中，并且在扩展后将其加入集合里。经过这种优化的树搜索称为<strong>图搜索（graph search）</strong></p><h2 id="DFS-Depth-First-Search"><a href="#DFS-Depth-First-Search" class="headerlink" title="DFS(Depth-First Search)"></a>DFS(Depth-First Search)</h2><p>深度优先搜索，故名意思一条边走到底再回去，优先搜索最深的边，用stack实现，头进头出</p><p>时间复杂度$O(b^m)$ 空间复杂度$O(bm)$</p><p>Complete（完备性）：定义是保证能找到答案在答案存在的情况。深度优先搜索并<strong>不具有完备性</strong>。如果在状态空间图中存在回路，这必然意味着相应搜索树的深度将是无限的。因此，存在这样一种可能性，即DFS老实地在无限大的搜索树中搜索最深的节点而不幸地陷入僵局，注定无法找到解。</p><p>Optimal：显然不是最优</p><p><img src="/2022/10/29/AI复习总结/1.png" alt=""></p><h2 id="BFS-Breadth-First-Search"><a href="#BFS-Breadth-First-Search" class="headerlink" title="BFS(Breadth-First Search)"></a>BFS(Breadth-First Search)</h2><p>广度优先搜索，优先最浅的边，用queue实现，头进尾出</p><p>时间复杂度$O(b^s)$，空间复杂度$O(b^s)$，Shallowest点的深度为s</p><p>Complete：是完整的搜索</p><p>Optimal：只有cost都为1才能找到最优解</p><p><img src="/2022/10/29/AI复习总结/2.png" alt=""></p><h2 id="Iterative-Deepening-迭代加深的深度优先搜索"><a href="#Iterative-Deepening-迭代加深的深度优先搜索" class="headerlink" title="Iterative Deepening(迭代加深的深度优先搜索)"></a>Iterative Deepening(迭代加深的深度优先搜索)</h2><p><strong>Iterative Deepening</strong></p><p><img src="/2022/10/29/AI复习总结/3.png" alt=""></p><p>从深度为0开始，深度不断增大，直到找到目标</p><p>Complete：Yes</p><p>Optimal：Yes</p><p>时间复杂度$ O(b^d)$,空间$O(bd)$<strong>比BFS空间更优</strong></p><h2 id="UCS-Uniform-Cost-Search"><a href="#UCS-Uniform-Cost-Search" class="headerlink" title="UCS(Uniform Cost Search)"></a>UCS(Uniform Cost Search)</h2><p>优先搜索最便宜的点路径，用的是优先队列</p><p>If that solution costs $C^<em>$  and arcs cost(两点间的最小代价)  $\epsilon$  , then the“effective depth” is roughly $C^</em>/\epsilon$</p><p>时间复杂度$O(C^*/\epsilon)$(exponential in effective depth)</p><p>空间复杂度$O(C^*/\epsilon)$</p><p>Complete：Yes</p><p>Optimal：Yes</p><p><img src="/2022/10/29/AI复习总结/4.png" alt=""></p><h2 id="GS-Greedy-Search"><a href="#GS-Greedy-Search" class="headerlink" title="GS(Greedy Search)"></a>GS(Greedy Search)</h2><p>Heuristics函数，估计期望函数一般表示到重点的距离估计</p><p>贪心直往离终点最近的路走，必然不优。</p><p>Complete：Yes</p><p>Optimal：No</p><p>如果存在一个目标状态，贪婪搜索<strong>无法保证能找到它</strong>，它也<strong>不是最优的</strong>，尤其是在选择了非常糟糕的启发函数的情况下。在不同场景中。它的行为通常是不可预测的，有可能一路直奔目标状态，也有可能像一个被错误引导的DFS一样并遍历所有的错误区域。</p><h2 id="A-Search"><a href="#A-Search" class="headerlink" title="A* Search"></a>A* Search</h2><p>$f(n)=g(n)+h(n)$</p><p>结合贪心和UCS，按该点的h+该点到起点的cost</p><p>H函数的性质：①admissible：$0\leq h(n)\leq h^*(n)$，小于实际n到终点的距离。</p><p>②Consistency：$h(A)-h(C)\leq cost(A,C)$，两个点H只差小于真实距离，<strong>满足此性质即可满足最优解</strong></p><p>Consistency $\implies$ admissibility</p><p>A* is optimal if the heuristic is <strong>admissible</strong> in the <strong>tree search</strong>.</p><h1 id="CSP-Constraint-Satisfaction-Problems"><a href="#CSP-Constraint-Satisfaction-Problems" class="headerlink" title="CSP(Constraint Satisfaction Problems)"></a>CSP(Constraint Satisfaction Problems)</h1><p>Constraint Graphs：图上相连的点表示这两个点之间有限制关系</p><h2 id="搜索方法："><a href="#搜索方法：" class="headerlink" title="搜索方法："></a>搜索方法：</h2><p>Backtracking Search：总的来说就是DFS+回溯算法，把所有可以取的值都取试一遍，可以继续就不断往下搜索，遇到问题就返回，不断撤回取值换一个值知道找到解。很慢，会走很多弯路，浪费时间。</p><p><img src="/2022/10/29/AI复习总结/5.png" alt=""></p><h3 id="改进过程"><a href="#改进过程" class="headerlink" title="改进过程"></a>改进过程</h3><h3 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h3><p>每次取值的时候把不能用的过滤掉，减少取值的domain</p><p>①Forward checking：每次划掉与当前取值变量有关联的变量取值，缺点是不能提前发现错误，比如在第三步的时候NT和SA都只能取蓝色其实已经矛盾了，因为每次只检查了与现在在填的格子相邻的格子取值，没有单独考虑相邻格子和其限制点的取值比较。</p><p><img src="/2022/10/29/AI复习总结/6.png" alt=""></p><p>②Constraint Propagation：加入了每次将每个点都和其他相关的限制点domain的比较，加入consitent定义来检查每个点的限制点取值比较</p><p>An arc X → Y is consistent iff for every x in the tail there is some y in the head which could be assigned without violating a constraint</p><p>A simple form of propagation makes sure all arcs are consistent，每次propagation确保每个点都能满足consistent条件</p><p><img src="/2022/10/29/AI复习总结/7.png" alt=""></p><p>这里其实我觉得NSW也可以取蓝色，V变成红绿，这里表现能提前排除错误</p><p>K-Consistency：弧一致性是一个更广义的一致性概念——<strong>k-相容（k-consistency）</strong> 的子集，它在强制执行时能保证对于CSP中的任意k个节点，对于其中任意k-1个节点组成的子集的赋值都能保证第k个节点能至少有一个满足相容的赋值。这个想法可以通过<strong>强k-相容（strong k-consistency）</strong> 的思想进行进一步拓展。一个具有强k-相容的图拥有这样的性质，任意k个节点的集合不仅是k-相容的，也是k-1, k-2, …,1-相容的。于是，在CSP中更高阶的相容计算的代价也更高。在这一广义的相容的定义下，我们可以看出弧相容等价于2-相容。</p><h3 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h3><p>①<strong>最小剩余值Minimum Remaining Values (MRV)</strong>：当选择下一个要赋值的<strong>变量</strong>时，用MRV策略能选择有效剩余值最少的未赋值变量（即约束最多的变量）。这很直观，因为受到约束最多的变量也最容易耗尽所有可能的值，并且如果没有赋值的话最终会回溯，所以最好尽早赋值。</p><p>这个是针对赋值的variable的选择</p><p>②<strong>最少约束值Least Constraining Value (LCV)</strong>：同理，当选择下一个要赋值的<strong>值</strong>时，一个好的策略就是选择从剩余未分配值的域中淘汰掉最少值的那一个。要注意的是，这要求更多的计算（比方说，对每个值重新运行弧相容/前向检测或是其他过滤方法来找到其LCV），但是取决于用途，仍然能获得更快的速度。</p><p>这个是针对对每个variable的value如何选择，尽量不要造成更多约束，选择约束最少的value，如下图应选择红色而不是蓝色</p><p><img src="/2022/10/29/AI复习总结/8.png" alt=""></p><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><h3 id="Tree-Structured-CSPs"><a href="#Tree-Structured-CSPs" class="headerlink" title="Tree-Structured CSPs"></a>Tree-Structured CSPs</h3><p><img src="/2022/10/29/AI复习总结/9.png" alt=""></p><p>Theorem: if the constraint graph has no loops, the CSP can be solved in $O(n d^2 )$ time</p><ul><li>首先，在CSP的约束图中任选一个节点来作为树的根节点（具体选哪一个并不重要，因为基础图论告诉我们一棵树的任一节点都可以作为根节点）。</li><li>将树中的所有无向边转换为指向根节点反方向的有向边。然后将得到的有向无环图<strong>线性化（linearize）</strong>（或<strong>拓扑排序（topologically sort）</strong>）。简单来说，这也就意味着将图的节点排序，让所有边都指向右侧。注意我们选择节点A作为根节点并让所有边都指向A的反方向，这一过程的结果是如下的CSP转换：</li></ul><p>①Remove backward: For i = n : 2, apply RemoveInconsistent(Parent(Xi ),Xi )，从孩子往父亲搜索，剪掉父亲不能consistent的值</p><p>②Assign forward: For i = 1 : n, assign Xi consistently with Parent(Xi )</p><p>从父亲开始往孩子赋值，在孩子中选取和父亲consistent的值</p><h3 id="Nearly-Tree-Structured-CSPs"><a href="#Nearly-Tree-Structured-CSPs" class="headerlink" title="Nearly Tree-Structured CSPs"></a>Nearly Tree-Structured CSPs</h3><p>通过<strong>割集条件设置（cutset conditioning）</strong>，树形结构算法能推广到树形结构相近的的CSP中。割集条件设置包括首先找到一个约束图中变量的最小子集，这样一来删去他们就能得到一棵树（这样的子集称为<strong>割集（cutset）</strong>）。举个例子，在我们的地图染色例题中，South Australia（SA）是可能的最小的割集：</p><p><img src="/2022/10/29/AI复习总结/10.png" alt=""></p><p>意思大概是通过不断的割掉点来减少图的边数和点数吧</p><h1 id="Adversarial-Search"><a href="#Adversarial-Search" class="headerlink" title="Adversarial Search"></a>Adversarial Search</h1><h2 id="Minimax-Values"><a href="#Minimax-Values" class="headerlink" title="Minimax Values"></a>Minimax Values</h2><p>基本内容就是一个人求最大，另一个人为了妨碍这个人只求最小</p><p>由于是本质还是DFS，所以复杂度是$O(b^m)$</p><p><img src="/2022/10/29/AI复习总结/11.png" alt=""></p><h2 id="α-β剪枝-Alpha-Beta-Pruning"><a href="#α-β剪枝-Alpha-Beta-Pruning" class="headerlink" title="α-β剪枝 Alpha-Beta Pruning"></a>α-β剪枝 Alpha-Beta Pruning</h2><p><img src="/2022/10/29/AI复习总结/12.png" alt=""></p><p>简单来说就是对于一个求最大\最小值的父亲节点的子节点，前面已经求出一个孩子的值，由于父亲只会返回最大\最下的孩子节点的值，如果某一个孩子的某一个节点已经相对于前一个孩子的值对父亲没有贡献了，就可以不搜索这个子树了，剪枝掉。</p><p>例子：下图f分支已经有b节点的10，由于a求最小，而f的100大于了10，并且e节点本身是要选最大值的，已经找出一个比较大的可能答案且比10还大，说明a节点不可能选e，故g要被剪。同理对于h节点，i这个还是是2且2已经小于了10，h本身求得的最小值已经小于a节点，根节点就不可能选h了所以l就被剪掉了。</p><p><img src="/2022/10/29/AI复习总结/13.png" alt=""></p><p>时间复杂度：$O(b^{m/2})$</p><p><strong>讨论一下什么节点的孩子是可能会被剪掉的</strong></p><p>①子树节点的最左边的子树一定不会被剪掉，无论如何都要比较第一个值，所以最左边最左下角的子树都要全部遍历（cd,jk)，同时所有没有被剪得节点的左边第一个孩子一定会遍历，比如上图中的f</p><p>②能被剪掉的一定是自己的siblings已经得出了部分答案，自己在被比较的过程中才会因为前一个siblings得出的答案无效所以中止检索。</p><h2 id="估计函数-Evaluation-Function"><a href="#估计函数-Evaluation-Function" class="headerlink" title="估计函数 Evaluation Function"></a>估计函数 Evaluation Function</h2><p>一个好的估计函数能给更好的状态赋更高的值。估计函数在<strong>深度限制（depth-limited）minimax</strong>中广泛应用，即将最大可解深度处的非叶子结点都视作叶子节点，然后用仔细挑选的估计函数给其赋虚值。由于估计函数只能用于估计非叶子结点的效益，这使得minimax的最优性不再得到保证。</p><p>$Eval(s)=w_1f_1(s)+w_2f_2(s)+ …+w_nf_n(s)$</p><p> $f(s)$ 对应从状态s中提取的一个特征，每个特征被赋予了一个相应的权重  。特征就是游戏状态中能够提取并量化的一些元素。</p><h2 id="Expectimax-Search"><a href="#Expectimax-Search" class="headerlink" title="Expectimax Search"></a>Expectimax Search</h2><p>Expectimax在游戏树中加入了<strong>机会节点（chance nodes）</strong>，与考虑最坏情况的最小化节点不同，机会节点会考虑<strong>平均情况（average case）</strong>。更准确的说，最小化节点仅仅计算子节点的最小效益，而机会节点计算<strong>期望效益（expected utility）</strong> 或期望值。Expectimax给节点赋值的规则如下：</p><p><img src="/2022/10/29/AI复习总结/15.png" alt=""></p><p>其中，$p(s’|s)$  要么表示在不能确定操作的情况下从状态s移动到s’的概率，要么表示对手的操作使得最终从s移动到s’的概率，这取决于游戏和游戏树的特性。从这个定义来看，minimax就是expectimax的一种特例，最小化节点就是认为值最小的子节点概率为1而其他子节点概率为0的机会节点。</p><p>总的来说，概率是用来合理反映游戏状态的，但我们会在后面的笔记中更详细地介绍这一过程的原理。现在，我们可以吧这些概率看做游戏自带的特性。</p><p>Expectimax的伪代码与minimax很相似，就是把最小效益换成了期望效益，这是因为最小化节点被替换成了机会节点：</p><p><img src="/2022/10/29/AI复习总结/14.png" alt=""></p><p>关于Expectimax，最后再说一句，需要重点注意的是，必须要遍历机会节点的所有子节点——不能再像minimax中一样进行剪枝。与minimax中求最大值或最小值时不同，每个值都会影响expectimax计算的期望值。不过，当我们已知节点有限的取值范围时，剪枝也是有可能的。</p><h1 id="Propositional-Logic"><a href="#Propositional-Logic" class="headerlink" title="Propositional Logic"></a>Propositional Logic</h1><p><img src="/2022/10/29/AI复习总结/16.png" alt=""></p><h2 id="Conjunctive-Normal-Form-CNF"><a href="#Conjunctive-Normal-Form-CNF" class="headerlink" title="Conjunctive Normal Form (CNF)"></a>Conjunctive Normal Form (CNF)</h2><p>conjunction of disjunctions of literals (clauses)</p><p>基本形式是()里面都是∪，外面套∩</p><h2 id="Horn-logic"><a href="#Horn-logic" class="headerlink" title="Horn logic"></a>Horn logic</h2><p>Horn logic: only (strict) Horn clauses are allowed</p><p>– A Horn clause has the form:</p><p>$P_1 \bigcap P_2 \bigcap …P_n \implies Q$</p><p>or alternatively</p><p>$ \neg P_1 \bigcup \neg  P_2 \bigcup … \neg P_n \bigcup Q$</p><p>where Ps and Q are non-negated proposition symbols</p><h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><p>$[C \bigcup (\neg A \bigcap \neg B)] = [(\neg A \bigcap \neg B)\bigcup (C \bigcap \neg B) \bigcup ( \neg A \bigcap C) \bigcup C]$</p><p>$(\neg A \bigcup \neg B)=((A \bigcap B) \rightarrow (A \bigcap \neg A))$</p><h2 id="Validity-and-satisfiability"><a href="#Validity-and-satisfiability" class="headerlink" title="Validity and satisfiability"></a>Validity and satisfiability</h2><p>A sentence is valid if it is true in all models</p><p>A sentence is satisfiable if it is true in some model</p><p>A sentence is unsatisfiable if it is true in no models</p><p>S is valid iff. $\neg $S is unsatisfiable</p><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><h3 id="entails"><a href="#entails" class="headerlink" title="entails"></a>entails</h3><p>$ A| !!!\ = B$ A entails B,相当于$A \implies B$</p><p>A is valid if and only if True entails A</p><h3 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h3><p>$A | !!!- B$ a demonstration of entailment from A to B</p><p>Method 1: model checking</p><p>Method 2: application of inference rules</p><p><strong>Sound inference</strong>：everything that can be proved is in fact entailed</p><p><strong>Complete inference</strong>：everything that is entailed can be proved</p><p>Resolution algorithm：Prove$KB |!!!= \alpha$ Proof by contradiction,show $KB |!!!= \alpha$ is unsatisfiable</p><ul><li><p>把$KB  \bigcap \neg \alpha$转换为CNF</p></li><li><p>. Repeatedly apply the resolution rule to add new clauses, until one of the two things happens</p><p>a) Two clauses resolve to yield the empty clause, in which</p><p>case$KB |!!! = \alpha $</p><p>b) There is no new clause that can be added, in which case</p><p>KB does not entail α</p></li></ul><h2 id="Forward-chaining"><a href="#Forward-chaining" class="headerlink" title="Forward chaining"></a>Forward chaining</h2><p>从 implies 前面的条件开始往implies后面的值推导</p><p><img src="/2022/10/29/AI复习总结/17.png" alt=""></p><p>从A B L M  P Q ，没往上推 节点的未知数就-1，直到都为0</p><h2 id="Backward-chaining"><a href="#Backward-chaining" class="headerlink" title="Backward chaining"></a>Backward chaining</h2><p>从果找因</p><p>• Idea: work backwards from the query q:</p><p>– to prove q by BC</p><p>• check if q is known to be true already, or prove by BC all premises of some rule concluding q</p><p>• Avoid loops: check if new subgoal is already on the goal</p><p>stack</p><p>• Avoid repeated work: check if new subgoal</p><ol><li><p>has already been proved true, or</p></li><li><p>has already failed</p></li></ol><h1 id="First-Order-Logic"><a href="#First-Order-Logic" class="headerlink" title="First-Order Logic"></a>First-Order Logic</h1><h2 id="FOL"><a href="#FOL" class="headerlink" title="FOL"></a>FOL</h2><p><img src="/2022/10/29/AI复习总结/18.png" alt=""></p><p><strong>In a FOL sentence, every variable must be bound.</strong></p><p>判断是否为FOL句式，要看变量有没有被量词限定</p><h2 id="Atomic-sentences"><a href="#Atomic-sentences" class="headerlink" title="Atomic sentences"></a>Atomic sentences</h2><p><img src="/2022/10/29/AI复习总结/19.png" alt=""></p><p>复杂句子由很多原子句子组成</p><ul><li>任意句式：$\forall x, At(x,stu) \implies Smart(x)$(Everyone at ShanghaiTech is smart)</li></ul><p>一般任意都接imply，不要用并</p><ul><li>存在句式：$\exist x,At(x,stu) \bigcup Smart(x)$ (Someone at ShanghaiTech is smart)</li></ul><p>存在句式用并，不要用imply</p><p><strong>任意和存在量词的一些性质</strong></p><p><img src="/2022/10/29/AI复习总结/20.png" alt=""></p><h2 id="两个变量替换原则"><a href="#两个变量替换原则" class="headerlink" title="两个变量替换原则"></a>两个变量替换原则</h2><ul><li>Universal instantiation (UI)</li></ul><p>全称列举规则，UI 规则的实质，可以看成是包含量词的符号式的展开式，通过简化式推论规则，缩略为其中某个“合取项”。</p><p>大概是变量代入具体的意思（），变量替换</p><ul><li>Existential Instantiation(EI)</li></ul><p>存在列举规则</p><p>存在列举规则，就是摘除存在量词。</p><p>与 UI 不同， EI 规则摘除量词后，该行中的自由变量不是全称，而是被制定出来用以指派一个具体个体的名称。</p><p>请注意，这个个体不是被任意选出的。</p><h2 id="Unification"><a href="#Unification" class="headerlink" title="Unification"></a>Unification</h2><p>好像就是找出一个变量替换的方式。。。如下图找到x,y分别代表什么</p><p><img src="/2022/10/29/AI复习总结/21.png" alt=""></p><h2 id="Forward-chaining-1"><a href="#Forward-chaining-1" class="headerlink" title="Forward chaining"></a>Forward chaining</h2><p>和之前那个Forward chaining差不多，从implies前的推到implies后面的</p><p>性质：</p><ul><li><p>Sound and complete for first-order Horn clauses</p></li><li><p>FC terminates for first-order Horn clauses with no functions (Datalog) in finite number of iterations</p></li><li><p>In general, FC may not terminate if α is not entailed，只要没找到不会中止</p></li></ul><h2 id="Backward-chaining-1"><a href="#Backward-chaining-1" class="headerlink" title="Backward chaining"></a>Backward chaining</h2><p>和之前那个Back chaining差不多，从implies后的找到implies前面的，由果及因</p><p>性质：</p><ul><li><p>Depth-first recursive proof search: space is linear in size of proof线性证明</p></li><li><p>Avoid infinite loops by checking current goal against every goal on stack有效避免无限循环</p></li><li><p>Avoid repeated subgoals by caching previous results不会重复找子问题</p></li></ul><p><strong>FC and BC are sound and complete with Horn clauses and run linear in space and time.</strong></p><h1 id="Bayes-Network"><a href="#Bayes-Network" class="headerlink" title="Bayes Network"></a>Bayes Network</h1><h2 id="条件独立"><a href="#条件独立" class="headerlink" title="条件独立"></a>条件独立</h2><p>$X \perp !!! \perp Y|Z$ : X is conditionally independent of Y given Z</p><p>$X \perp !!! \perp Y|Z \Leftrightarrow P(x|y,z)=P(x|z),P(x,y|z)=P(x|z)P(y|z)$</p><p>贝叶斯网络是一种描述<strong>随机变量之间互相条件独立关系的有向无环图</strong>。在这个有向无环图中，每个节点代表一个<strong>随机变量对其父节点的条件概率分布</strong> $P(X_i|parents(X_i)$ ，每一条边可以理解成变量之间的联系。</p><p>A Bayes net = Topology (graph) + Local Conditional Probabilities</p><p>贝叶斯网络的空间：n变量，最大取值空间d，最大父节点数量k，满节点的分布$O(d^n)$贝叶斯网络大小$O(nd^{k+1})$</p><p>贝叶斯网络是有向无环图，$B \rightarrow A$ 代表B是A的条件，有公式</p><p>$P(X_1,…,X_n)=\prod_{i}P(X_i|Parents(X_i)$</p><p><img src="/2022/10/29/AI复习总结/22.png" alt=""></p><p>When Bayes nets reflect the true causal patterns:</p><p>▪ Often simpler (fewer parents, fewer parameters)</p><p>▪ Often easier to assess probabilities</p><p>▪ Often more robust: e.g., changes in frequency of burglaries should not affect the rest of the model</p><p>BNs need not actually be causal</p><p><strong>BN don’t need to reflect the true causal patterns</strong></p><h3 id="给定贝叶斯网络上部分点，判断两点是否独立："><a href="#给定贝叶斯网络上部分点，判断两点是否独立：" class="headerlink" title="给定贝叶斯网络上部分点，判断两点是否独立："></a>给定贝叶斯网络上部分点，判断两点是否独立：</h3><p><strong>[Step 1]. Draw the ancestral graph.</strong></p><p>根据原始概率图，构建包括表达式中包含的变量以及这些变量的ancestor节点（父节点、父节点的父节点…）的图。<strong>注意不能包括孩子节点，不然会引起错误。</strong></p><p><strong>[Step 2]. “Moralize” the ancestral graph by “marrying” the parents.</strong></p><p>连接图中每个collider结构中的父节点，即若两个节点有同一个子节点，则连接这两个节点。（若一个变量的节点有多个父节点，则分别链接每一对父节点）。</p><p><strong>[Step 3]. “Disorient” the graph by replacing the directed edges (arrows) with undirected edges (lines).</strong></p><p>去掉图中所有的路径方向，将directional graph变为non-directional graph。</p><p><strong>[Step 4]. Delete the givens and their edges.</strong></p><p>从图中删除需要判断的概率表达式中作为条件的变量，以及和他们相连的路径。比如“是否P(A|BDF) = P(A|DF)?”，我们删掉D, F变量以及他们的路径。</p><p><strong>[Step 5]. Read the answer off the graph.</strong></p><ul><li>如果变量之间没有连接，则它们在给定条件下是独立的；</li><li>如果变量之间有路径连接，则它们不能保证是独立的（或者粗略地说他们是不独立的，基于概率图来说）；</li><li>如果其中一个变量或者两者都不包含在现在的图中（作为观测条件，在step 4 被删掉了），那么他们是独立的。</li></ul><p>补充概念：活跃与非活跃道路</p><p><img src="/2022/10/29/AI复习总结/23.png" alt=""></p><h2 id="马尔可夫网络-Markov-Networks"><a href="#马尔可夫网络-Markov-Networks" class="headerlink" title="马尔可夫网络(Markov Networks)"></a>马尔可夫网络(Markov Networks)</h2><p>是一个无向图</p><p>Markov network = undirected graph + potential functions</p><h3 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h3><p><img src="/2022/10/29/AI复习总结/24.png" alt=""></p><p>有一个特定的rule$P(X_1,X_2,…,X_t)=P(X_1)\prod_{t=2}^TP(X_t|X_{t-1})$</p><p>只需要初始概率和条件概率表（CPT）就可以得出任何一个时段，某一件事所要发生的概率。如果一个马尔可夫链接近无限长，最终概率会越来越接近一个平稳大小。</p><p>这个我们称作，静态分布（Stationary Distributions)。每一个马尔可夫链都至少有一个静态分布。对于一些特殊结构的马尔可夫链，可能只有唯一一个静态分布。比如：不可还原的（Irreducible）马尔可夫链或者叫正常的（Regular)马尔可夫链</p><p>表示的是马尔可夫链上的点可以有机会到达其它任何一个点，就表示它是Irreducible。</p><p>当一个马尔可夫链是irreducible的，那么它一定会有唯一一个静止状态。</p><p>但要想确定它是否可能最终收敛到这个静止状态，还需要另外一个属性来判断，看他是不是非周期性的（Aperiodic）</p><h3 id="隐马尔可夫模型-HMM"><a href="#隐马尔可夫模型-HMM" class="headerlink" title="隐马尔可夫模型(HMM)"></a>隐马尔可夫模型(HMM)</h3><p>马尔可夫链的基础上加了一层可观察层，原来的链路变成了不可观察：</p><p><img src="/2022/10/29/AI复习总结/25.png" alt=""></p><p>$P(X_1,E_1,…,X_T,E_T)=P(X_1)P(E_1|X_1)\prod_{t=2}^TP(X_t|X_{t-1})P(E_t|X_t)$</p><p>性质：</p><ol><li>在已知现在(present)的可观察的状态下，未来(future)的可观察的状态，是独立于过去(past)的可观察的状态。</li><li>在已知所有的可观察的状态下，可观察的状态与可观察状态之间是独立的。</li></ol><h2 id="马尔可夫网络-Markov-Nets"><a href="#马尔可夫网络-Markov-Nets" class="headerlink" title="马尔可夫网络(Markov Nets)"></a>马尔可夫网络(Markov Nets)</h2><p>对于马尔可夫网络中，我们也可以用势能 （$\phi_i$ ）来表示不同结点间影响力的大小或者结点团之间影响力的大小。其实这个概念是源自物理中的势能。</p><p>我们可以通过一个被称作联合分布函数的来表示这个马尔可夫网络（也被称作吉布斯分布/Gibbis分布）</p><p>引入一个clique（小集团）的定义，用这个来定义分布</p><p>$P(X)=\frac{1}{Z}\prod_{c\in cliques(H)}\phi_c(x_c)$</p><p>$Z=\sum_x \prod_{c \in cliques(H)}\phi_c(x_c)$</p><p><img src="/2022/10/29/AI复习总结/27.png" alt=""></p><p><img src="/2022/10/29/AI复习总结/26.png" alt=""></p><p>$P(X)=\frac{1}{Z}\phi_1(A,B)\phi_2(B,C)\phi_3(C,D)\phi_4(D,A)$</p><h2 id="马尔可夫毯"><a href="#马尔可夫毯" class="headerlink" title="马尔可夫毯"></a>马尔可夫毯</h2><p>简单来说就是T的父亲节点+T的孩子+T的孩子的父亲</p><p><img src="/2022/10/29/AI复习总结/28.png" alt=""></p><h3 id="贝叶斯网络和马尔可夫网络的转换"><a href="#贝叶斯网络和马尔可夫网络的转换" class="headerlink" title="贝叶斯网络和马尔可夫网络的转换"></a>贝叶斯网络和马尔可夫网络的转换</h3><p>Steps</p><ol><li><p>Moralization</p></li><li><p>Construct potential functions from CPTs</p></li></ol><p>The BN and MN encode the same distribution，两个表示同一个分布</p><p>But they don’t encode the same set of conditional independence但表示的独立性不同</p><p>①链式结构，直接转换</p><p><img src="/2022/10/29/AI复习总结/29.png" alt=""></p><p>②非链式结构，要加边</p><p>只要有共同的父亲就要练边，每个父亲两两相连</p><p><img src="/2022/10/29/AI复习总结/30.png" alt=""></p><h1 id="Bayes-Nets-Exact-Inference"><a href="#Bayes-Nets-Exact-Inference" class="headerlink" title="Bayes Nets: Exact Inference"></a>Bayes Nets: Exact Inference</h1><p>calculating some useful quantity from a probabilistic model (joint probability distribution)</p><h2 id="Join-factors"><a href="#Join-factors" class="headerlink" title="Join factors"></a>Join factors</h2><p>字面意思就是把条件放到条件前面去$P(r) * P(t|r) \rightarrow P(r,t)$</p><p>需要一直单独的概率和条件概率</p><p><img src="/2022/10/29/AI复习总结/31.png" alt=""></p><h2 id="Eliminate-factors"><a href="#Eliminate-factors" class="headerlink" title="Eliminate factors"></a>Eliminate factors</h2><p>直接把某个变量删掉，必须知道联合分布</p><p>一般采用enumeration 的顺序，即从条件到非条件，沿着箭头来，但也可以不按这个顺序来。</p><p>每次eliminate一个变量就相当于把他哦才能够贝叶斯网络里面划掉，只用eliminate目标变量的祖先节点，不用管孩子节点。</p><p><img src="/2022/10/29/AI复习总结/32.png" alt=""></p><h1 id="Bayes-Nets-Approximate-Inference"><a href="#Bayes-Nets-Approximate-Inference" class="headerlink" title="Bayes Nets: Approximate Inference"></a>Bayes Nets: Approximate Inference</h1><h2 id="Prior-Sampling-直接采样"><a href="#Prior-Sampling-直接采样" class="headerlink" title="Prior Sampling (直接采样)"></a>Prior Sampling (直接采样)</h2><p>生成全联合概率分布，这里可以理解为路上的随机采访，因为每个节点的值概率是不一样的，所以在每个节点采样值和概率相关，我们就是通过直接采样，就像街上的直接采访一样，一个一个采样，最后生成一个概率分布表。</p><p>直接按原图的顺序一个个采就行</p><p><img src="/2022/10/29/AI复习总结/33.png" alt=""></p><h2 id="Rejection-Sampling-拒绝采样"><a href="#Rejection-Sampling-拒绝采样" class="headerlink" title="Rejection Sampling(拒绝采样)"></a>Rejection Sampling(拒绝采样)</h2><p>在直接采样的基础上删去不符合的样本</p><p>对于含有随机接受度的拒绝采样，如果采样被拒绝了即取负值，则在下一个接受度重新取直到是正的再继续取别的。只要被拒绝就重新采样。</p><p><img src="/2022/10/29/AI复习总结/34.png" alt=""></p><h2 id="Likelihood-Weighting-似然加权"><a href="#Likelihood-Weighting-似然加权" class="headerlink" title="Likelihood Weighting(似然加权)"></a>Likelihood Weighting(似然加权)</h2><p>对<strong>证据变量不采样</strong>，直接利用条件分布表的概率，给每个样本一个权重，也称作似然。</p><p>我的理解就是weight就是证据变量的条件概率乘积下图的意思就是采样S,W是证据变量，其他都要有一个采样这里sample是c,s,r,w，c,r都是采样的</p><p>所以该样本weight就等于$P(S|C)P(W|S,R)$，这个1.0指的是weight一开始就是1.0给我干寂寞了之前一直没看懂</p><p>weight是evidence的$e_i,\prod_i^mP(e_i|Parents(e_i))$</p><p><img src="/2022/10/29/AI复习总结/35.png" alt=""></p><p>下图写的就是这个过程</p><p><img src="/2022/10/29/AI复习总结/36.png" alt=""></p><p>下面就是计算完所有权值之后再来算给定的条件概率，对比普通的采样是直接根据有多少个才看作是w，这个是每个w不同</p><p><img src="/2022/10/29/AI复习总结/37.png" alt=""></p><p>还有一种给你随机序列让你完成一组采样和weight计算的类型</p><p>estimate$P(C=1|B=1,E=1)$，已知B,E为evidence，要采样剩余的A,C,D</p><p>采样标准：select a value <img src="http://latex.codecogs.com/svg.latex?a" alt=""> from the table, and choose $W=1$if$a \geq P(W=0) $</p><p>根据第一个值0.249&gt;0.2,A=1,0.052&lt;0.6,C=0,0,299&lt;0.6 D=0</p><p>故A=1,C=0,D=0</p><p>$weight=P(B|A)P(\neg C,\neg D|E)=0.8*0.8=0.64$<br><img src="/2022/10/29/AI复习总结/40.png" alt=""></p><p><img src="/2022/10/29/AI复习总结/39.png" alt=""></p><h2 id="Gibbs-Sampling-吉布斯采样"><a href="#Gibbs-Sampling-吉布斯采样" class="headerlink" title="Gibbs Sampling(吉布斯采样)"></a>Gibbs Sampling(吉布斯采样)</h2><p>先确定一个evidence，已经有一个固定值了，然后随机初始化其他的所有变量，之后随便选一个不是evidence I的变量进行采样，现要求这个I的马尔可夫毯的条件概率如下图就是</p><p>先求weight$w(s|c,r,\neg w)=P(s|c)P(\neg w|s,r),w(\neg s|c,r,\neg w)=P(\neg s|c)P(\neg w|\neg s,r)$</p><p>再求$p(s|c,r,\neg w)=w(s|c,r,\neg w)/(w(s|c,r,\neg w)+w(\neg s|c,r,\neg w))$</p><p>$p(\neg s|c,r,\neg w)=w(\neg s|c,r,\neg w)/(w(s|c,r,\neg w)+w(\neg s|c,r,\neg w))$</p><p>一般来说是直接算完就行了，可能会给一个接受率然后根据这个来决定sample T还是F，可能会给一个随机值r让$r \leq p(s|c,r,\neg w))$就取T，不然就是F~~~~</p><p><img src="/2022/10/29/AI复习总结/38.png" alt=""></p><h2 id="MCMC-Markov-Chain-Monte-Carlo"><a href="#MCMC-Markov-Chain-Monte-Carlo" class="headerlink" title="MCMC(Markov Chain Monte Carlo)"></a>MCMC(Markov Chain Monte Carlo)</h2><p>Markov chain = a sequence of randomly chosen states (“random walk”), where each state is chosen conditioned on the previous state</p><p>MCMC = sampling by constructing a Markov chain</p><p>基本思路：在随机变量x的状态空间S上定义一个满足遍历定理的马尔可夫链$X=x_0,x_1,…,x_t,….$，使得平稳分布就是抽样的目标分布$p(x)p ( x ) 。然后在这个马尔可夫链上开始随机游走，每个时刻得到一个样本。根据遍历定理，当时间趋于无穷时，样本的分布是趋于平稳分布的，样本的函数均值趋于函数的期望均值。所以说当时间足够长时(比如说当n&gt;m时)(从时刻1到m我们称之为燃烧期)，在m时刻之后的时间里随机游走得到的样本值就是对目标分布抽样的结果，得到的函数均值就是近似函数的数学期望。</p><p>马尔可夫蒙特卡罗法基本步骤：</p><ul><li><p>首先，在随机变量x的状态空间S上构造一个满足遍历定理的马尔科夫链，使其平稳分布为目标分布$p(x)$。</p></li><li><p>从状态空间中的某一点开始出发，用构造的马尔科夫链进行随机游走，产生样本序列$x_0,x_1,…,x_t$。</p></li><li><p>确定正整数m和n，得到样本值集合$x_{m+1},…,x_n$。求的函数$f(x)$的均值：$E_{p(x)}[f(x)]=\frac{1}{n-m}\sum_{i=m+1}^nf(x_i)$</p></li></ul><h3 id="Metropolis-Hastings"><a href="#Metropolis-Hastings" class="headerlink" title="Metropolis-Hastings"></a>Metropolis-Hastings</h3><p>首先先定义采样时刻t-1的采样值为x，t时刻的采样值为x’，所以对于要抽样的概率分布$p(x)$采用转移核为$p(x,x’)$的马尔科夫链：$p(x,x’)=q(x,x’)\alpha(x,x’)$</p><p>其中$q(x,x’)$和$\alpha(x,x’)$分布被称之为提议分布和接受率。而提议分布是另一个马尔可夫链的转移核，是一个比较容易抽样的分布。而接受分布$\alpha(x,x’)$是：$\alpha(x,x’)=min(1,\frac{p(x’)q(x’,x)}{p(x)q(x,x’)})$</p><ul><li><p>任意选一个初始值$x_0$</p></li><li><p>对于$i=1,2,…,n$ 循环操作 ①对于$x_{i-1}=x$按分布$q(x,x’)$ 随机抽取一个候选状态$x’$②计算$\alpha(x,x’)$③在(0,1)中去一个随机值如果$\alpha(x,x’)\geq u$<br>则$x_i=x’$否则$x_i=x$</p></li><li><p>最后得到样本合集$x_{m+1},…,x_n$，算$E_{p(x)}[f(x)]=\frac{1}{n-m}\sum_{i=m+1}^nf(x_i)$</p></li></ul><p>吉布斯采样就是接受值一直为1的特例，一直接受新采样的样本</p><h1 id="Markov-logic"><a href="#Markov-logic" class="headerlink" title="Markov logic"></a>Markov logic</h1><p> A Markov Logic Network (MLN) is <strong>a set of pairs (F, w)</strong></p><p>where</p><ul><li><p>F is a formula in first-order logic</p></li><li><p>w is a real number</p></li></ul><p>Together with a set of <strong>constants</strong>, it defines a Markov network with</p><ul><li><p>One node for each grounding of each predicate in the MLN</p></li><li><p>One clique for each grounding of each formula F in the MLN, with the potential being: exp(w) for node assignments that satisfy F, 1 otherwise</p></li></ul><p><img src="/2022/10/29/AI复习总结/61.png" alt=""></p><p><img src="/2022/10/29/AI复习总结/62.png" alt=""></p><p><strong>MLN is template for ground Markov nets</strong></p><p>Probability of a word x: $P(x)=\frac{1}{Z}(\sum_iw_in_i(x))$,$w_i$ weight of formula i, $n_i(x)$ No. of true groundings of formula i in x</p><p><img src="/2022/10/29/AI复习总结/63.png" alt=""></p><p>Infinite weights -&gt; First-order logic</p><p><strong>Markov logic allows contradictions between formulas</strong></p><h3 id="Relation-to-PRM"><a href="#Relation-to-PRM" class="headerlink" title="Relation to PRM"></a>Relation to PRM</h3><ul><li><p>MLN is More general and flexible than PRM</p></li><li><p>In principle, a PRM can be converted into a MLN by writing a formula for each entry of each CPT and setting the weight to be the logarithm of the conditional probability</p></li></ul><p><img src="/2022/10/29/AI复习总结/64.png" alt=""></p><h1 id="Markov-Models"><a href="#Markov-Models" class="headerlink" title="Markov Models"></a>Markov Models</h1><p>▪  <strong>Past and future independent given the present</strong></p><p>▪ <strong>Each time step only depends on the previous</strong></p><p>first-order Markov model</p><h3 id="Stationary-distribution"><a href="#Stationary-distribution" class="headerlink" title="Stationary distribution"></a>Stationary distribution</h3><p>求无限的分布时候：$P_{\infty }(X)=\sum_xP(X|x)P_{\infty}(x) $</p><p><img src="/2022/10/29/AI复习总结/41.png" alt=""></p><h2 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h2><p>If the hidden state at time t is given, both the evidence at time t and the hidden state at time t + 1 are independent of the hidden state at time t − 1.</p><ol><li><p>先求$P(x_t|e_{1:t})$，一般为已知，没有e0就直接用，有先算$P(x_0|e_0)=P(e_0|x_0)P(x_0)$</p></li><li><p>再求$P(e_{t+1}|x_{t+1})\sum_{x_t}P(x_t|e_{1:t})P(X_{t+1}|x_t)$</p></li><li><p>最后标准化</p></li></ol><p>$P(X_{t+1}|e_{1:t})=\sum_{X_t}P(X_t|e_{1:t})P(X_{t+1}|X_t,e_{1:t})$</p><p><img src="/2022/10/29/AI复习总结/42.png" alt=""></p><h3 id="Forward-algorithm"><a href="#Forward-algorithm" class="headerlink" title="Forward algorithm"></a>Forward algorithm</h3><p>cost per time:$O(|X|^2)$,$|X|$ 是state数量</p><p>$f_{1:t+1}=\alpha P(e_{t+1}|x_{t+1})\sum_{x_t}f_{1:t}[x_t]P(X_{t+1}|x_t)$</p><p><img src="/2022/10/29/AI复习总结/43.png" alt=""></p><h3 id="Viterbi-algorithm"><a href="#Viterbi-algorithm" class="headerlink" title="Viterbi algorithm"></a>Viterbi algorithm</h3><p>Forward求和，这个求最大值</p><p>$m_{1:t+1}=P(e_{t+1}|x_{t+1})max_{x_t}{m_{1:t}[x_t]P(X_{t+1}|x_t)}$</p><p>Time:$O(|X|^2T)$, Space $O(|X|T)$,T length of sequence</p><p>Both the time complexity and the space complexity of the Viterbi algorithm are linear in  the length of the sequence.</p><p><img src="/2022/10/29/AI复习总结/45.png" alt=""></p><p>两者比较，时间复杂度相同</p><p><img src="/2022/10/29/AI复习总结/44.png" alt=""></p><h2 id="Dynamic-Bayes-Nets"><a href="#Dynamic-Bayes-Nets" class="headerlink" title="Dynamic Bayes Nets"></a>Dynamic Bayes Nets</h2><p>▪ Every HMM is a DBN，hmm都是dbn</p><ul><li>Every hidden Markov model can be represented as a dynamic Bayesian network with a single state variable and a single evidence variable.</li></ul><p>▪ Each HMM state is Cartesian product of DBN state variables</p><p>▪ Every discrete DBN can be represented by a HMM，只有离散的dbn才是hmm</p><p>DBN优点：参数更少，Sparse dependencies</p><h2 id="Particle-Filtering"><a href="#Particle-Filtering" class="headerlink" title="Particle Filtering"></a>Particle Filtering</h2><p>Represent belief state at each step by a set of samples（Samples are called particles）</p><p>Each iteration of particle fifiltering consists of propagate forward, observe and resample</p><p><strong>Initialization</strong></p><p>▪ sample N particles from the initial distribution $P(X_0 ）$，All particles have a weight of 1</p><p>▪ Each particle is moved by sampling its next position from the transition model:$x_{t+1} $~$P(X_{t+1}|x_t)$</p><p>▪ Similar to likelihood weighting, weight samples based on the evidence $W=P(e_t|x_t)$</p><p>▪ Rather than tracking weighted samples, we resample. Each new sample is selected from the current population of samples; the probability is proportional to its weight</p><p><img src="/2022/10/29/AI复习总结/46.png" alt=""></p><h1 id="Markov-Decision-Processes"><a href="#Markov-Decision-Processes" class="headerlink" title="Markov Decision Processes"></a>Markov Decision Processes</h1><p><strong>MDPs are non-deterministic search problems</strong></p><p>MDP satisfy the memoryless property.</p><p>马尔可夫决策过程是一个五元组，求解一个马尔可夫决策过程，则意味着找到最优<strong>策略π*</strong></p><p>S：有限状态集</p><p>A：有限动作集</p><p>P：状态转移矩阵 (也有的地方是T)</p><p>R：奖励函数</p><p>γ：折扣因子 是给定状态的动作分布 <strong>状态值函数：</strong><br> <strong>动作值函数：</strong>  状态值函数的<strong>贝尔曼期望方程</strong>：某一个状态的价值可以用该状态下所有动作的价值表述  动作值函数的<strong>贝尔曼期望方程</strong>： 某一个动作的价值可以用该状态后继状态的价值表述，及 发生了动作a的价值</p><h3 id="贝尔曼-Bellman-方程"><a href="#贝尔曼-Bellman-方程" class="headerlink" title="贝尔曼(Bellman)方程"></a><strong>贝尔曼(Bellman)方程</strong></h3><ol><li>一个状态s的最优值$V^*(s)$ </li></ol><p>——s的最优值是一个从s出发的agent在其余下寿命中采取最优行动能获得的效益的期望值。</p><ol start="2"><li>一个q状态(s,a)的最优值$Q^*(s,a)$ </li></ol><p>——(s,a)的最优值是一个agent从状态s采取行动a之后获得的效益的期望值，并且该agent从此以后采取的都是最优行动。</p><ol start="3"><li>最优策略$\pi ^*(s)$</li></ol><p>$Q^<em>(s,a)=\sum_{s’}T(s,a,s’)[R(s,a,s’)+ \gamma V^</em>(s’)]$,$V^<em>(s)=max_a\sum_{s’}T(s,a,s’)[R(s,a,s’)+\gamma V^</em>(s’)]$</p><h3 id="值迭代-Value-Iteration-求解马尔科夫决策过程"><a href="#值迭代-Value-Iteration-求解马尔科夫决策过程" class="headerlink" title="值迭代 (Value Iteration)求解马尔科夫决策过程"></a><strong>值迭代 (Value Iteration)求解马尔科夫决策过程</strong></h3><p>现在我们有了一个能验证MDP中各状态的值的最优性的框架，接下来自然就想知道如何能精确计算出这些最优值。为此我们需要<strong>限时值（time-limited values）</strong>（强化有限界得到的结果）。限制时间步数为k的一个状态s的限时值表示为 $V_k(s)$ ，代表着在已知当前MDP会在k时间步后终止的情况下，从s出发能得到的最大期望效益。这也正是一个在MDP的搜索树上执行的k层expectimax所返回的东西。</p><blockquote><p>简单来说，值迭代就是给定k，也就是步数为k，在这k步之内，我们希望值迭代已经到达稳定状态，即下一次迭代与这一次的完全相同，这时我们就得到一个最优决策，也就是从哪里出发能够得到最大期望效益。</p></blockquote><p>$V_{k+1}(s)\leftarrow max_a \sum_{s’}T(s,a,s’)[R(s,a,s’)+\gamma V_k(s’)]$</p><p>Time:$O(S^2A)$</p><p>$V_k$ converge as long as $\gamma &lt;1$</p><h3 id="策略迭代-Policy-Iteration求解马尔科夫决策过程"><a href="#策略迭代-Policy-Iteration求解马尔科夫决策过程" class="headerlink" title="策略迭代 Policy Iteration求解马尔科夫决策过程"></a><strong>策略迭代 Policy Iteration求解马尔科夫决策过程</strong></h3><p>Time:$O(S^2A)$ </p><p><strong>策略提取 Policy Extraction</strong></p><p>还记得我们解决MDP的最终目标是要确定一个最优策略。只需要确定所有状态的最优值就能达成这一目标，这可以通过一种叫策略提取(policy extraction)的方法来实现。策略提取的背后的思想非常简单：如果你处于一种状态s，你应该采取会产生最大期望效益的行动a。不难想到，a正是会将我们带到具有最大q值的q状态的操作，于是最优策略可以表达为：</p><p>$\pi^<em>(s)=argmax_a\sum_{s’}T(s,a,s’)[R(s,a,s’)+\gamma V^</em>(s’)]$</p><p>为了取得最好的效益，状态的最优q值对策略提取来说是最好的，因为在这种情况下，只需要一次argmax就能确定从一个状态出发的最优行动。仅保存每个 $V^*(s)$意味着我们必须在取argmax之前用Bellman方程重新计算所有必须的q值，相当于进行一次深度为1的expectimax。</p><p><img src="/2022/10/29/AI复习总结/47.png" alt=""></p><p><strong>策略迭代 Policy Iteration</strong></p><p>值迭代可能会很慢。在每次迭代中，我们必须更新所有|S|个状态的值（|n|表示集合中元素的个数），其中每个都要求在我们计算每个行动的q值时对所有|A|个行动进行迭代。对这些每个q值的计算，需要轮流对|S|个状态再次进行迭代，导致时间成本过高  。此外，当我们只想确定MDP的最优策略时，值迭代会进行大量多余的计算，因为由策略提取得到的策略通常会比值本身更快地收敛。修正这些缺陷的方法就是选择策略迭代，这种算法可以在保持值迭代的最优性的同时还能对表现进行大幅提升。策略迭代的操作如下：</p><ol><li><p>定义一个初始策略。这个可以随意定，但是如果初始策略越接近最优策略，策略迭代收敛得也就越快。</p></li><li><p>重复以下操作，直至收敛：  </p></li><li><p>用<strong>策略评估</strong>对当前策略进行评估。对于一个策略π，策略评估意味着计算所有状态s的Vπ(s)，其中Vπ(s)表示按照策略π从状态s出发的期望效益：   $V^\pi (s)=max_a\sum_{s’}T(s,a,s’)[R(s,a,s’)+\gamma V^\pi(s’)]$</p></li><li><p>把策略迭代的第i次迭代成为πi。由于我们正在对每个状态的一个行动进行修正，我们不再需要取最大的操作max operator，这样我们得到的系统就能有效由以上规则生成的|S|个方程构成的。然后每个$V^{\pi_i}(s)$ 就可以通过解决这个系统来计算得到。</p></li></ol><p>评估完当前策略后，用<strong>策略改进 policy improvement</strong>来生成更好的策略。策略改进通过对由策略评估生成的状态的值进行策略提取，生成以下改进提升后的策略：</p><p>$\pi_{i+1}(s)=argmax_a\sum_{s’}T(s,a,s’)[R(s,a,s’)+\gamma V^{\pi_i}(s’)]$</p><p>策略迭代就是给定初始策略，不断进行策略评估-&gt;策略提取-&gt;策略改进直至收敛</p><h3 id="值迭代和策略迭代比较"><a href="#值迭代和策略迭代比较" class="headerlink" title="值迭代和策略迭代比较"></a>值迭代和策略迭代比较</h3><p>▪ Both value iteration and policy iteration compute the same thing (all optimal values)计算一样的东西</p><p>▪<strong>In value iteration:</strong></p><p>▪ Every iteration updates both the values and (implicitly) the policy</p><p>▪ We don’t track the policy, but taking the max over actions implicitly recomputes it</p><p>▪ <strong>In policy iteration:</strong></p><p>▪ We do several passes that update utilities with fixed policy (each pass is fast because we consider only one action, not all of them)</p><p>▪ After the policy is evaluated, a new policy is chosen (slow like a value iteration pass)</p><p>▪ May converge faster，会更快收敛</p><p><strong>Both are dynamic programs for solving MDPs</strong></p><h1 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h1><p>Offline Planning</p><p>▪ You determine all quantities through computation</p><p>▪ You need to know the details of the MDP</p><p>▪ You do not actually play the game!</p><p>Online Planning</p><p>不需要transition model for states and actions，reward funcition for every allowed transition between states</p><p><img src="/2022/10/29/AI复习总结/48.png" alt=""></p><h2 id="Model-Based-Learning"><a href="#Model-Based-Learning" class="headerlink" title="Model-Based Learning"></a>Model-Based Learning</h2><p><strong>离线学习</strong>(off-line)也通常称为批学习，是指对独立数据进行训练，将训练所得的模型用于预测任务中。将全部数据放入模型中进行计算，一旦出现需要变更的部分，只能通过再训练(retraining)的方式，这将花费更长的时间，并且将数据全部存在服务器或者终端上非常占地方，对内存要求高。Q学习就是离线学习</p><p><strong>在线学习</strong>(in-line)也称为增量学习或适应性学习，是指对一定顺序下接收数据，每接收一个数据，模型会对它进行预测并对当前模型进行更新，然后处理下一个数据。这对模型的选择是一个完全不同，更复杂的问题。需要混合假设更新和对每轮新到达示例的假设评估。换句话说，你只能访问之前的数据，来回答当前的问题。</p><h2 id="Model-Free-Learning"><a href="#Model-Free-Learning" class="headerlink" title="Model-Free Learning"></a>Model-Free Learning</h2><ul><li><p>Input: a fixed policy (s)</p></li><li><p>You don’t know the transitions T(s,a,s’)</p></li><li><p>You don’t know the rewards R(s,a,s’)</p></li><li><p>Goal: learn the state values</p></li></ul><h3 id="Direct-Evaluation"><a href="#Direct-Evaluation" class="headerlink" title="Direct Evaluation"></a>Direct Evaluation</h3><p>Goal: Compute values for each state under $\pi$</p><p>Idea: Average together observed sample values</p><p>▪ Act according to $\pi$</p><p>▪ Every time you visit a state, write down what the sum of discounted rewards turned out to be</p><p>▪ Average those samples</p><p><strong>Good</strong>: </p><p>▪ It’s easy to understand</p><p>▪ It doesn’t require any knowledge of T, R</p><p>▪ It eventually computes the correct average values, using just sample transitions</p><p><strong>Bad</strong>:<br>▪ It wastes information about state connections</p><p>▪ Each state must be learned separately</p><p>▪ So, it takes a long time to learn</p><h3 id="Passive-Reinforcement-Learning"><a href="#Passive-Reinforcement-Learning" class="headerlink" title="Passive Reinforcement Learning"></a>Passive Reinforcement Learning</h3><p>TD学习的基本思想是<strong>从每一次经验中学习</strong>（这里我的理解是从v中学习，一定程度上也可以称为v学习），而不是像直接评估那样简单地记录总奖励和访问状态并在最后学习。在策略评估中，我们使用固定策略和贝尔曼方程产生的方程评估该策略下的状态值：</p><p><strong>Temporal Difference Learning</strong></p><p>▪ (Policy still fixed, still doing evaluation!)</p><p>▪ Move the value towards the sample</p><p><img src="/2022/10/29/AI复习总结/49.png" alt=""></p><p>Decreasing learning rate (alpha) can give converging averages</p><h2 id="Model-Based-Learning-1"><a href="#Model-Based-Learning-1" class="headerlink" title="Model-Based Learning"></a>Model-Based Learning</h2><p>▪ Learn an approximate model based on experiences</p><p>▪ Solve for values as if the learned model was correct</p><ul><li><p>Step 1: Learn empirical MDP model</p></li><li><p>Step 2: Solve the learned MDP</p></li></ul><h3 id="Active-Reinforcement-Learning"><a href="#Active-Reinforcement-Learning" class="headerlink" title="Active Reinforcement Learning"></a>Active Reinforcement Learning</h3><p><img src="/2022/10/29/AI复习总结/50.png" alt=""></p><p>Q-learning can converge to the optimal policy even if you are acting sub-optimally when you explore.</p><p>The factor for Q-learning to converge to the optimal Q-values:</p><ul><li><p>Every state-action pair is visited infinitely often.</p></li><li><p>The learning rate is decreased to 0 over time.</p></li></ul><p><strong>Full reinforcement learning</strong></p><p>▪ You don’t know the transitions T(s,a,s’)</p><p>▪ You don’t know the rewards R(s,a,s’)</p><p>▪ You choose the actions now</p><p>▪ Goal: learn the optimal policy / values</p><p>Q-learning：off-policy learning</p><p><img src="/2022/10/29/AI复习总结/51.png" alt=""></p><h3 id="Regret"><a href="#Regret" class="headerlink" title="Regret"></a>Regret</h3><p>The $\epsilon $-greedy strategy often produces a lower regret for a decaying $\epsilon$ than a fixed one.</p><p>Regret is a measure of your total mistake cost: the difference between your (expected) rewards, including youthful suboptimality, and optimal (expected) rewards</p><p>Minimizing regret goes beyond learning to be optimal – it requires optimally learning to be optimal</p><h2 id="Approximate-Q-Learning"><a href="#Approximate-Q-Learning" class="headerlink" title="Approximate Q-Learning"></a>Approximate Q-Learning</h2><p>Approximate Q-learning is model-free learning</p><p>▪ Learn about some small number of training states from experience</p><p>▪ Generalize that experience to new, similar situations</p><p>Compared with Q-learning, approximate Q-learning that describes each state with a vector of features can be helpful when the number of states is huge.</p><h3 id="Linear-Value-Functions"><a href="#Linear-Value-Functions" class="headerlink" title="Linear Value Functions"></a>Linear Value Functions</h3><p><img src="/2022/10/29/AI复习总结/52.png" alt=""></p><p>  Q-learning:</p><p>transition=$(s,a,r,s’)$</p><p>difference=$[r+\gamma max_{a’}Q(s’,a’)]-Q(s,a)$</p><p>$Q(s,a)=Q(s,a)+\alpha [difference],w_i=w_i+\alpha [difference]f_i(s,a)$</p><h1 id="Supervised-Machine-Learning"><a href="#Supervised-Machine-Learning" class="headerlink" title="Supervised Machine Learning"></a>Supervised Machine Learning</h1><h2 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naïve Bayes"></a>Naïve Bayes</h2><p>$P(Y,F_1,…,F_n)=P(Y)\prod _iP(F_i|Y)$</p><p>nx|F|x|Y| parameters</p><p><strong>Total number of parameters is linear in n</strong></p><p>Goal: compute posterior distribution over label variable</p><p>The na ̈ıve Bayes assumption takes all features to be independent given the class label.</p><h2 id="Overfitting过拟合"><a href="#Overfitting过拟合" class="headerlink" title="Overfitting过拟合"></a>Overfitting过拟合</h2><p><strong>原因：</strong></p><p>1.训练集的数据太少</p><p>2.训练集和新数据的特征分布不一致</p><p>3.训练集中存在噪音。噪音大到模型过分记住了噪音的特征，反而忽略了真实的输入输出间的关系。</p><p>4.权值学习迭代次数足够多，拟合了训练数据中的噪音和训练样例中没有代表性的特征。</p><p><strong>解决方法：</strong></p><p>加大数据集（Training and test Set）使模型在训练的过程中尽可能多的见到更多的问题，从而使学到的分布更加全面更加General。比如采集更多的样本，或者采取Data Augmentation的方法。</p><p>改进你的模型。<br>2.1. 比如将你的模型进行简化，从而减少一些不重要的参数和属性。比如如果你使用神经网络，你可以减少Hidden Layer，或者减少每个Hidden Layer中的神经元数量（Dropout等）；或者如果你使用Adaboost这类的Ensemble Learning方法，你可以减少模型所包含的Weak Learner的数量，并且尽可能的简化每一个Weak Learner。<br>2.2 你也可以采取一些Regularization的方法主动地调节模型的参数值，比如L1， L2 Norm等等。采用这类方法，可以很大程度的惩罚模型内部的参数，从而阻止Overfitting的发生。（之后的专栏会有介绍）。</p><p>提前结束无意义的训练 Early Stop。比如当我们训练一个Logistic Regression时，我们的目标是专注于找到合适的参数，使Loss（error）尽可能的小。如果重复过多次数的训练，会导致训练出来的模型过分专注于解决训练集，从而使模型不具备Generalization。如下图，可以看到，过多的training iteration，确实可以降低Training Loss，但是也会使模型过分专注于training Samples,从而使Test Loss提高（即Overfit）。这时候我们需要提前结束训练，阻止Test Error的提升。</p><p><strong>Avoid overfitting</strong></p><ul><li><p>Acquire more training data (not always possible)</p></li><li><p>Remove irrelevant attributes (not always possible)</p></li><li><p>Limit the model expressiveness by regularization, early stopping, pruning, etc.</p></li><li><p>We can use smoothing or regularization to improve model’s generalization.</p></li></ul><p>we may smooth the empirical rate to improve generalization</p><h2 id="Laplace-Smoothing"><a href="#Laplace-Smoothing" class="headerlink" title="Laplace Smoothing"></a>Laplace Smoothing</h2><p><img src="/2022/10/29/AI复习总结/53.png" alt=""></p><p>$c(x)$权重，k给定，|X|x有多少取值，N x权重和</p><h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><p>Least squares: Minimizing squared error最小二乘法</p><h1 id="Unsupervised-Machine-Learning"><a href="#Unsupervised-Machine-Learning" class="headerlink" title="Unsupervised Machine Learning"></a>Unsupervised Machine Learning</h1><h2 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h2><p><img src="/2022/10/29/AI复习总结/54.png" alt=""></p><h2 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h2><p>The EM algorithm can be used to learn any model with hidden variables (missing data)</p><p>[E step] Compute probability of each instance having each possible label，Compute label distribution of each data point</p><p>[M step] Treating each instance as fractionally having both labels,</p><p>compute the new parameter values，Compute weighted MLE of parameters given label distributions, When using the EM algorithm to learn a Gaussian mixture model, the M-step computes weighted maximum likelihood estimation (MLE).</p><p><img src="/2022/10/29/AI复习总结/55.png" alt=""></p><p>The label distributions computed at E-step are point-estimations</p><p><img src="/2022/10/29/AI复习总结/56.png" alt=""></p><h3 id="EM-amp-K-means"><a href="#EM-amp-K-means" class="headerlink" title="EM &amp; K-means"></a>EM &amp; K-means</h3><p><img src="/2022/10/29/AI复习总结/65.png" alt=""></p><p>A neural network with a sufficient number of neurons and a complex enough architecture can approximate any continuous function to any desired accuracy.</p><p>In Convolutional Neural Networks, different hidden units organized into the same “feature map” share weight parameters.</p><h1 id="Natural-Language-Processing"><a href="#Natural-Language-Processing" class="headerlink" title="Natural Language Processing"></a>Natural Language Processing</h1><h2 id="Context-Free-Grammars"><a href="#Context-Free-Grammars" class="headerlink" title="Context-Free Grammars"></a>Context-Free Grammars</h2><p><strong>four components</strong></p><p> A set of terminals (words)</p><p> A set N of nonterminals (phrases)</p><p> A start symbol SN</p><p> A set R of production rules</p><p> Specifies how a nonterminal can produce a string of terminals and/or nonterminals</p><p>Any arbitrary CFG can be rewritten into the Chomsky normal form (CNF), Probabilistic CFGs tend to assign larger probabilities to smaller parse trees.</p><h2 id="CFG-Chomsky-Normal-Form-，乔姆斯基规范形式"><a href="#CFG-Chomsky-Normal-Form-，乔姆斯基规范形式" class="headerlink" title="CFG(Chomsky Normal Form)，乔姆斯基规范形式"></a>CFG(Chomsky Normal Form)，乔姆斯基规范形式</h2><p>具有以下形式：</p><pre class="line-numbers language-rust"><code class="language-rust">A <span class="token punctuation">-></span> aA <span class="token punctuation">-></span> BCS <span class="token punctuation">-></span> ε<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>小写字母表示终结符号，大写表示非终结符。<br>产生式的体要么由单个终结符号或者ε构成，要么由两个非终结符构成。</p><p>题目转换只需要满足箭头后面只有两个大写单词，不会是一个或者三个，多于两个用x新增一行，只有一个向下面合并</p><p><img src="/2022/10/29/AI复习总结/57.png" alt=""></p><p>Ambiguity: A sentence is ambiguous if it has more than one possible parse tree</p><p>Probabilistic CFGs have ambiguity problem.</p><h2 id="Cocke–Younger–Kasami-Algorithm-CYK"><a href="#Cocke–Younger–Kasami-Algorithm-CYK" class="headerlink" title="Cocke–Younger–Kasami Algorithm (CYK)"></a>Cocke–Younger–Kasami Algorithm (CYK)</h2><p>Base case:</p><p> A is in cell [i-1,i] iff. there exists a rule A → wi</p><p>Recursion:</p><p> A is in cell [i,j] iff. for some rule A → B C there is a B in ell [i,k] and a C in cell [k,j] for some k.</p><p><img src="/2022/10/29/AI复习总结/58.png" alt=""><br>图示</p><p><img src="/2022/10/29/AI复习总结/59.png" alt=""></p><h2 id="Dependency-Parse"><a href="#Dependency-Parse" class="headerlink" title="Dependency Parse"></a>Dependency Parse</h2><p><img src="/2022/10/29/AI复习总结/60.png" alt=""></p><p>The links between the words represent their dependency relations </p><p>Dependency parses of sentences having the same meaning are more similar across languages than constituency parses</p><p>Parsing can be faster than CFG-bases parsers</p><h2 id="Graph-based-parsing"><a href="#Graph-based-parsing" class="headerlink" title="Graph-based parsing"></a>Graph-based parsing</h2><p>Parsing: find the highest-scoring parse tree</p><p>Taking a string and a grammar and returning one or more parse tree(s) for that string</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考有很多，不一一列举，还有很多懒得找了（&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43407273/article/details/110856123&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MCM</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="AI" scheme="http://yoursite.com/categories/CS/AI/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="人工智能" scheme="http://yoursite.com/tags/人工智能/"/>
    
  </entry>
  
  <entry>
    <title>生导C期末总结</title>
    <link href="http://yoursite.com/2022/06/17/%E7%94%9F%E5%AF%BCC%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/06/17/%E7%94%9F%E5%AF%BCC%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-18T01:42:22.000Z</published>
    <updated>2022-06-20T05:20:18.965Z</updated>
    
    <content type="html"><![CDATA[<p>主要总结一下不太会的或者忘记的部分其他部分就不写了 应试用的 </p><h1 id="Lecture3：生命的物质基础"><a href="#Lecture3：生命的物质基础" class="headerlink" title="Lecture3：生命的物质基础"></a>Lecture3：生命的物质基础</h1><h2 id="组成生物的元素"><a href="#组成生物的元素" class="headerlink" title="组成生物的元素"></a>组成生物的元素</h2><p>生物具有多样性，但生物体的元素（化学）组成基本相似主要元素：C、H、O、N、P、S、Ca等，以上7种元素约占生物体的99.35%，其中C、H、O、N 4种元素占97%。</p><p>微量元素：铁、铜、锌、锰、钼、钴、镍、镉、锡、硅、碘等。</p><p>C相互连接成链或环，形成各种生物大分子的基本骨架；</p><p>H和O存在于几乎所有的有机化合物中，构成水的元素之一；</p><p>N是蛋白质、核酸等的重要组成元素；</p><p>P是核酸、生物膜磷脂、骨骼的成分，参与细胞中能量转移反应；</p><p>S是大多数蛋白质的成分；</p><p>Ca是骨骼、牙齿等的成分，肌肉收缩、细胞信号转导、血液凝聚等必需；</p><p>K+/Na+维持体液或细胞内外正负离子平衡、神经冲动传导、肌肉收缩等；</p><p>Mg是血液及其它组织的重要成分；</p><p>Cl维持体液或细胞内外正负离子平衡；</p><p>Fe是血红蛋白的重要成分。</p><h2 id="生物大分子"><a href="#生物大分子" class="headerlink" title="生物大分子"></a>生物大分子</h2><h3 id="糖类"><a href="#糖类" class="headerlink" title="糖类"></a>糖类</h3><p>糖类（sugars），主要由C、H、O组成，又叫碳水化合物（carbohydrates），是多羟醛或多羟酮及其缩合物和某些衍生物的总称。</p><p>广泛分布于生物细胞中，如动物血液中的葡萄糖，植物细胞壁中的纤维素，谷类中的淀粉等。</p><p> 糖类是细胞重要的结构成分（如纤维素和淀粉），还参与构成核酸和糖蛋白等；是生物代谢过程的重要中间代谢物；是生命活动的主要能源。</p><p><strong>葡萄糖</strong></p><p>• 分子式C6H12O6, 6碳糖，细胞中储存能量的有机分子。</p><p>• 五碳糖和六碳糖在水溶液中成环式结构，即单糖分子中的醛基或酮基与另一个碳原</p><p>子上的羟基反应形成半缩醛或半缩酮，从而形成环式结构。</p><p><strong>果糖、半乳糖</strong></p><p>• 分子式都为C6H12O6，6碳糖，与葡萄糖分子式相同，为同分异构体。</p><p><strong>核糖、脱氧核糖</strong></p><p>• 5碳糖，第2碳上的氧原子脱去便是脱氧核糖。</p><p>• 核糖与脱氧核糖是核糖核酸（RNA）与脱氧核糖核酸（DNA）的主要成分。</p><p><strong>二糖</strong></p><p>• 最简单的寡糖。</p><p>• 两分子单糖经脱水缩合形成以糖苷键（ glycosidic linkage ）连接的二糖。</p><p>•  二糖可水解为单糖。</p><p>• 重要的二糖有麦芽糖、蔗糖和乳糖等。</p><p><strong>多糖</strong></p><p>淀粉</p><p>· 植物的糖类储存库，由α-葡萄糖通过1，4糖苷键聚合而成。</p><p>·  分为直链淀粉（没有分支，如豆类淀粉）和支链淀粉（有分支，如糯米淀粉）。</p><p>·  直链淀粉遇碘变蓝，支链淀粉遇碘变紫红色。</p><p>· 人和其它动物都能通过消化系统的淀粉酶把淀粉水解为葡萄糖。</p><p><strong>纤维素</strong></p><p>• 植物细胞壁的主要成分，保持细胞和生物体形状。</p><p>• β-葡萄糖通过1，4糖苷键聚合而成，无分支。</p><p>• 人体不含水解β-葡萄糖糖苷键的酶，因此不能消化纤维素。</p><p><strong>糖原</strong></p><p>• 动物淀粉，动物细胞储存能量，主要储存于肝脏和肌肉细胞中，与淀粉结构基本</p><p>相同，由α-葡萄糖通过1，4糖苷键聚合而成。</p><p>• 糖原支链比支链淀粉更多，但长度较短。</p><p>• 糖原遇碘变红色。</p><h3 id="脂类"><a href="#脂类" class="headerlink" title="脂类"></a>脂类</h3><p><strong>脂肪</strong></p><p>脂肪是由甘油和脂肪酸缩水结合而成的脂类，在动物称为脂肪，在植物则称为油。</p><p>· 甘油是3羟基丙醇。</p><p>·  常见脂肪酸是由12-24个碳的烃链与羧基组成的有机酸。</p><p><strong>磷脂</strong></p><p>在磷脂中，两个脂肪酸和一个磷酸基团附着在甘油上</p><p>两个脂肪酸尾部是疏水的，但磷酸基团及其附着物形成亲水头部</p><p><strong>类固醇</strong></p><p>类固醇是一种脂类，其特征是碳骨架由四个融合环组成</p><p>胆固醇是一种类固醇，是动物细胞膜的成分，也是合成其他类固醇的前体</p><p>血液中胆固醇含量过高可能导致心血管疾病</p><h3 id="蛋白质"><a href="#蛋白质" class="headerlink" title="蛋白质"></a>蛋白质</h3><p>蛋白质四级结构模型</p><p>·  一级结构又称为初级结构，指氨基酸序列。</p><p>· 二级结构指因多肽链内部分子之间的氢键而形成的α-螺旋和β-折叠，或是无规则卷曲</p><p>· 三级结构是指多肽链在二级结构的基础上再盘绕或折叠形成的三维空间形态。包含若干个α-螺旋和/或β-折叠。一般指一条肽链。</p><p> 氢键、离子键、疏水作用、范德华力、二硫键等决定了三级结构的稳定性。</p><p>·  每一个或两个肽链都可以组成蛋白的一个亚基。这种亚基相互作用形成的整个蛋白质特定的结构，即蛋白质四级结构。</p><p><img src="/2022/06/17/生导C期末总结/1.png" alt=""></p><p>一级结构（氨基酸序列）决定了三级结构</p><p> 结构决定了功能</p><p>蛋白质的功能依赖于对其它蛋白的识别和结合能力</p><h3 id="核酸"><a href="#核酸" class="headerlink" title="核酸"></a>核酸</h3><p>· DNA碱基有四种：A，T，G，C</p><p>· RNA碱基有四种：A，U，G，C</p><p><img src="/2022/06/17/生导C期末总结/2.png" alt=""></p><h1 id="Lecture4：能量与代谢"><a href="#Lecture4：能量与代谢" class="headerlink" title="Lecture4：能量与代谢"></a>Lecture4：能量与代谢</h1><p>热力学定律</p><h3 id="ATP"><a href="#ATP" class="headerlink" title="ATP"></a>ATP</h3><p>ATP尾部磷酸基团之间的键可以通过水解来打破</p><p>当末端磷酸键断裂时，ATP释放出能量</p><p>这种能量的释放来自化学变化到较低自由能状态，而不是来自磷酸盐键本身</p><p>ATP通过磷酸化驱动去能反应，</p><p>将磷酸基团转移到其他分子上，如反应物</p><p>•受体分子现在被称为磷酸化中间体</p><h2 id="酶"><a href="#酶" class="headerlink" title="酶"></a>酶</h2><h3 id="酶催化原理"><a href="#酶催化原理" class="headerlink" title="酶催化原理"></a>酶催化原理</h3><p>正确定位底物</p><p>应变基底键</p><p>提供有利的</p><p>微环境</p><p>共价键合到底物</p><h3 id="辅助因子"><a href="#辅助因子" class="headerlink" title="辅助因子"></a>辅助因子</h3><p>金属离子和辅酶</p><p>金属离子的作用主要是以下几方面:</p><p>(1）作为酶活性中心的催化基团参与催化反应、传递电子</p><p>(2）作为连接酶与底物的桥梁</p><p>(3）稳定酶的构象</p><p>(4）中和阴离子，降低反应中的静电斥力</p><p>多数氧化还原酶类的辅酶是具有核苷酸结构的维生素，如NAD+（烟酰胺腺嘌呤二核苷酸，辅酶I)，NADP+（烟酰胺腺嘌呤二核苷磷酸，辅酶Ⅱ)，FAD（黄素腺嘌呤二核苷酸）等，可以转移H和电子，在细胞呼吸过程中发挥了很大作用;如辅酶A，转移酰基的作用。</p><p>绝大多数维生素参与形成辅酶。</p><h2 id="细胞呼吸"><a href="#细胞呼吸" class="headerlink" title="细胞呼吸"></a>细胞呼吸</h2><ul><li>糖酵解</li></ul><p><img src="/2022/06/17/生导C期末总结/3.png" alt=""></p><ul><li>柠檬酸循环</li></ul><p><img src="/2022/06/17/生导C期末总结/4.png" alt=""></p><p>• 柠檬酸循环，也称为Krebs循环，完成丙酮酸分解为$CO_2$</p><p>• 该循环氧化丙酮酸衍生的有机燃料，每转产生1个ATP、3个NADH和1个$FADH_2$</p><ul><li>氧化磷酸化</li></ul><p><img src="/2022/06/17/生导C期末总结/5.png" alt=""></p><p>ATP产生原理：糖酵解，柠檬酸循环，氧化磷酸化</p><h2 id="有氧呼吸和厌氧发酵"><a href="#有氧呼吸和厌氧发酵" class="headerlink" title="有氧呼吸和厌氧发酵"></a>有氧呼吸和厌氧发酵</h2><p>有氧条件和缺氧条件下，葡萄糖等“食物分子”在生物细胞中产生能量的情况是不一样的。<br>有氧条件下，酵母细胞可以消耗氧气来分解葡萄糖并获得能量，同时产生二氧化碳。<br>缺氧条件下，酵母菌将葡萄汁中的葡萄糖分解成乙醇和二氧化碳。</p><ul><li><p>乙醇发酵<br>丙酮酸被转化为$CO_2$,和乙醇;这个过程中重新生成了NAD+ ,从而保证了酵解的继续进行;用于酿酒。</p></li><li><p>乳酸发酵<br>丙酮酸被发酵为乳酸;<br>这个过程中也重新生成了NAD+，保证了酵解的继续进行;<br>乳酸发酵被用于制作奶酪和酸奶。</p></li></ul><h1 id="Lecture5：细胞的亚结构和功能"><a href="#Lecture5：细胞的亚结构和功能" class="headerlink" title="Lecture5：细胞的亚结构和功能"></a>Lecture5：细胞的亚结构和功能</h1><h2 id="原核细胞与真核细胞"><a href="#原核细胞与真核细胞" class="headerlink" title="原核细胞与真核细胞"></a>原核细胞与真核细胞</h2><ul><li><p>按照结构的复杂程度及进化顺序，细胞可以分为两类，原核细胞和真核细胞。</p></li><li><p>原核细胞没有真正的细胞核，遗传信息较少，DNA通常分布于一定区域，称为核区或拟核。原核细胞内部结构简单，没有以膜为基础的具有特定结构与功能的细胞器。</p></li><li><p>原核生物一般是单细胞生物,主要包括细菌和蓝藻等。</p></li><li><p>原核生物细胞外层是双层脂类构成的质膜（细胞膜)，质膜内所有细胞内容物为原生质。</p></li></ul><h2 id="细胞核"><a href="#细胞核" class="headerlink" title="细胞核"></a>细胞核</h2><ul><li><p>含有主要遗传物质，是细胞的信息中心。</p></li><li><p>一般有一个细胞核，但部分肝细胞、心肌细胞等有2个或多个细胞核</p></li><li><p>成熟的红细胞没有细胞核。<br>包括核膜，核纤层，核基质，染色质和核仁等部分。</p></li><li><p>核纤层是核膜下方的纤维网络，对核膜有支持作用。</p></li><li><p>染色质是细胞核中由DNA和蛋白质组成并可以被苏木精等染色的物质。在细胞准备分裂时，线性缠绕的染色质凝缩成显微镜下可以辨认的染色体。</p></li><li><p>核仁是细胞核中的纤维和颗粒状结构，富含蛋白质和RNA。是核糖体亚单位发生的场所。核糖体亚单位通过核孔进入细胞质中再组装成核糖体。</p></li></ul><h2 id="内质网"><a href="#内质网" class="headerlink" title="内质网"></a>内质网</h2><p>粗面内质网多呈扁囊状，排列较整齐，膜表面分布有大量的核糖体。是分泌性蛋白、溶酶体蛋白和膜蛋白合成、加工、分选的场所。<br>滑面型内质网的膜表面没有核糖体。是脂类合成的重要场所，某些疏水化合物的解毒场所。  </p><p><strong>粗糙型内质网作用</strong></p><p>粗糙型内质网的功能：是合成蛋白质大分子，并把它从细胞输送出去或在细胞内转运到其他部位。凡蛋白质合成旺盛的细胞，粗糙型内质网便发达。在神经细胞中，粗糙型内质网的发达与记忆有关。<br><strong>光滑型内质网作用：</strong><br>光滑型内质网的功能:与糖类和脂类的合成、解毒、同化作用有关，并且还具有运输蛋白质的功能。</p><h2 id="过氧化物酶体"><a href="#过氧化物酶体" class="headerlink" title="过氧化物酶体"></a>过氧化物酶体</h2><ul><li><p>单层膜结构</p></li><li><p>含有脱氢酶，可以将H+转移给$O_2$，形成$H_2O_2$<br>功能较多，通过转移H+分解脂肪酸，解酒，解毒等</p></li></ul><h2 id="膜蛋白"><a href="#膜蛋白" class="headerlink" title="膜蛋白"></a>膜蛋白</h2><p>蛋白质决定了膜的大部分特定功能</p><p>•外周蛋白与膜表面结合</p><p>•完整蛋白质穿透疏水核心</p><p>•跨膜的完整蛋白质称为跨膜蛋白质</p><p><strong>膜蛋白的主要功能</strong></p><p>•运输</p><p>•酶活性</p><p>•信号转导</p><p>•细胞识别</p><p>•细胞间连接</p><p>•附着于细胞骨架和细胞外基质（ECM）</p><p><strong>跨膜运输方式</strong><br>可以归纳为两类，一类为被动运输(passive transport)，另一类为主动运输(active transport)。<br>简单扩散是被动运输的一种主要方式，不需要能量，从高浓度一侧向低浓度一侧运动，直至两侧浓度相同。相对分子量小或脂溶性强的物质，如氧，经，乙醇，水等。<br>水的简单扩散又称为渗透作用(osmosis)，可影响活细胞内外水的平衡并影响细胞的存活。<br>易化扩散是被动运输的另一种方式，指在跨膜蛋白的帮助下，一些非脂溶性物质或亲水物质，如氨基酸、某些糖和金属离子等，顺浓度梯度或电化学梯度不消耗能量进入细胞内。</p><p><img src="/2022/06/17/生导C期末总结/6.png" alt=""></p><p>包括细胞膜和细胞内膜</p><ul><li><p>信息处理</p></li><li><p>能量转化</p></li><li><p>化学反应的组织与控制</p></li><li><p>发生电化学变化</p></li></ul><h1 id="Lecture6：细胞分裂和分化"><a href="#Lecture6：细胞分裂和分化" class="headerlink" title="Lecture6：细胞分裂和分化"></a>Lecture6：细胞分裂和分化</h1><h2 id="细胞分裂"><a href="#细胞分裂" class="headerlink" title="细胞分裂"></a>细胞分裂</h2><h3 id="体细胞分裂"><a href="#体细胞分裂" class="headerlink" title="体细胞分裂"></a>体细胞分裂</h3><p>Mitosis(有丝分裂）, the division of the genetic material in the </p><p>Cytokinesis(胞质分裂）, the division of the cytoplasm<br>有分裂能力的细胞，从一次分裂结束到下一次分裂结束所经历的一个完整过程叫细胞周期(cell cycle)</p><p><strong>有丝分裂：</strong></p><p><img src="/2022/06/17/生导C期末总结/7.png" alt=""></p><p><strong>减数分裂：</strong></p><p><img src="/2022/06/17/生导C期末总结/8.png" alt=""></p><p><strong>胞质分裂：</strong></p><p><img src="/2022/06/17/生导C期末总结/9.png" alt=""></p><p><strong>细胞周期的调控：</strong></p><p>对于许多细胞来说，G1检查点似乎是最重要的</p><p>如果一个单元在G1检查点接收到前进信号，它通常会完成S、G2和M阶段，并且</p><p>分</p><p>如果电池没有收到goahead信号，它将退出循环，切换到称为G0相的非分裂状态</p><p><strong>细胞周期调控因子：</strong></p><p>涉及两种调节蛋白</p><p>细胞周期蛋白和细胞周期蛋白依赖激酶（CDK）</p><p>影响细胞分裂的外部因素包括特定的生长因子</p><p>某些细胞释放生长因子并刺激其他细胞分裂</p><p>血小板衍生生长因子（PDGF）由称为血小板的血细胞碎片制成</p><ul><li><p>在密度依赖性抑制中，拥挤的细胞将停止分裂</p></li><li><p>密度依赖性抑制和锚定</p></li></ul><p>依赖性检查细胞在最佳密度下的生长</p><ul><li>癌细胞的分裂既不受任何类型的调节</li></ul><p><img src="/2022/06/17/生导C期末总结/10.png" alt=""></p><h3 id="细胞分化："><a href="#细胞分化：" class="headerlink" title="细胞分化："></a>细胞分化：</h3><p>(1）细胞分化起始于基因表达（关闭或打开)和基因表达强度的调控;</p><p>(2)分化细胞之间的差异在于不同蛋白质的表达;<br>(3）分化过程主要在成年阶段以前进行，但仍有少部分细胞（如哺乳动物骨髓中的血细胞)的分化持续终生。</p><p>细胞的分化潜能<br>全能性:能够使后代细胞分化出各种组织细胞并发育成个体，如受精卵<br>多能性:能够使后代细胞分化出各种组织细胞但不能发育成个体，如生血干细胞<br>单能性:只能分化形成一种后代细胞，如单能生血细胞</p><h1 id="Lecture7：动物的结构和功能"><a href="#Lecture7：动物的结构和功能" class="headerlink" title="Lecture7：动物的结构和功能"></a>Lecture7：动物的结构和功能</h1><h2 id="动物组织"><a href="#动物组织" class="headerlink" title="动物组织"></a>动物组织</h2><h3 id="上皮组织"><a href="#上皮组织" class="headerlink" title="上皮组织"></a>上皮组织</h3><p>动物具有其特殊的组织，组织是构成器官的基本结构分为:上皮组织、结缔组织、肌肉组织、神经组织</p><p>上皮组织是指覆盖身体表面和体内器官内表面的一层或多层紧密排列的细胞。</p><p>皮肤、肺、肾小管、消化道<br>上皮组织具有保护、分泌、排泄和吸收等功能，分布在动物体不同部位的上皮，其功能各不相同。<br>单层上皮、复层上皮</p><h3 id="结缔组织"><a href="#结缔组织" class="headerlink" title="结缔组织"></a>结缔组织</h3><p>结缔组织由基质及分散其中的细胞构成<br>具有连接、支持、保护、防御、修复和运输等功能。</p><p>疏松结缔组织:大多分布在上皮组织下</p><p>血液<br>脂肪组织<br>致密结缔组织:纤维状结缔组织，软骨组织，骨骼</p><h3 id="肌肉组织"><a href="#肌肉组织" class="headerlink" title="肌肉组织"></a>肌肉组织</h3><p>肌肉组织由成束的具收缩能力的长形肌纤维（肌细胞）构成，是脊椎动物体内最丰<br>富的组织。<br>维持机体和器官的运动。<br>包括骨骼肌、心肌和平滑肌三种类型。</p><h3 id="神经组织"><a href="#神经组织" class="headerlink" title="神经组织"></a>神经组织</h3><p>神经组织是动物体内分化程度较高的一种组织。<br>神经组织由神经元(传递神经冲动)和神经胶质细胞（支持）构成。<br>每个神经元都含有细胞体（含细胞核)和数条长短不等的突起(树突、轴突）。<br>细长的神经轴突和树突又称为神经纤维。神经纤维的末端很细，并终止于器官组织内，成为神经末梢。感觉神经末梢和运动神经末梢分别具有感受器和效应器的作用。</p><h2 id="器官与系统"><a href="#器官与系统" class="headerlink" title="器官与系统"></a>器官与系统</h2><h3 id="消化系统"><a href="#消化系统" class="headerlink" title="消化系统"></a>消化系统</h3><p>人体的消化系统由消化道和消化腺组成。<br>消化道的主要部分是口、舌、咽、食通、肖、小肠、大肠和肛门。<br>消化腺包括唾液腺、胰腺和肝脏。</p><h3 id="血糖调节"><a href="#血糖调节" class="headerlink" title="血糖调节"></a>血糖调节</h3><p>胰岛素和胰高血糖素调节糖原的储存和分解为葡萄糖</p><p>肝脏是葡萄糖的场所</p><p>体内稳态</p><p>富含碳水化合物的膳食会提高胰岛素水平，从而触发糖原的合成</p><p>低血糖导致胰高血糖素刺激糖原分解并释放葡萄糖</p><h3 id="排泄系统"><a href="#排泄系统" class="headerlink" title="排泄系统"></a>排泄系统</h3><p>肾脏是生成尿的器官，能将含氮的代谢终产物从血液中清除。这些代谢废物以尿的形式从输尿管进入膀胱暂时贮存，最后通过尿道排出体外。<br>排泄系统对于维持机体的水盐平衡、氮的排出、保持内环境稳定具有重要作用。</p><h3 id="循环系统"><a href="#循环系统" class="headerlink" title="循环系统"></a>循环系统</h3><p>循环系统指心血管系统，由心脏、血管和血液组成，其主要功能是物质运输。<br>血液为细胞输送营养和氧气，同时还将CO,运输到肺，将其他代谢终产物从身体各部位运输到排泄器官。</p><h3 id="呼吸系统"><a href="#呼吸系统" class="headerlink" title="呼吸系统"></a>呼吸系统</h3><p>呼吸系统是人体与外界环境进行气体交换的场所。<br>为血液提供氧气，同时排出细胞新陈代谢的终产物COz。</p><h3 id="淋巴和免疫系统"><a href="#淋巴和免疫系统" class="headerlink" title="淋巴和免疫系统"></a>淋巴和免疫系统</h3><p>淋巴系统和免疫系统紧密合作，共用一些结构。<br>淋巴系统是由淋巴管构成的网状结构，淋巴管与淋巴结相连接。淋巴系统是循环系统的辅助和补充。<br>淋巴结含有大量的白细胞，包括淋巴细胞、单核细胞、粒细胞。白细胞是免疫系统的组成部分。<br>脾脏是人体最大的免疫器官，含有大量白细胞。</p><h3 id="内分泌系统"><a href="#内分泌系统" class="headerlink" title="内分泌系统"></a>内分泌系统</h3><p>产生激素的器官叫内分泌腺，作为一个整体，它们构成了内分泌系统。<br>内分泌系统影响特定的生理活动，调节诸如消化、生长、生殖、心率和水盐平衡以及各种新陈代谢活动等。</p><h3 id="神经系统"><a href="#神经系统" class="headerlink" title="神经系统"></a>神经系统</h3><p>人的神经系统包括中枢神经系统和周围神经系统两部分。<br>中枢神经系统主要包括脑和脊髓，脑包括大脑、小脑、间脑、中脑、脑桥和延髓。周围神经系统主要由12对脑神经和31对脊神经组成。</p><h3 id="生殖系统"><a href="#生殖系统" class="headerlink" title="生殖系统"></a>生殖系统</h3><p>生殖系统由生殖腺（卵巢和睾丸）、输精管或输卵管、附属腺体和外生殖器四部分组成。<br>主要功能是产生生殖细胞，繁殖后代，延续种族。<br>生殖器官还具有内分泌功能，可产生激素，调节发育。</p><h3 id="肌肉系统"><a href="#肌肉系统" class="headerlink" title="肌肉系统"></a>肌肉系统</h3><p>肌肉系统由身体中所有的骨骼肌构成，骨骼肌与坚硬的骨骼或者软骨结构相连，带动身体的某些部分运动。<br>肌肉系统使我们得以随意运动，对周围环境作出灵活的反应，并可以改变面部的表情。</p><h2 id="动物结构和功能的适应性"><a href="#动物结构和功能的适应性" class="headerlink" title="动物结构和功能的适应性"></a>动物结构和功能的适应性</h2><p>1.结构和功能的适应性保证了动物与环境之间的化学交换</p><p>2.结构和功能的适应保证了较高的工作效率</p><p>3.结构和功能的适应维持了内环境的相对稳定</p><h2 id="稳态"><a href="#稳态" class="headerlink" title="稳态"></a>稳态</h2><p>生物体利用内环境平衡来维持稳定状态或内部平衡，无论外部环境如何</p><p>人类的体温、血液pH值和葡萄糖浓度都保持在恒定水平</p><p>正反馈和负反馈调节</p><h1 id="Lecture8：遗传学定律、基因复制与表达"><a href="#Lecture8：遗传学定律、基因复制与表达" class="headerlink" title="Lecture8：遗传学定律、基因复制与表达"></a>Lecture8：遗传学定律、基因复制与表达</h1><h2 id="遗传定律"><a href="#遗传定律" class="headerlink" title="遗传定律"></a>遗传定律</h2><ul><li><p>孟德尔遗传定律</p></li><li><p>杂交实验</p></li><li><p>分离定律</p></li><li><p>自由组合定律：非等位基因自由组合</p></li><li><p>伴性遗传</p></li></ul><h2 id="DNA复制"><a href="#DNA复制" class="headerlink" title="DNA复制"></a>DNA复制</h2><p>半保留复制:<br>watson J.D.等提出的DNA半保留复制方式。其方法为:<br>①.一端沿氢键逐渐断开﹔②.以单链为模板，碱基互补﹔③．氢键结合，聚合酶等连接﹔4.形成新的互补链﹔⑤.形成了两个新DNA分子。</p><p>DNA的这种复制方式对保持生物遗传的稳定性是非常重要的。</p><p>在每个复制泡的末端是一个复制叉，一个Y形区域，新的DNA链在这里伸长</p><p>拓扑异构酶纠正复制分叉之前的“过度缠绕”</p><p>螺旋酶是解开双螺旋的酶</p><p>单链结合蛋白结合并稳定单链DNA</p><p><img src="/2022/06/17/生导C期末总结/11.png" alt=""></p><h3 id="DNA复制过程"><a href="#DNA复制过程" class="headerlink" title="DNA复制过程"></a>DNA复制过程</h3><p>1.DNA双螺旋的解链</p><ul><li><p>DNA解旋酶在ATP供能下，每分钟旋转300o次解开双螺旋;</p></li><li><p>单链DNA结合蛋白马上结合在分开的单链上，以避免产生单链内配对;</p></li><li><p>DNA拓扑异构酶来解决由于复制叉的推进而产生超螺旋的问题。</p></li></ul><p>2.DNA合成的开始</p><p>合成DNA片段之前，先由RNA聚合酶合成一小段RNA引物(约有10个碱基对)→DNA聚合酶才开始起作用合成DNA片段。</p><p><img src="/2022/06/17/生导C期末总结/12.png" alt=""></p><p>3.后随链的不连续复制</p><p>∵DNA聚合酶，以5’→3’方向发挥作用;</p><p>∴从3’→5’合成方向的一条链，就会遇到困难。<br>考恩伯格( Kornberg A.,1967)提出不连续</p><p>复制假说:<br>在3’→5’方向链上，仍按从5’→3’的方向一段段地合成DNA单链小片段“冈崎片段”(1000~2000bp)→由连接酶连接这些片段→形成一条连续的单链。</p><h2 id="转录"><a href="#转录" class="headerlink" title="转录"></a>转录</h2><p>RNA，核糖核酸，与DNA差别在于:<br>RNA大多是单链;含核糖而不是脱氧核糖;4种核苷酸A、U、G、C<br><strong>细胞中主要有三种RNA分子:</strong><br>信使RNA (mRNA)<br>转运RNA (tRNA)核糖体RNA (rRNA)</p><ol><li><strong>前体mRNA到成熟mRNA:加帽子和加尾巴</strong><br>·在真核生物细胞核中，DNA链上具有不能编码蛋白质的核苷酸片段即内含子(intron）和编码蛋白质的核苷酸片段即外显子(exon) 。<br>·在真核生物中，转录后新合成的mRNA是未成熟的，称为前体mRNA (pre-mRNA)<br>pre-mRNA5’端加“帽子”(5’ -Cap)，3’端加“尾巴”(poly A tail)，和去除内含子变为成熟mRNA</li></ol><p><img src="/2022/06/17/生导C期末总结/15.png" alt=""></p><ol start="2"><li><strong>前体mRNA到成熟mRNA:内含子的切除</strong><br>·在真核生物细胞核中，DNA链上具有不能编码蛋白质的核昔酸片段即内含子(intron）和编码蛋白质的核苷酸片段即外显子( exon) 。<br>·在真核生物中，转录后新合成的mRNA是未成熟的，称为前体mRAN (pre-mRNA)<br>pre-mRNA5’端加“帽子”(5’ -Cap) ，3’端加“尾巴”(poly A tail)，和去除内含子变为成熟mRNA</li></ol><p><img src="/2022/06/17/生导C期末总结/14.png" alt=""></p><h2 id="遗传密码"><a href="#遗传密码" class="headerlink" title="遗传密码"></a>遗传密码</h2><p><strong>遗传密码的基本特征:</strong><br>1.遗传密码为三联体:</p><p>三个碱基决定一种氨基酸;<br>61个为有意密码，起始密码为GUG（缬氨酸)、AUG(甲硫氨酸);<br>3个为无意密码，UAA、UAG、UGA为蛋白质合成终止信号。<br>2.遗传密码间不能重复:<br>在一个mRNA上每个碱基只属于一个密码子;均以3个一组形成氨基酸密码。</p><p>3.遗传密码间无逗号∶<br>密码子与密码子之间无逗号，按三个三个的顺序一直阅读下去。<br>如果中间某个碱基增加或缺失后，阅读就会按新的顺序进行下去，最终形成的多肽链就与原先的完全不一样(称为移码突变)。</p><p>4．简并性:</p><p>①简并现象:<br>色氨酸(UGG)和甲硫氨酸(AUG)例外，仅一个三联体密码;其余氨基酸都有一种以上的密码子。<br>②简并现象的意义:<br>同义的密码子越多，生物遗传的稳定性也越大。如: UCU-→&gt;UCC或UCA或UCG，均为丝氨酸。</p><p>5．遗传密码的有序性:<br>决定同一个氨基酸或性质相近的不同氨基酸的多个密码子中，第1个和第2个碱基的重要性大于第3个碱基，往往只是最后一个碱基发生变化。<br>例如:脯氨酸(pro） : CCU、CCA、CCC、CCG。</p><p>6.通用性:<br>①在整个生物界中，从病毒到人类，遗传密码通用。<br>4个基本碱基符号→所有氨基酸→所有蛋白质→生物种类、生物体性状。<br>1980年以后发现:<br>具有自我复制能力的线粒体tRNA(转移核糖核酸)在阅读个别密码子时有不同的翻译方式。<br>如:酵母、链孢霉与哺乳动物的线粒体。</p><h1 id="Lecture9：遗传学与表观遗传学"><a href="#Lecture9：遗传学与表观遗传学" class="headerlink" title="Lecture9：遗传学与表观遗传学"></a>Lecture9：遗传学与表观遗传学</h1><h2 id="基因表达的调控"><a href="#基因表达的调控" class="headerlink" title="基因表达的调控"></a>基因表达的调控</h2><ul><li><p>在真核生物中，特定基因的高水平转录依赖于与特定转录因子相互作用的控制元件</p></li><li><p>远端控制元件，其分组称为增强子，可能远离基因，甚至位于内含子中</p></li><li><p>近端控制元件位于启动子附近</p></li></ul><p><img src="/2022/06/17/生导C期末总结/16.png" alt=""></p><p>激活剂是一种与增强子结合并刺激基因转录的蛋白质</p><p>激活剂有两个域，一个结合DNA，另一个激活转录</p><p>结合激活剂促进蛋白质-蛋白质序列导致特定基因转录的相互作用</p><h2 id="mRNA降解"><a href="#mRNA降解" class="headerlink" title="mRNA降解"></a>mRNA降解</h2><ul><li><p>依赖于脱腺苷酸化的mRNA降解</p></li><li><p>不依赖于脱腺苷酸化的mRNA降解</p></li><li><p>核酸内切酶介导的mRNA降解‘</p></li></ul><h2 id="蛋白质降解"><a href="#蛋白质降解" class="headerlink" title="蛋白质降解"></a>蛋白质降解</h2><ul><li><p>自噬</p></li><li><p>泛素-蛋白酶体系统</p></li></ul><p>泛素化:泛素(一类低分子量的蛋白质）分子在一系列特殊的酶作用下，对靶蛋白进行特异性修饰的过程</p><h2 id="表观遗传"><a href="#表观遗传" class="headerlink" title="表观遗传"></a>表观遗传</h2><p>表观遗传是指在没有DNA序列变化的基础上，基因表达时发生的可遗传的改变，最终导致表型的改变。<br>表观遗传学是研究基因组DNA序列未发生变化、而基因表达及基因功能的诱导和维持却发生可遗传变化的科学。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>可遗传的，即这类改变通过有丝分裂或减数分裂，能在细胞或个体世代间遗传</p></li><li><p>可逆性的基因表达调节</p></li><li><p>没有DNA序列的改变或不能用DNA序列变化来解释</p></li></ul><p>决定细胞类型（表型)的不是基因本身，而是基因表达模式，通过细胞分裂来传递和稳定地维持具有组织和细胞特异性的基因表达模式对于整个机体的结构和功能协调是至关重要的。基因表达模式有表观遗传修饰决定。</p><h4 id="表观遗传修饰"><a href="#表观遗传修饰" class="headerlink" title="表观遗传修饰"></a>表观遗传修饰</h4><p><img src="/2022/06/17/生导C期末总结/17.png" alt=""></p><h4 id="DNA甲基化"><a href="#DNA甲基化" class="headerlink" title="DNA甲基化"></a>DNA甲基化</h4><ul><li><p>DNA甲基化(DNA methylation)是最早被发现，研究最清楚的重要表观遗传修饰形式，主要是基因组DNA上的胞喀啶第5位碳原子和甲基间的共价结合，胞傕啶由此被修饰为5甲基胞喀啶(5-methylcytosine，5mC)。</p></li><li><p>在基因的5’端调控区域,CpG二连核苷常常以成簇串联形式排列，这种富含CpG二连核苷的区域称为CpG岛(CpG islands)，其大小为500-1000bp，约56%的编码基因含该结构。</p></li><li><p>基因调控元件所含CpG岛中的5mC会阻碍转录因子复合体与DNA的结合<br>·DNA甲基化一般与基因沉默相关联;<br>·非甲基化一般与基因的活化相关联;<br>·而去甲基化往往与一个沉默基因的重新激活相关联。</p></li></ul><h4 id="组蛋白修饰"><a href="#组蛋白修饰" class="headerlink" title="组蛋白修饰"></a>组蛋白修饰</h4><ul><li><p>组蛋白修饰是表观遗传研究的重要内容。</p></li><li><p>组蛋白的N端是不稳定的，其延伸至核小体以外，会受到不同的化学修饰，与基因的表达调控密切相关。</p></li></ul><h4 id="染色质重塑"><a href="#染色质重塑" class="headerlink" title="染色质重塑"></a>染色质重塑</h4><ul><li><p>染色质重塑(chromatin remodeling）是一个重要的表观遗传学机制。</p></li><li><p>染色质重塑是由染色质重塑复合物介导的一系列以染色质上核小体变化为基本特征的生物学过程。</p></li></ul><h5 id="RNA重塑"><a href="#RNA重塑" class="headerlink" title="RNA重塑"></a>RNA重塑</h5><ul><li><p>只有一小部分DNA编码蛋白质，而一小部分非蛋白质编码DNA由RNA基因组成，如rRNA和tRNA</p></li><li><p>大量基因组可能转录成非编码RNA（ncRNAs）</p></li><li><p>非编码RNA在两个点调节基因表达：mRNA翻译和染色质配置</p></li></ul><p>除DNA甲基化、组蛋白修饰、染色质重塑、和RNA调控以外，还有X染色体失活、遗传印迹等。<br>X染色体失活、遗传印迹的本质仍为DNA甲基化、组蛋白修饰、染色质重塑、RNA调控。</p><h3 id="遗传印记"><a href="#遗传印记" class="headerlink" title="遗传印记"></a>遗传印记</h3><p>概念:<br>●或称亲本印迹(parent imprinting），是指基因组在传递遗传信息的过程中，通过基因组的化学修饰(DNA甲基化;组蛋白的甲基化、乙酰化、磷酸化、泛素化等修饰）而使基因或DNA片段被标识的过程。<br>特点:<br>●基因组印迹依靠单亲传递某种性状的遗传信息，被印迹的基因会随着其来自父源或母源而表现不同，即源自双亲的两个等位基因中一个不表达或表达很弱。<br>●不遵循孟德尔定律，是一种典型的非孟德尔遗传，正反交结果不同。</p><h1 id="Lecture10：发育-从单细胞到个体"><a href="#Lecture10：发育-从单细胞到个体" class="headerlink" title="Lecture10：发育-从单细胞到个体"></a>Lecture10：发育-从单细胞到个体</h1><h2 id="受精过程"><a href="#受精过程" class="headerlink" title="受精过程"></a>受精过程</h2><p>受精之后是分裂，这是一个细胞快速分裂而不生长的时期</p><h2 id="Cleavage-卵裂"><a href="#Cleavage-卵裂" class="headerlink" title="Cleavage(卵裂)"></a>Cleavage(卵裂)</h2><p>从一个细胞分开形成多个细胞，成为卵裂球( blastomeres )</p><ul><li><p><strong>全母细胞解理(完全卵裂)</strong>,卵子的完全分裂发生在蛋黄含量很少或中等的物种中，如海胆和青蛙(卵黄少的，例如海胆和青蛙)</p></li><li><p><strong>多晶分裂(不完全卵裂)</strong>，卵子分裂不完全，发生在卵黄丰富的物种中，如爬行动物和鸟类(卵黄多的，例如蛇和鸟)</p></li></ul><p><img src="/2022/06/17/生导C期末总结/18.png" alt=""></p><p>最初的发育是由卵子发生过程中沉积在卵子中的RNA和蛋白质进行的</p><p>卵裂后，卵细胞质在许多卵裂球之间分裂，每个卵裂球都能产生足够的RNA来规划细胞的代谢和进一步发育</p><p><strong>动物的形态发生涉及细胞形状、位置和存活率的特定变化</strong></p><p>分裂后，细胞分裂速度减慢，细胞周期恢复正常</p><p>形态发生是细胞占据其适当位置的过程，包括原肠胚形成，细胞从囊胚表面向胚胎内部的运动</p><p>器官发生，器官的形成</p><h2 id="原肠胚形成"><a href="#原肠胚形成" class="headerlink" title="原肠胚形成"></a>原肠胚形成</h2><p><img src="/2022/06/17/生导C期末总结/19.png" alt=""></p><p><img src="/2022/06/17/生导C期末总结/20.png" alt=""></p><h2 id="器官建立"><a href="#器官建立" class="headerlink" title="器官建立"></a>器官建立</h2><p>器官形成时细胞的迁移<br>·细胞的长大<br>细胞的移动<br>·细胞的分裂和延展<br>·细胞的死亡</p><p>动物而非植物的形态发生涉及细胞的运动</p><p>•在动物中，细胞各部分的运动可导致细胞形状改变，或使细胞迁移到新的位置</p><p>•细胞骨架的微管和微丝对这些事件至关重要</p><p>在这两种适应过程中，胚胎都被羊膜囊中的液体包围</p><p>•这可以保护胚胎免受干燥，并允许在旱地繁殖</p><p>•哺乳动物和爬行动物（包括鸟类）因此被称为羊膜动物</p><h2 id="细胞凋亡"><a href="#细胞凋亡" class="headerlink" title="细胞凋亡"></a>细胞凋亡</h2><p>程序性细胞死亡也称为凋亡</p><p>在发育过程中的不同时间，单个细胞、一组细胞或整个组织停止发育，并被相邻细胞吞噬</p><p>例如，在发育中的胚胎中产生的神经元数量远远超过所需数量</p><p>通过凋亡去除额外的神经元</p><h2 id="细胞命运决定"><a href="#细胞命运决定" class="headerlink" title="细胞命运决定"></a>细胞命运决定</h2><p>细胞命运决定是一个术语，用于描述一个细胞或一组细胞致力于某一特定领域的过程</p><p>细胞分化 分化是指结构和功能上的结果专门化</p><p>命运图是显示器官和其他结构的图表，这些器官和结构起源于</p><p>胚</p><p>利用青蛙进行的经典研究表明，生殖层中的细胞谱系可追溯到囊胚细胞</p><h2 id="体轴"><a href="#体轴" class="headerlink" title="体轴"></a>体轴</h2><p>在一系列动物身上都可以找到双侧对称的体型图</p><p>该身体平面图显示了背腹轴和前后轴的不对称性</p><p>左右轴基本对称</p><p><img src="/2022/06/17/生导C期末总结/21.png" alt=""></p><h2 id="细胞全能性"><a href="#细胞全能性" class="headerlink" title="细胞全能性"></a>细胞全能性</h2><p>在哺乳动物中，发育的全能性保持到8细胞期<br>发育过程中渐进性的限制增加是动物发育过程中的基本特性Progressive restriction of developmental potential is ageneral feature of development in all animals<br>组织特异性细胞命运决定在后原肠胚期形成。</p><p>细胞的命运决定受到组织信号的调节</p><p>纤毛影响组织命运决定</p><h3 id="现代生物技术"><a href="#现代生物技术" class="headerlink" title="现代生物技术"></a>现代生物技术</h3><p>基因克隆</p><p>基因治疗</p><h1 id="Lecture11：神经系统与智能"><a href="#Lecture11：神经系统与智能" class="headerlink" title="Lecture11：神经系统与智能"></a>Lecture11：神经系统与智能</h1><h2 id="大脑中的化学The-chemical-brain"><a href="#大脑中的化学The-chemical-brain" class="headerlink" title="大脑中的化学The chemical brain"></a>大脑中的化学The chemical brain</h2><p>神经元用小分子物质相互通讯</p><p>神经递质：乙酰胆碱，去甲肾上腺素NA和乙酰胆碱ACh</p><p>脑内主要抑制性递质：GABA</p><p>兴奋性神经递质：Glutamate and NO</p><p><strong>Neuropeptides 神经肽:内源性阿片肽</strong></p><p>鸦片的活性成分 Morphine(1806，德国Friedrich Sertürner),有多种作用镇痛作用的位点：<br>阿司匹林作用于外周<br>吗啡作用于中枢</p><p><strong>神经肽作为神经递质</strong></p><p>与小分子不同神经肽在细胞体合成通过长距离运输,在突触释放，调节性作用的关键元件</p><h2 id="大脑中的电信号The-electrical-brain"><a href="#大脑中的电信号The-electrical-brain" class="headerlink" title="大脑中的电信号The electrical brain"></a>大脑中的电信号The electrical brain</h2><p>大脑用电信号传递信息</p><ol><li>Single neuron: Action potential神经元活动</li><li>Group of neurons: local field potential (LFP), EEG “脑电信号”</li></ol><p>动作电位和离子泵：直接突触传递涉及神经递质与突触后细胞中配体门控离子通道的结合神经递质结合导致离子通道开放，产生突触后电位</p><p><strong>信息的传递 通过突触进行</strong></p><p>突触后电位分为两类</p><ul><li>兴奋性后膜电位</li></ul><p>兴奋性突触后电位（EPSP）是使膜电位接近阈值的去极化</p><ul><li>抑制性后膜电位</li></ul><p>抑制性突触后电位（IPSP）是使膜电位远离阈值的超极化</p><p><img src="/2022/06/17/生导C期末总结/22.png" alt=""></p><p>神经可塑性主要反映在突触</p><p>神经可塑性：通过改变突触和神经元兴奋性，加工得到学习获得的能力</p><h2 id="“自我”与外部世界的映射The-reflection-of-the-external-world"><a href="#“自我”与外部世界的映射The-reflection-of-the-external-world" class="headerlink" title="“自我”与外部世界的映射The reflection of the external world"></a>“自我”与外部世界的映射The reflection of the external world</h2><p>Brain signals construct the reaction to the external world</p><h2 id="大脑的“路线”如何计算The-wiring-map-of-the-brain"><a href="#大脑的“路线”如何计算The-wiring-map-of-the-brain" class="headerlink" title="大脑的“路线”如何计算The wiring map of the brain"></a>大脑的“路线”如何计算The wiring map of the brain</h2><h3 id="大脑运行的特征"><a href="#大脑运行的特征" class="headerlink" title="大脑运行的特征"></a>大脑运行的特征</h3><p>I. 局部化分工 （The hieratical structure Specialized functional<br>regions Connections and intelligence）<br>II. 阶层型结构（The hieratical structure）<br>III. 环型结构（loop structure）<br>IV. 脑状态的动态切换]</p><p><img src="/2022/06/17/生导C期末总结/23.png" alt=""></p><p>Population coding/Vector Coding Distributed representing<br>群体编码/向量编码/分布式表征</p><h2 id="连接主义与智能Connections-and-intelligence"><a href="#连接主义与智能Connections-and-intelligence" class="headerlink" title="连接主义与智能Connections and intelligence"></a>连接主义与智能Connections and intelligence</h2><p>外祖母细胞是一个假想的神经元，代表一个复杂但具体的概念或对象。</p><p>当一个人“看到、听到或以其他方式理智地歧视”一个特定实体时，如他或她的祖母，它就会激活。</p><p>这个词是杰里·莱特文在1969年左右创造的。两年前，灵知神经元的JerzyKonorski提出了一个类似的概念。</p><p>Theory：Single Cells as Feature Detector<br>外界世界的信息（甚至运动输出和复杂的认知过程）的编码可以由单个神经元来完成的。</p><p>“Running-out-of-neurons” problem<br>人的大脑神经细胞数目有限，如何表达无限可能的外界信息和内部思维状态</p><p><strong>信息由神经元池表示( Information is represented by pools of neurons)</strong></p><p>独立编码假设：每个神经元都独立地参与了该池</p><p>每个神经元的“投票”给出了一个总体向量</p><p>协调编码假说</p><p>群体中神经元之间的关系是信号的重要组成部分。</p><p>如果不考虑脉冲同步、振荡或人群中神经元之间的其他关系，就无法解码信号</p><h1 id="Lecture12：健康与疾病"><a href="#Lecture12：健康与疾病" class="headerlink" title="Lecture12：健康与疾病"></a>Lecture12：健康与疾病</h1><h2 id="免疫系统的原理"><a href="#免疫系统的原理" class="headerlink" title="免疫系统的原理"></a>免疫系统的原理</h2><p>天然免疫与获得性免疫</p><h3 id="先天免疫（所有动物）"><a href="#先天免疫（所有动物）" class="headerlink" title="先天免疫（所有动物）"></a>先天免疫（所有动物）</h3><p>• 使用一小组受体识别广泛病原体的共同特征</p><p>• 快速响应</p><p>屏障防御：皮、粘膜、分泌物</p><p>内部防御：吞噬细胞、自然杀伤细胞、抗菌蛋白质类、炎症反应</p><h3 id="适应性免疫（仅脊椎动物）"><a href="#适应性免疫（仅脊椎动物）" class="headerlink" title="适应性免疫（仅脊椎动物）"></a>适应性免疫（仅脊椎动物）</h3><p>• 使用avast受体阵列识别特定致病因子的特异性</p><p>• 响应较慢</p><p>体液反应：抗体可以抵抗体液中的感染。</p><p>细胞介导反应：细胞毒性细胞可以抵抗体内细胞的感染。</p><p><img src="/2022/06/17/生导C期末总结/24.png" alt=""></p><h3 id="免疫系统的两种噬细胞"><a href="#免疫系统的两种噬细胞" class="headerlink" title="免疫系统的两种噬细胞"></a>免疫系统的两种噬细胞</h3><ul><li><p>中性粒细胞</p></li><li><p>巨噬细胞</p></li><li><p>树突细胞</p></li><li><p>嗜酸性粒细胞</p></li></ul><p>脊椎动物的细胞天然防御也涉及自然杀伤细胞</p><p>这些细胞在体内循环并检测异常细胞</p><p>它们释放导致细胞死亡的化学物质，抑制病毒感染或癌细胞的传播</p><p>许多细胞先天防御系统涉及淋巴系统</p><h3 id="抗菌肽和蛋白质"><a href="#抗菌肽和蛋白质" class="headerlink" title="抗菌肽和蛋白质"></a>抗菌肽和蛋白质</h3><p>肽和蛋白质通过攻击病原体或阻碍其繁殖在天然防御中发挥作用</p><p>干扰素蛋白提供天然防御，干扰病毒并帮助激活巨噬细胞</p><p>补体系统由大约30种蛋白质组成，可导致入侵细胞溶解，并有助于引发炎症</p><p>炎症可以是局部的，也可以是全身的</p><p>发热是一种全身炎症反应，由巨噬细胞释放的物质对某些病原体作出反应而引发</p><p>败血性休克是一种严重的炎症反应引起的危及生命的疾病</p><h2 id="免疫抵抗"><a href="#免疫抵抗" class="headerlink" title="免疫抵抗"></a>免疫抵抗</h2><p>炎症反应，如疼痛和肿胀，是由感染损伤后释放的分子引起的</p><p>肥大细胞是一种结缔组织，它释放组胺，引发血管扩张并变得更具渗透性</p><p><img src="/2022/06/17/生导C期末总结/25.png" alt=""></p><p>病原微生物可以规避天然免疫</p><h2 id="获得性免疫"><a href="#获得性免疫" class="headerlink" title="获得性免疫"></a>获得性免疫</h2><h3 id="B细胞与T细胞"><a href="#B细胞与T细胞" class="headerlink" title="B细胞与T细胞"></a>B细胞与T细胞</h3><p>适应性反应依赖于两种类型的淋巴细胞或白细胞</p><p>在<strong>心脏上方胸腺</strong>中成熟的淋巴细胞称为T细胞，在<strong>骨髓</strong>中成熟的淋巴细胞称为B细胞</p><p>抗原是能引起B或T细胞反应的物质</p><h4 id="B细胞产生大量抗体"><a href="#B细胞产生大量抗体" class="headerlink" title="B细胞产生大量抗体"></a>B细胞产生大量抗体</h4><p>B细胞抗原受体与抗原的结合是B细胞活化的早期步骤</p><p>•这导致细胞分泌一种称为抗体或免疫球蛋白（Ig）的可溶性蛋白质</p><p>•抗体与B细胞抗原受体具有相同的Y形，但是分泌的，而不是膜结合的</p><h4 id="T细胞进行免疫应答"><a href="#T细胞进行免疫应答" class="headerlink" title="T细胞进行免疫应答"></a>T细胞进行免疫应答</h4><p>•每个T细胞受体由两条不同的多肽链（称为$\alpha $和$\beta$）组成</p><p>•链的尖端形成可变（V）区域；其余部分为恒定（C）区域</p><p>•T细胞和B细胞抗原受体功能不同</p><p>T或B细胞通过特定于病原体一个分子部分的抗原受体与抗原结合</p><p>T细胞与宿主细胞上显示或呈现的抗原片段结合</p><p><strong>T细胞和B细胞的多样性基础</strong></p><p>通过组合可变元件，免疫系统组装各种各样的抗原受体</p><p>免疫球蛋白（Ig）基因编码B细胞受体的一条链</p><p>通过DNA重排，同一基因可以产生许多不同的链。重排的DNA被转录和翻译，形成抗原受体</p><p>免疫反应的动态过程：二次免疫</p><p><img src="/2022/06/17/生导C期末总结/26.png" alt=""></p><h3 id="抗原"><a href="#抗原" class="headerlink" title="抗原"></a>抗原</h3><p>抗原中可与抗原受体结合的小部分称为表位</p><p>•每个单独的B或T细胞专门识别特定类型的分子</p><p>•B细胞和T细胞的抗原受体具有相似的成分，但它们以不同的方式遇到抗原</p><p>•每个B细胞抗原受体是一个Y形分子，具有两条相同的重链和两条相同的轻链</p><p>•在B细胞中，链的恒定区域变化不大，而可变区域差异很大</p><p>•可变区域提供抗原特异性</p><h2 id="细胞免疫"><a href="#细胞免疫" class="headerlink" title="细胞免疫"></a>细胞免疫</h2><p>细胞毒性T细胞使用有毒蛋白质杀死被病毒或其他细胞内病原体感染的细胞</p><p>细胞毒性T细胞识别受感染细胞产生的外源蛋白片段</p><p>活化的细胞毒性T细胞分泌蛋白质，破坏靶细胞膜并触发凋亡</p><p><img src="/2022/06/17/生导C期末总结/27.png" alt=""></p><p>B细胞的激活涉及辅助性T细胞以及病原体表面的蛋白质</p><p>当抗原与B细胞结合时，B细胞通过受体介导的内吞作用吸收少量外来分子</p><p>然后，B细胞的II类MHC蛋白将抗原片段呈现给辅助性T细胞，这一过程对B细胞活化至关重要</p><p><img src="/2022/06/17/生导C期末总结/28.png" alt=""></p><p>B淋巴细胞和T淋巴细胞提供的防御可分为体液免疫反应和细胞介导的免疫反应</p><p>在体液免疫反应中，抗体有助于中和或消除血液和淋巴中的毒素和病原体</p><p>在细胞介导的免疫反应中，特化T细胞破坏受影响的宿主细胞</p><h2 id="抗体和补体系统"><a href="#抗体和补体系统" class="headerlink" title="抗体和补体系统"></a>抗体和补体系统</h2><p>抗体不会杀死病原体；相反，它们会标记病原体以供销毁</p><p>•中和时，抗体与病毒表面蛋白结合，防止宿主细胞感染</p><p>•抗体也可能与体液中的毒素结合，阻止它们进入人体细胞</p><p>在调理过程中，抗体与细菌上的抗原结合，引发吞噬作用</p><p>•抗原抗体复合物可与补体蛋白结合，从而触发补体蛋白激活级联</p><p>•最终，膜攻击复合物在外来细胞膜上形成一个孔，导致其溶解</p><h2 id="免疫系统的异常与功效"><a href="#免疫系统的异常与功效" class="headerlink" title="免疫系统的异常与功效"></a>免疫系统的异常与功效</h2><ol><li>凝血</li></ol><p><img src="/2022/06/17/生导C期末总结/29.png" alt=""></p><ol start="2"><li>免疫排斥</li></ol><p>从一个人转移到另一个人的细胞会受到免疫防御的攻击</p><p>这使输血或组织或器官的移植变得复杂</p><ol start="3"><li>器官移植</li></ol><p>MHC分子在基因不完全相同的个体中是不同的</p><p>MHC分子的差异刺激组织移植和器官移植的排斥反应</p><ol start="4"><li><p>过敏反应</p></li><li><p>自身免疫病</p></li></ol><p>在患有自身免疫性疾病的个体中，免疫系统对自身失去耐受性，转而对抗身体的某些分子</p><p>自身免疫性疾病包括系统性红斑狼疮、类风湿性关节炎、非胰岛素依赖型糖尿病和多发性硬化症</p><ol start="6"><li>心理因素和免疫</li></ol><p>适度运动可改善免疫系统功能，通过改变激素、神经和免疫系统的相互作用来调节免疫系统，充分休息对免疫力也很重要</p><ol start="7"><li><p>免疫缺陷病</p></li><li><p>抗原变异</p></li><li><p>免疫逃逸</p></li></ol><h1 id="Leture13：现代生物技术"><a href="#Leture13：现代生物技术" class="headerlink" title="Leture13：现代生物技术"></a>Leture13：现代生物技术</h1><ul><li><p>分解</p></li><li><p>分析</p></li><li><p>重组</p></li><li><p>创造</p></li></ul><p>大胆而灵活<br>人类基因组计划的目标是相当大胆的。鉴于人们不知道人类基因组的测序和分析会得出什么样的结果，一些人抱着怀疑的态度审视这项工作也情有可原。优先发展技术<br>优先发展技术<br>1990年10月，人类基因组计划的成员们清醒地认识到，必须把基因组测序与绘制图谱的工具与方法作为一个更大的项目去开发。</p><p>有计划地分析数据<br>人类基因组计划的筹划有其缺陷。</p><p>数据分享最大化<br>人类基因组计划改变了生物医学研究中数据分享的E例。</p><p>·生物技术∶知识门槛不高</p><p>·运用场景︰需求旺盛<br>·生物技术创新︰基础研究工作量大，基本原理已经奠定</p><p>·新技术公司∶多如牛毛<br>目前生物技术公司的场景∶软件产业化早期。</p><h1 id="Lecture14：生命的进化和起源"><a href="#Lecture14：生命的进化和起源" class="headerlink" title="Lecture14：生命的进化和起源"></a>Lecture14：生命的进化和起源</h1><p>基因组的进化包含了复制、重排和突变现象</p><ul><li><p>事实1: 多样的物种具有不同的基因组</p></li><li><p>事实2: 比较不同的物种发现，基因组里有大量“无用”的DNA序列，大脑中有大量“无用”的区域</p></li></ul><p><strong>基因突变</strong>使得进化成为可能</p><p>• 种群是一个能够杂交并产生可育后代的局部个体群体<br>• 基因库由群体中所有位点的所有等位基因组成</p><p>• 对于二倍体生物，一个位点上的等位基因总数是个体总数乘以2<br>• 一个位点的显性等位基因总数为每个纯合显性个体的两个等位基因加上<br>每个杂合个体的一个等位基因；同样的逻辑也适用于隐性等位基因</p><p><strong>The Hardy-Weinberg Equation(“哈迪-温伯格定律”)</strong><br>• 哈迪-温伯格方程描述了我们对一个没有在特定位点进化的群体所<br>期望的遗传组成<br>• 如果观察到的种群遗传组成与哈迪·温伯格的预期不同，则表明种<br>群可能正在进化</p><p><strong>Hardy-Weinberg Equilibrium</strong><br>• 在配子随机产生下一代并发生孟德尔遗传的群体中，等位基因和<br>基因型频率代代相传保持不变<br>• 这样的种群处于哈代-温伯格平衡</p><p>自然选择，遗传漂移和基因流动会改变一个群体中<br>的基因频率</p><h2 id="基因漂变"><a href="#基因漂变" class="headerlink" title="基因漂变"></a>基因漂变</h2><p>• 偶然事件会导致等位基因频率在一代到下一代之间发生不可预测<br>的波动，尤其是在小群体中，这一过程被称为遗传漂变。<br>• 在遗传漂变中，世代间等位基因频率的偶然波动往往会减少遗传<br>变异。</p><h2 id="瓶颈效应"><a href="#瓶颈效应" class="headerlink" title="瓶颈效应"></a>瓶颈效应</h2><p>•瓶颈效应是由于环境变化导致人口数量突然减少</p><p>•产生的基因库可能不再反映原始群体的基因库</p><p>•如果种群数量仍然较小，可能会进一步受到遗传漂变的影响</p><h2 id="自然选择"><a href="#自然选择" class="headerlink" title="自然选择"></a>自然选择</h2><p>自然选择(自然选择） 是唯一能持续导致适应性进化的机制</p><p>•自然选择的进化涉及机会和“排序”</p><p>•新的基因变异是偶然产生的</p><p>•有益等位基因被“分类”并受到自然选择的青睐</p><p>•只有自然选择才能持续增加提供生殖优势的等位基因的频率</p><h2 id="杂种优势"><a href="#杂种优势" class="headerlink" title="杂种优势"></a>杂种优势</h2><p>当杂合子比两个纯合子都具有更高的适合度时，杂合子优势就会出现</p><p>•自然选择倾向于在该位点保持两个或多个等位基因</p><p>•杂合子优势可能来自稳定或定向选择</p><h2 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h2><p>基因组上的进化<br>• 基因组复杂多样<br>• DNA复制、重排、突变<br>• 基因组比较推测亲缘关系<br>• 种群和微进化<br>• 基因频率<br>• 哈迪-温伯格定律<br>• 自然选择，遗传漂移和基因流动</p><h2 id="生命起源"><a href="#生命起源" class="headerlink" title="生命起源"></a>生命起源</h2><h3 id="原细胞"><a href="#原细胞" class="headerlink" title="原细胞"></a>原细胞</h3><p>• 复制和代谢是生命的关键特性，可能在原细胞中同时出现<br>• 原细胞可能是由具有膜状结构的充满液体的囊泡形成的<br>• 在水中，脂质和其他有机分子可以自发形成具有脂质双层的囊泡</p><p><img src="/2022/06/17/生导C期末总结/30.png" alt=""></p><p><strong>RNA是最早使用的遗传物质</strong></p><h3 id="The-First-Single-Celled-Organisms"><a href="#The-First-Single-Celled-Organisms" class="headerlink" title="The First Single-Celled Organisms"></a>The First Single-Celled Organisms</h3><p>• 已知最古老的化石是叠层石, 细菌席上沉积层堆积形成的岩石叠层石可追溯到35亿年前<br>• 15多亿年来，原核生物是地球上唯一的居民</p><p>• 大气中的大多数氧（O2）来源于生物<br>• 光合作用产生的氧气与溶解的铁发生反应，沉淀出来形成带状铁<br>（矿石）</p><h3 id="最早的真核生物"><a href="#最早的真核生物" class="headerlink" title="最早的真核生物"></a>最早的真核生物</h3><p>最古老的真核细胞化石可追溯到18亿年前<br>• 真核细胞有核膜、线粒体、内质网和细胞骨架<br>• 内共生体理论提出，线粒体和质体（叶绿体和相关细胞器）以前是生活在较大宿主细胞内的小型原核生物</p><h3 id="多细胞生物出现"><a href="#多细胞生物出现" class="headerlink" title="多细胞生物出现"></a>多细胞生物出现</h3><p>• 真核细胞的进化使得更广泛多样的单细胞类型形成<br>• 当多细胞进化产生并产生藻类、植物、真菌和动物时，出现了第二波多样化</p><h3 id="物种的产生和灭亡"><a href="#物种的产生和灭亡" class="headerlink" title="物种的产生和灭亡"></a>物种的产生和灭亡</h3><p>• 地球上生命的历史见证了许多生物群的兴衰<br>• 种群的兴衰取决于种群内的物种形成和灭绝速率<br>• 生物群命运的这种变化受到了大规模过程的影响，如板块构造、大灭绝和适应性辐射。</p><h3 id="Mass-Extinctions-大灭绝"><a href="#Mass-Extinctions-大灭绝" class="headerlink" title="Mass Extinctions 大灭绝"></a>Mass Extinctions 大灭绝</h3><p>• 化石记录表明，大多数曾经生活过的物种现已灭绝<br>• 物种的灭绝可能是由物种环境的变化引起的<br>• 有时，物种灭绝的速度急剧增加，并导致大灭绝<br>• 大灭绝是破坏性全球环境变化的结果</p><h3 id="适应辐射"><a href="#适应辐射" class="headerlink" title="适应辐射"></a>适应辐射</h3><p>适应性辐射是来自同一祖先的不同适应物种的快速进化</p><p>• 陆生恐龙灭绝后，哺乳动物经历了适应性辐射<br>• 恐龙（鸟类除外）的消失使哺乳动物的多样性和体型得以扩大<br>• 其他适应性辐射包括光合原核生物的崛起、寒武纪大型食肉动物的进化、和植物、昆虫、四足动物对陆地的占领</p><h3 id="进化趋势"><a href="#进化趋势" class="headerlink" title="进化趋势"></a>进化趋势</h3><p>• 从化石记录中提取单一的进化进程可能会产生误导<br>• 应在更广泛的背景下审查明显的趋势<br>• 物种选择模型表明，不同物种形成的成功可能决定进化趋势<br>• 进化趋势并不意味着对特定表型的内在驱动力</p><h3 id="进化树、系统发生树"><a href="#进化树、系统发生树" class="headerlink" title="进化树、系统发生树"></a>进化树、系统发生树</h3><p>在一些进化树中，分支的长度可以反映该谱系中特定DNA序列中<br>发生的遗传变化的数量</p><p><img src="/2022/06/17/生导C期末总结/31.png" alt=""></p><h3 id="最大简约与最大似然"><a href="#最大简约与最大似然" class="headerlink" title="最大简约与最大似然"></a>最大简约与最大似然</h3><p>• 随着不断增长的DNA序列数据库使我们能够研究更多的物种，构建最能描述其进化历史的系统发育树的难度也越来越大<br>• 系统论者永远无法确定在大型数据集中找到最好的树<br>• 他们通过应用最大简约和最大似然的原则来缩小可能性</p><p>• 最大简约 假设需要最少进化事件的树最有可能<br>• 最大似然原理指出，给定DNA如何随时间变化的某些规则，可以找到一棵树来反映最可能的进化事件序列<br>• 计算机程序被用来搜索简约或者似然的进化树</p><h3 id="Phylogenetic-Trees-as-Hypotheses"><a href="#Phylogenetic-Trees-as-Hypotheses" class="headerlink" title="Phylogenetic Trees as Hypotheses"></a>Phylogenetic Trees as Hypotheses</h3><p>• 系统发育树的最佳假设应符合大多数数据：形态学、分子和化石<br>• Phylogenetic bracketing（系统发育环套法）允许我们根据后代的<br>特征预测祖先的特征<br>• 例如，系统发育括号可以让我们推断恐龙的特征</p><h3 id="基因复制和基因家族"><a href="#基因复制和基因家族" class="headerlink" title="基因复制和基因家族"></a>基因复制和基因家族</h3><p>• 直系同源基因是在不同物种中发现的基因，它们的差异可追溯到<br>产生该物种的物种形成事件<br>• 旁系同源基因源于基因复制；因此，在一个物种中，这种基因的<br>多个拷贝彼此分离产生</p><h2 id="高中知识：生物多样性"><a href="#高中知识：生物多样性" class="headerlink" title="高中知识：生物多样性"></a>高中知识：生物多样性</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要总结一下不太会的或者忘记的部分其他部分就不写了 应试用的 &lt;/p&gt;
&lt;h1 id=&quot;Lecture3：生命的物质基础&quot;&gt;&lt;a href=&quot;#Lecture3：生命的物质基础&quot; class=&quot;headerlink&quot; title=&quot;Lecture3：生命的物质基础&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
  <entry>
    <title>CA期末总结</title>
    <link href="http://yoursite.com/2022/06/13/CA%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/06/13/CA%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-13T23:21:04.000Z</published>
    <updated>2022-06-18T14:19:07.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lecture1-Introduction"><a href="#Lecture1-Introduction" class="headerlink" title="Lecture1: Introduction"></a>Lecture1: Introduction</h1><p>• Thinking about Machine Structures</p><p>• Great Ideas in Computer Architecture</p><p>• What you need to know about this class</p><p>• Everything is a Number</p><h1 id="Lecture-2-C-I"><a href="#Lecture-2-C-I" class="headerlink" title="Lecture 2: C I"></a>Lecture 2: C I</h1><p>• Compile vs. Interpret 不同进制数字表示法</p><ul><li><p>二进制的表示方法：1.Unsigned Integers 2.Two’s-Complement 二补数（取反+1）3. One’s-Complement 一补数（直接取反）4. Sign Magnitude 只有最高位表示符号</p></li><li><p>CPP Macro 宏定义 <code>#define MAG(x, y) (sqrt( (x)*(x) + (y)*(y)))</code> 要加很多括号不然就会有问题</p></li></ul><h1 id="Lecture-3-C-II"><a href="#Lecture-3-C-II" class="headerlink" title="Lecture 3: C II"></a>Lecture 3: C II</h1><p>• Pointers</p><p>• Pointers &amp; Arrays</p><p>• C Memory Management</p><p>• C Bugs</p><p> 指针的分类</p><ul><li>空指针 指针的值为NULL或0的指针</li><li>空悬指针  指向的空间已被释放</li><li>野指针  指针未被初始化(赋值)</li></ul><h3 id="C内存管理"><a href="#C内存管理" class="headerlink" title="C内存管理"></a>C内存管理</h3><p>静态内存、动态内存<br>静态内存分配好后，程序运行过程中一直存在不会被释放，且一旦分配好，其内存大小就固定下来不能改变，在编译和链接的阶段就会分配好。<br>动态内存是程序运行过程中，根据程序的需要分配和释放，其大小可变。</p><p>2 堆与栈<br>堆是程序通过调用malloc或new分配，调用free或delete释放。 栈是线性结构，堆是链表结构。</p><p>3 C的内存分配<br>全局变量和static修饰的静态变量都存放在静态内存区<br>函数内部定义的局部变量，存储在栈上，函数退出时，其占用内存被收回。<br>调用malloc或new得到的内存在堆上，不再需要时要显示的调用free或delete来释放，否则会造成内存泄漏</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//全局初始化区 ，static</span><span class="token keyword">char</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//全局未初始化区 , static</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//stack</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//stack</span><span class="token keyword">char</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//stack</span><span class="token keyword">char</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//"123456\0"在static，静态内存，p3在栈上。 </span>p3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">></span><span class="token keyword">static</span> <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span><span class="token number">0</span>； <span class="token comment" spellcheck="true">//全局（静态）初始化区 static</span>p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// heap</span>p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//heap</span><span class="token operator">&amp;</span>p2 <span class="token operator">-</span><span class="token operator">></span> stack <span class="token function">strcpy</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//"123456\0"放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Lecture-4-RISC-V-I"><a href="#Lecture-4-RISC-V-I" class="headerlink" title="Lecture 4: RISC-V I"></a>Lecture 4: RISC-V I</h1><h3 id="Big-Endian-vs-Little-Endian"><a href="#Big-Endian-vs-Little-Endian" class="headerlink" title="Big Endian vs. Little Endian"></a>Big Endian vs. Little Endian</h3><p><img src="/2022/06/13/CA期末总结/2.png" alt=""></p><h1 id="Lecture-5-RISC-V-II-III-IV"><a href="#Lecture-5-RISC-V-II-III-IV" class="headerlink" title="Lecture 5: RISC-V II III IV"></a>Lecture 5: RISC-V II III IV</h1><p>introduce how to write risc-v 具体看绿卡就行</p><p><img src="/2022/06/13/CA期末总结/3.png" alt=""></p><h1 id="Lecture-8-RISC-V-V"><a href="#Lecture-8-RISC-V-V" class="headerlink" title="Lecture 8: RISC-V V"></a>Lecture 8: RISC-V V</h1><p>浮点数表示法</p><p><a href="http://www.speedfly.cn/tools/hexconvert/" target="_blank" rel="noopener">在线进制转换-IEE754浮点数16进制转换</a></p><p><img src="/2022/06/13/CA期末总结/4.png" alt=""></p><h1 id="Lecture-9-Call"><a href="#Lecture-9-Call" class="headerlink" title="Lecture 9: Call"></a>Lecture 9: Call</h1><h4 id="Interpretation"><a href="#Interpretation" class="headerlink" title="Interpretation"></a>Interpretation</h4><p>• Python interpreter is just a program that reads a</p><p>python program and performs the functions of</p><p>that python program.</p><ul><li>Interpretation vs. Translation</li></ul><p><img src="/2022/06/13/CA期末总结/42.png" title="" alt="" data-align="inline"></p><h2 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h2><p>Input: High-Level Language Code</p><p>Output: Assembly Language Code</p><p>Pseudo-instructions: instructions that assembler understands but not in machine</p><p><img src="/2022/06/13/CA期末总结/43.png" alt=""></p><h2 id="Assembler"><a href="#Assembler" class="headerlink" title="Assembler"></a>Assembler</h2><p>Input: Assembly Language Code</p><p>Output: Object Code, information tables</p><p>Reads and Uses Directives</p><ul><li><p>Replace Pseudo-instructions</p></li><li><p>Produce Machine Language</p></li><li><p>Creates Object File</p></li></ul><p>Assembler Directives</p><p>• Give directions to assembler, but do not produce machine instructions</p><h3 id="Producing-Machine-Language"><a href="#Producing-Machine-Language" class="headerlink" title="Producing Machine Language"></a>Producing Machine Language</h3><p>• Simple Case</p><p>• What about Branches?</p><p>– PC-Relative (e.g., beq/bne and jal)</p><p>– So once pseudo-instructions are replaced by real ones, we know by how many instructions to branch</p><p>• “Forward Reference” problem ：Solved by taking two passes over the program</p><ul><li><p>First pass remembers position of labels</p></li><li><p>Second pass uses label positions to generate code</p></li></ul><h3 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h3><p>List of “items” in this file that may be used by</p><p>other files</p><p>– Labels: function calling</p><p>– Data: anything in the .data section; variables which may be accessed across files</p><h3 id="Relocation-Table"><a href="#Relocation-Table" class="headerlink" title="Relocation Table"></a>Relocation Table</h3><p>• List of “items” whose address this file needs</p><p><img src="/2022/06/13/CA期末总结/44.png" alt=""></p><h3 id="Assembly-Step"><a href="#Assembly-Step" class="headerlink" title="Assembly Step :"></a>Assembly Step :</h3><ul><li><p>Instructions and Labels have addresses</p></li><li><p>Create relocation table and symbol table</p></li><li><p>Generate object (.o) file,Output binary representation for</p><p>• text segment (instructions)</p><p>• data segment (data)</p><p>• symbol and relocation tables</p></li></ul><h2 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h2><p>• Input: Object code files, information tables</p><p>• Output: Executable code</p><p>• Combines several object (.o) files into a single executable (“linking”)</p><p>• Enable separate compilation of files</p><p>– Changes to one file do not require recompilation of the whole program</p><p>• Linux source &gt; 20 M lines of code!</p><p>– Old name “Link Editor” from editing the “links” in jump and link instructions</p><p><img src="/2022/06/13/CA期末总结/45.png" alt=""></p><p><img src="/2022/06/13/CA期末总结/46.png" alt=""></p><p>• To resolve references:</p><p>– search for reference (data or label) in all “user” symbol tables</p><p>– if not found, search library files</p><p>– once absolute address is determined, fill in the machine code appropriately</p><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>• Input: Executable Code</p><p>• Output: (program is run)</p><p>• Executable files are stored on disk</p><p>• When one is run, loader’s job is to load it into</p><p>memory and start it running</p><p>• In reality, loader is the operating system (OS)</p><p>– loading is one of the OS tasks</p><p><img src="/2022/06/13/CA期末总结/47.png" alt=""></p><h3 id="Static-vs-Dynamically-linked-libraries"><a href="#Static-vs-Dynamically-linked-libraries" class="headerlink" title="Static vs Dynamically linked libraries"></a>Static vs Dynamically linked libraries</h3><p><img src="/2022/06/13/CA期末总结/48.png" alt=""></p><h2 id="Some-steps-for-each-stages"><a href="#Some-steps-for-each-stages" class="headerlink" title="Some steps for each stages"></a>Some steps for each stages</h2><h3 id="Compiler-1"><a href="#Compiler-1" class="headerlink" title="Compiler"></a>Compiler</h3><ol><li><p>Uses Lexers to process the input into tokens.</p></li><li><p>Be responsible for loop unrolling</p></li><li><p>Produce an executable binary from a collection of <strong>C source files</strong></p></li><li><p>Checks if there are any syntax errors in the C source files.</p></li><li><p>Resolve #include directives.</p></li></ol><h3 id="Assembler-1"><a href="#Assembler-1" class="headerlink" title="Assembler"></a>Assembler</h3><ol><li><p>Prepares the relocation table.</p></li><li><p>Produce an executable binary from a collection of C source files.</p></li><li><p>Translate symbolic register name to integer register name.</p></li></ol><h3 id="Linker-1"><a href="#Linker-1" class="headerlink" title="Linker"></a>Linker</h3><ol><li><p>Prepares the virtual address space for the static section.</p></li><li><p>Fills in the final value for the immediate in jump instructions. Note that the label<br>we are jumping to exists in a different file than the jump instruction.</p></li><li><p>Incorporates statically-linked libraries.</p></li><li><p>Produces <strong>executable file</strong>containing text and data (plus header).</p></li><li><p>Produce an <strong><em>executable binary</em></strong> from a collection of C source files.</p></li><li><p>Relocation</p></li></ol><h3 id="Loader-1"><a href="#Loader-1" class="headerlink" title="Loader"></a>Loader</h3><ol><li><p>Copies instructions and data from executable file into the address space.</p></li><li><p>Runtime symbol resolution</p></li></ol><h1 id="Lecture-10-SDS"><a href="#Lecture-10-SDS" class="headerlink" title="Lecture 10: SDS"></a>Lecture 10: SDS</h1><ul><li>CMOS</li></ul><p><img src="/2022/06/13/CA期末总结/5.png" alt=""></p><p><img src="/2022/06/13/CA期末总结/6.png" alt=""></p><p><img src="/2022/06/13/CA期末总结/7.png" alt=""></p><h2 id="逻辑电路化简公式"><a href="#逻辑电路化简公式" class="headerlink" title="逻辑电路化简公式"></a>逻辑电路化简公式</h2><p><a href="https://blog.csdn.net/qq_41361526/article/details/107770713" target="_blank" rel="noopener">数字电路 化简</a></p><p>并项法： AB + AB’ = A<br>两项合并为一项，消去B与B’</p><p>吸收法： A + AB = A<br>短项吸收长项</p><p>消项法： AB+ A’C + BC =AB + A’C<br>可拓展为：<br>AB+ A’C + BCD =AB + A’C</p><p>消因子法：A + A’B = A + B<br>短项能够消去 长项中 的 相反项<br>此处也能这样理解：A看作A*(1+B), 即A+AB+A’B</p><p>配项法： 基本公式 A + A = A<br>可以在逻辑函数中重复写入某一项，或如下图过程中所示，乘上(A+A’)</p><p><img src="/2022/06/13/CA期末总结/10.png" alt=""></p><p><img src="/2022/06/13/CA期末总结/11.png" alt=""></p><h1 id="Lecture-11-FSM"><a href="#Lecture-11-FSM" class="headerlink" title="Lecture 11: FSM"></a>Lecture 11: FSM</h1><p>SDS相关计算</p><p><img src="file:///D:/Blog/source/_posts/CA期末总结/8.png" title="" alt="" data-align="right"></p><p><img src="/2022/06/13/CA期末总结/9.png" alt=""></p><p>min clk period= clk-to-q delay + max CL delay +set up time</p><p>longest set up time = min (clk period - input delay) (包括寄存器clk delay) 算从输入到寄存器的delay</p><p>longest hold time = min output delay (包括寄存器clk delay，从输出口子到output的delay）</p><p>clk-q + best case CL delay &lt; hold time</p><h1 id="Lecture-12-CPU-Control-amp-Datapath"><a href="#Lecture-12-CPU-Control-amp-Datapath" class="headerlink" title="Lecture 12 : CPU Control &amp; Datapath"></a>Lecture 12 : CPU Control &amp; Datapath</h1><p><img src="/2022/06/13/CA期末总结/12.png" alt=""></p><p>Complete Datapath</p><p><img src="/2022/06/13/CA期末总结/13.png" alt=""></p><p><img src="/2022/06/13/CA期末总结/14.png" alt=""></p><h1 id="Lecture-12-Pipelining"><a href="#Lecture-12-Pipelining" class="headerlink" title="Lecture 12: Pipelining"></a>Lecture 12: Pipelining</h1><p>• Pipelining</p><p>• Hazards</p><p>– Structural</p><p>– Data</p><p>• R-type instructions</p><p>• Load</p><p>– Control</p><h3 id="Single-Cycle-Performance-without-pipeline-t-clk-t-pc-clk-q-t-IMEMread-t-RF-read-t-mux-t-ALU-t-DMEMread-t-mux-t-RFsetup"><a href="#Single-Cycle-Performance-without-pipeline-t-clk-t-pc-clk-q-t-IMEMread-t-RF-read-t-mux-t-ALU-t-DMEMread-t-mux-t-RFsetup" class="headerlink" title="Single Cycle Performance without pipeline: $t_{clk}=t_{pc-clk-q}+t_{IMEMread}+t_{RF read}+t_{mux}+t_{ALU}+t_{DMEMread}+t_{mux}+t_{RFsetup}$"></a>Single Cycle Performance without pipeline: $t_{clk}=t_{pc-clk-q}+t_{IMEMread}+t_{RF read}+t_{mux}+t_{ALU}+t_{DMEMread}+t_{mux}+t_{RFsetup}$</h3><h3 id="how-to-speed-up-of-5-through-pipelining"><a href="#how-to-speed-up-of-5-through-pipelining" class="headerlink" title="how to speed up of 5 through pipelining:"></a>how to speed up of 5 through pipelining:</h3><ol><li><p>No hazards</p></li><li><p>No pipeline register delay</p></li><li><p>All pipeline stages have equal delay</p></li></ol><h3 id="5-stages-pipelining"><a href="#5-stages-pipelining" class="headerlink" title="5 stages pipelining"></a>5 stages pipelining</h3><p>IF : $t_{clk-q}+t_{MEMread}+t_{Regsetup}$</p><p>ID：$t_{clk-q}+t_{RFread}+t_{Regsetup}$</p><p>EX：$t_{clk-q}+t_{mux}+t_{ALU}+t_{Regsetup}+t_{mux}$</p><p>MEM：$t_{Regclk-q}+t_{MEMread}+t_{mux}+t_{Regsetup}$</p><p>WB：$t_{Regclk-q}+t_{RFsetup}$</p><p><img src="/2022/06/13/CA期末总结/16.png" alt=""></p><p><img src="/2022/06/13/CA期末总结/17.png" alt=""></p><p>Structural hazards occur when more than one instruction needs to use the same datapath resource at the same time. Structural hazards can always be resolved by adding more hardware.</p><h3 id="Data-Hazard-solution"><a href="#Data-Hazard-solution" class="headerlink" title="Data Hazard solution"></a>Data Hazard solution</h3><ul><li><p>stalling</p></li><li><p>forwarding</p></li></ul><h3 id="Control-Hazards-solution"><a href="#Control-Hazards-solution" class="headerlink" title="Control Hazards solution"></a>Control Hazards solution</h3><ul><li>prediction</li></ul><h1 id="Lecture-13-Superscalar"><a href="#Lecture-13-Superscalar" class="headerlink" title="Lecture 13: Superscalar"></a>Lecture 13: Superscalar</h1><p>• Processor Performance - Overview</p><p>• Complex Pipelines</p><p>• Static Multiple Issues (VLIW)</p><p>• Dynamic Multiple Issues (Superscalar)</p><h3 id="“Iron-Law”-of-Processor"><a href="#“Iron-Law”-of-Processor" class="headerlink" title="“Iron Law” of Processor"></a>“Iron Law” of Processor</h3><p>cpi </p><p><img src="/2022/06/13/CA期末总结/18.png" alt=""></p><p>Static Multiple Issue</p><p>• aka.: Very Long Instruction Word (VLIW)</p><p>• Compiler bundles instructions together</p><p>• Compiler takes care of hazards</p><p>• CPU executes at the same time</p><p><img src="/2022/06/13/CA期末总结/19.png" alt=""></p><p>fetch buffer between 1 and 2</p><h1 id="Lecture-14-16-Caches-Part-I"><a href="#Lecture-14-16-Caches-Part-I" class="headerlink" title="Lecture 14-16: Caches Part I"></a>Lecture 14-16: Caches Part I</h1><p>Cache Lecture I</p><p>– Caches Introduction</p><p>– Principle of Locality</p><p>• Temporal Locality (locality in time)</p><p>– If a memory location is referenced, then it will</p><p>tend to be referenced again soon</p><p>• Spatial Locality (locality in space)</p><p>– If a memory location is referenced, the locations</p><p>with nearby addresses will tend to be referenced soon</p><p><img src="/2022/06/13/CA期末总结/20.png" alt=""></p><p>– Simple Cache</p><p><img src="/2022/06/13/CA期末总结/21.png" alt=""></p><p>– Direct Mapped &amp; Set-Associative Caches</p><p>• Cache Lecture II</p><p>– Stores to Caches</p><p>– Cache Performance</p><p>– Cache Misses</p><p><img src="/2022/06/13/CA期末总结/22.png" alt=""></p><p>– Cache Configurations</p><p>– Cache Examples</p><h4 id="increase-associativity"><a href="#increase-associativity" class="headerlink" title="increase associativity"></a>increase associativity</h4><ul><li><p>hit time increase</p></li><li><p>miss rate decrease</p></li><li><p>miss penalty unchange</p></li></ul><h4 id="increase-entries"><a href="#increase-entries" class="headerlink" title="increase entries"></a>increase entries</h4><ul><li><p>hit time increase</p></li><li><p>miss rate decrease</p></li><li><p>miss penalty unchange</p></li></ul><h4 id="increase-block-size"><a href="#increase-block-size" class="headerlink" title="increase block size"></a>increase block size</h4><ul><li><p>hit time unchange</p></li><li><p>miss rate decrease</p></li><li><p>miss penalty increase</p></li></ul><p><img src="/2022/06/13/CA期末总结/23.png" alt=""></p><p>矩阵乘法 最快的循环时jki</p><h1 id="Lecture-19-DLP"><a href="#Lecture-19-DLP" class="headerlink" title="Lecture 19: DLP"></a>Lecture 19: DLP</h1><h2 id="Flynn-Taxonomy"><a href="#Flynn-Taxonomy" class="headerlink" title="Flynn* Taxonomy"></a>Flynn* Taxonomy</h2><ul><li><p>Single-Instruction/Single-Data Stream(SISD)</p></li><li><p>Single-Instruction/Multiple-Data Stream(SIMD or “sim-dee”)</p></li><li><p>Multiple-Instruction/Multiple-Data Streams(MIMD or “mim-dee”)</p></li><li><p>Multiple-Instruction/Single-Data Stream(MISD)</p></li></ul><p><img src="/2022/06/13/CA期末总结/24.png" alt=""></p><p>SIMD simplify in LAB</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum_naive</span><span class="token punctuation">(</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>        sum <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sum_unrolled</span><span class="token punctuation">(</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* do the body of the work in a faster unrolled loop */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">/</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        sum <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        sum <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        sum <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* handle the small tail in a usual way */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>           sum <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sum_vectorized</span><span class="token punctuation">(</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token punctuation">)</span><span class="token punctuation">{</span>    __m128i tp<span class="token operator">=</span><span class="token function">_mm_setzero_si128</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">/</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        tp<span class="token operator">=</span><span class="token function">_mm_add_epi32</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span><span class="token function">_mm_loadu_si128</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__m128i <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> z<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>ans<span class="token punctuation">;</span>    <span class="token function">_mm_storeu_si128</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>__m128i <span class="token operator">*</span><span class="token punctuation">)</span>z<span class="token punctuation">,</span>  tp <span class="token punctuation">)</span><span class="token punctuation">;</span>    ans<span class="token operator">=</span>z<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>z<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>z<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>z<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        ans<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sum_vectorized_unrolled</span><span class="token punctuation">(</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token punctuation">)</span><span class="token punctuation">{</span>    __m128i tp<span class="token operator">=</span><span class="token function">_mm_setzero_si128</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">/</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">16</span><span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        tp<span class="token operator">=</span><span class="token function">_mm_add_epi32</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span><span class="token function">_mm_loadu_si128</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__m128i <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tp<span class="token operator">=</span><span class="token function">_mm_add_epi32</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span><span class="token function">_mm_loadu_si128</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__m128i <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tp<span class="token operator">=</span><span class="token function">_mm_add_epi32</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span><span class="token function">_mm_loadu_si128</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__m128i <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tp<span class="token operator">=</span><span class="token function">_mm_add_epi32</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span><span class="token function">_mm_loadu_si128</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__m128i <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> z<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>ans<span class="token punctuation">;</span>    <span class="token function">_mm_storeu_si128</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>__m128i <span class="token operator">*</span><span class="token punctuation">)</span>z<span class="token punctuation">,</span>  tp <span class="token punctuation">)</span><span class="token punctuation">;</span>    ans<span class="token operator">=</span>z<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>z<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>z<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>z<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">16</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        ans<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Amdahl’s-Law"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a>Amdahl’s Law</h3><p><img src="/2022/06/13/CA期末总结/25.png" alt=""></p><ul><li>Loop Unrolled</li></ul><p>• Amdahl’s Law: Serial sections limit speedup</p><p>• Flynn Taxonomy</p><p>• Intel SSE SIMD Instructions</p><p>– Exploit data-level parallelism in loops</p><p>– One instruction fetch that operates on multiple</p><p>operands simultaneously</p><p>– 128-bit XMM registers</p><p>• SSE Instructions in C</p><p>– Embed the SSE machine instructions directly into C</p><p>programs through use of intrinsics</p><p>– Achieve efficiency beyond that of optimizing compiler</p><h1 id="Lecture-20-TLP-Thread-Level-Parallelism"><a href="#Lecture-20-TLP-Thread-Level-Parallelism" class="headerlink" title="Lecture 20: TLP Thread-Level Parallelism"></a>Lecture 20: TLP Thread-Level Parallelism</h1><ul><li><p>Hardware Multithreading</p></li><li><p>Operating System Threads</p></li><li><p>Hyper-threading (simplified)</p></li><li><p>OpenMP</p></li></ul><p><a href="https://cloud.tencent.com/developer/article/1949206" target="_blank" rel="noopener">【OpenMP学习笔记】</a></p><p><img src="/2022/06/13/CA期末总结/26.png" alt=""></p><p><img src="/2022/06/13/CA期末总结/27.png" alt=""></p><ul><li><p>OpenMP problem data race</p></li><li><p>OpenMP lock (too slow)</p></li></ul><p>OpenMP for loop divides index regions sequentially per thread in default.<br>For potential spatial locality and cache optimization.</p><p>OpenMP in lab</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// EDIT THIS FUNCTION PART 1</span><span class="token keyword">double</span> <span class="token function">dotp_manual_optimized</span> <span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>y<span class="token punctuation">,</span> <span class="token keyword">int</span> arr_size<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">double</span> global_sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>  <span class="token macro property">#<span class="token directive keyword">pragma</span> omp parallel</span>  <span class="token punctuation">{</span>    <span class="token keyword">int</span> curr_id <span class="token operator">=</span> <span class="token function">omp_get_thread_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num_threads <span class="token operator">=</span> <span class="token function">omp_get_num_threads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> curr_id <span class="token operator">*</span> <span class="token punctuation">(</span>arr_size <span class="token operator">/</span> num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>arr_size <span class="token operator">/</span> num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> thread_sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      thread_sum <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr_id <span class="token operator">==</span> num_threads <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;</span> arr_size<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        thread_sum <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">pragma</span> omp critical</span>      global_sum <span class="token operator">+</span><span class="token operator">=</span> thread_sum<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token keyword">return</span> global_sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// EDIT THIS FUNCTION PART 2</span><span class="token keyword">double</span> <span class="token function">dotp_reduction_optimized</span> <span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>y<span class="token punctuation">,</span> <span class="token keyword">int</span> arr_size<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">double</span> global_sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>  <span class="token macro property">#<span class="token directive keyword">pragma</span> omp parallel</span>  <span class="token punctuation">{</span>    <span class="token macro property">#<span class="token directive keyword">pragma</span> omp for reduction (+ : global_sum)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      global_sum <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> global_sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">v_add_for</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span> y<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span> z<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token macro property">#<span class="token directive keyword">pragma</span> omp parallel</span>    <span class="token punctuation">{</span>    <span class="token macro property">#<span class="token directive keyword">pragma</span> omp for</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>ARRAY_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">v_add_optimized_adjacent</span> <span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>y<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token macro property">#<span class="token directive keyword">pragma</span> omp parallel</span>  <span class="token punctuation">{</span>    <span class="token keyword">int</span> curr_id <span class="token operator">=</span> <span class="token function">omp_get_thread_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num_threads <span class="token operator">=</span> <span class="token function">omp_get_num_threads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> curr_id<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> num_threads<span class="token punctuation">)</span>    z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Edit this function (Method 2) </span><span class="token keyword">void</span> <span class="token function">v_add_optimized_chunks</span> <span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>y<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token macro property">#<span class="token directive keyword">pragma</span> omp parallel</span>  <span class="token punctuation">{</span>    <span class="token keyword">int</span> curr_id <span class="token operator">=</span> <span class="token function">omp_get_thread_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num_threads <span class="token operator">=</span> <span class="token function">omp_get_num_threads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> curr_id <span class="token operator">*</span> <span class="token punctuation">(</span>ARRAY_SIZE <span class="token operator">/</span> num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>ARRAY_SIZE <span class="token operator">/</span> num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr_id <span class="token operator">==</span> num_threads <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        z<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Lecture-22-OS"><a href="#Lecture-22-OS" class="headerlink" title="Lecture 22: OS"></a>Lecture 22: OS</h1><p>• OS Boot Sequence and Operation</p><p>• Devices and I/O, interrupt and traps</p><p>I/O Example (<strong>polling</strong>) :mouse/processor</p><p><img src="/2022/06/13/CA期末总结/28.png" alt=""></p><p><strong>Interrupt-driven</strong> I/O:Disk</p><p><img src="/2022/06/13/CA期末总结/29.png" alt=""></p><h3 id="Polling-compare-with-Interrupt"><a href="#Polling-compare-with-Interrupt" class="headerlink" title="Polling compare with Interrupt"></a>Polling compare with Interrupt</h3><p>Polling: CPU periodically queries device to determine if they need attention<br>Interrupts: Each device signals to CPU that it wants to be serviced<br>The latter one is better since it utilizes CPU better</p><p>Traps/Interrupts/Exceptions</p><p>• Application, Multiprogramming/time-sharing</p><h1 id="Lecture-24-VM"><a href="#Lecture-24-VM" class="headerlink" title="Lecture 24: VM"></a>Lecture 24: VM</h1><ul><li>What do we need Virtual Memory for?</li></ul><p>Reason 1: Adding Disks to Hierarchy</p><p>Reason 2: Simplifying Memory for Apps</p><p>Reason 3: Protection Between Processes</p><p><img src="/2022/06/13/CA期末总结/30.png" alt=""></p><p>Pages advantages:</p><ul><li><p>run program longer than DRAM</p></li><li><p>no memory fragamentation</p></li></ul><p>TLB</p><p><img src="/2022/06/13/CA期末总结/31.png" alt=""></p><p>TLB check -&gt; page check -&gt; allocate new memory -&gt; update page -&gt; update TLB</p><p><img src="/2022/06/13/CA期末总结/32.png" alt=""></p><h3 id="Some-true-or-false-statement"><a href="#Some-true-or-false-statement" class="headerlink" title="Some true or false statement"></a>Some true or false statement</h3><ol><li>In a bare system without virtual memory, a program can modify any part of the memory. T</li><li>Both base and bound memory system and paged memory system can run programs with larger memory than DRAM. F</li><li>The TLB should be flushed after a context switch or when any new memory is allocated. F</li><li>Increasing page table size can always lead to reduction in page faults. F</li></ol><h1 id="Lecture-24-FGPA"><a href="#Lecture-24-FGPA" class="headerlink" title="Lecture 24: FGPA"></a>Lecture 24: FGPA</h1><h3 id="FPGA-application-devices"><a href="#FPGA-application-devices" class="headerlink" title="FPGA application/devices"></a>FPGA application/devices</h3><p>• Communication devices<br>Wired and wireless routers and switches<br>• Automotive applications<br>Braking systems, traction control, airbag release systems, and cruise-control<br>applications<br>• Aerospace applications<br>Flight-control systems, engine controllers, auto-pilots and passenger in-flight<br>entertainment systems<br>• Defense systems<br>Radar systems, fighter aircraft flight-control systems, radio systems, and missile guidance systems</p><h3 id="Embedded-System-Design"><a href="#Embedded-System-Design" class="headerlink" title="Embedded System Design"></a>Embedded System Design</h3><p>– Communication devices</p><p>• Wired and wireless routers and switches</p><p>– Automotive applications</p><p>• Braking systems, traction control, airbag release systems,</p><p>and cruise-control applications</p><p>– Aerospace applications</p><p>• Flight-control systems, engine controllers, auto-pilots and</p><p>passenger in-flight entertainment systems</p><p>– Defence systems</p><p>• Radar systems, fighter aircraft flight-control systems, radio</p><p>systems, and missile guidance systems</p><h3 id="some-statements"><a href="#some-statements" class="headerlink" title="some statements"></a>some statements</h3><ol><li><p>Embedded System are designed to perform predefined functions on certain platforms.</p></li><li><p>Embedded Systems usually provide limited functions and have fewer components than Computer Systems.</p></li><li><p>ASIC can not be changed once designed, but it is suitable<br>for high-volume mass production.</p></li><li><p><img src="/2022/06/13/CA期末总结/33.png" alt=""></p></li></ol><p>FPGA vs others</p><p><img src="/2022/06/13/CA期末总结/34.png" alt=""></p><h1 id="Lecture-25-WSC"><a href="#Lecture-25-WSC" class="headerlink" title="Lecture 25: WSC"></a>Lecture 25: WSC</h1><h4 id="Warehouse-Scale-Computing"><a href="#Warehouse-Scale-Computing" class="headerlink" title="Warehouse Scale Computing"></a>Warehouse Scale Computing</h4><p>• Request-level Parallelism</p><p>e.g. Web search</p><p>• Data-level Parallelism</p><p>Static web servers use request-level Parallelism while MapReduce is Data-level Parallelism.</p><p>Inefficient load balancing in a warehouse-scale computer may lead to higher<br>energy consumptions.</p><p>– MapReduce</p><p>– Hadoop, Spark</p><p>two parallelism strategies in WSC. : Request-level, Data-level</p><h4 id="Impact-on-WSC-software"><a href="#Impact-on-WSC-software" class="headerlink" title="Impact on WSC software"></a>Impact on WSC software</h4><p>• Latency, bandwidth à Performance</p><p>– Independent data set within an array</p><p>– Locality of access within server or rack</p><p>• High failure rate à Reliability, Availability</p><p>– Preventing failures is expensive</p><p>– Cope with failures gracefully</p><p>• Varying workloads à Scalability, Availability</p><p>– Scale up and down gracefully</p><p><img src="/2022/06/13/CA期末总结/35.png" alt=""></p><ul><li>MapReduce</li></ul><p>Warehouse-Scale Computers (WSCs)</p><p>– New class of computers</p><p>– Scalability, energy efficiency, high failure rate</p><p>• Cloud Computing</p><p>– Benefits of WSC computing for third parties</p><p>– “Elastic” pay as you go resource allocation</p><p>• Request-Level Parallelism</p><p>– High request volume, each largely independent of other</p><p>– Use replication for better request throughput, availability</p><p>• MapReduce Data Parallelism</p><p>– Map: Divide large data set into pieces for independent parallel processing</p><p>– Reduce: Combine and process intermediate results to obtain final result</p><p>– Hadoop, Spark</p><h1 id="Lecture-26-Advanced-Caches"><a href="#Lecture-26-Advanced-Caches" class="headerlink" title="Lecture 26: Advanced Caches"></a>Lecture 26: Advanced Caches</h1><p>Advanced Caches:</p><ul><li>MRU is LRU</li></ul><p><img src="/2022/06/13/CA期末总结/36.png" alt=""></p><ul><li><p>Reduce the size of LLC</p></li><li><p>LLC is not monolithic</p></li></ul><h1 id="Lecture-27-I-O-DMA-Disks-Networking"><a href="#Lecture-27-I-O-DMA-Disks-Networking" class="headerlink" title="Lecture 27: I/O: DMA, Disks, Networking"></a>Lecture 27: I/O: DMA, Disks, Networking</h1><p>• Direct Memory Access (DMA)</p><p>• Disks</p><p>• Networking</p><p>Shared vs. Switch-Based Networks</p><p>Software Protocol to Send and Receive</p><h3 id="PIO-DMA"><a href="#PIO-DMA" class="headerlink" title="PIO/DMA"></a>PIO/DMA</h3><p><a href="https://blog.csdn.net/amf12345/article/details/91450694" target="_blank" rel="noopener">PIO模式和DMA模式的区别_</a></p><p>硬盘和内存之间数据传送的两种方式：一是PIO模式，二是DNA模式</p><p>  PIO模式下通过CPU来控制硬盘和内存之间的数据传输，是一种通过CPU执行I/O端口指令来进行数据的读写的数据交换模式。</p><p> DMA模式下，CPU并不全程参与数据的传送工作，只需下达命令即可。DMA方式下有控制器和通道，CPU只须向DMA控制器下达指令，让DMA控制器来处理数据的传送，数据传送完毕再把信息反馈给CPU，这样就很大程度上减轻了CPU资源占有率。DMA模式与PIO模式的区别就在于，DMA模式不过分依赖CPU，可以大大节省系统资源，二者在传输速度上的差异并不十分明显。DMA模式又可以分为Single-Word DMA（单字节DMA）和Multi-Word DMA（多字节DMA）两种，其中所能达到的最大传输速率也只有16.6MB/s。</p><p>DMA 传送方式的优先级高于程序中断，两者的区别主要表现在对CPU的干扰程度不同。程序中断请求不但使CPU停下来，而且要CPU执行中断服务程序为中断请求服务，这个请求包括了对断点和现场的处理以及CPU与外设的传送，所以CPU付出了很多的代价；DMA请求仅仅使CPU暂停一下，不需要对断点和现场的处理，并且是由DMA控制外设与主存之间的数据传送，无需CPU的干预，DMA只是借用了一点CPU的时间而已。还有一个区别就是，CPU对这两个请求的响应时间不同，对程序中断请求一般都在执行完一条指令的时钟周期末尾响应，而对DMA的请求，由于考虑它的高效性，CPU在每条指令执行的各个阶段之中都可以让给DMA使用，是立即响应。　DMA主要由硬件来实现，此时高速外设和内存之间进行数据交换不通过CPU的控制，而是利用系统总线。DMA方式是I/O系统与主机交换数据的主要方式之一，另外还有程序查询方式和中断方式。</p><p><img src="/2022/06/13/CA期末总结/37.png" alt=""></p><p>• I/O gives computers their 5 senses</p><p>• I/O speed range is 100-million to one</p><p>• Polling vs. Interrupts</p><p>• DMA to avoid wasting CPU time on data transfers</p><p>• Disks for persistent storage, replaced by flash</p><p>• Networks: computer-to-computer I/O</p><p>– Protocol suites allow networking of heterogeneous</p><p>components. Abstraction!!!</p><h1 id="Lecture-28-Dependability-and-RAID"><a href="#Lecture-28-Dependability-and-RAID" class="headerlink" title="Lecture 28: Dependability and RAID"></a>Lecture 28: Dependability and RAID</h1><p>Dependability via Redundancy</p><p><img src="/2022/06/13/CA期末总结/38.png" alt=""></p><p><img src="/2022/06/13/CA期末总结/39.png" alt=""></p><ul><li>汉明码 Parity /Hamming Error Correction Code</li></ul><p><img src="/2022/06/13/CA期末总结/40.png" alt=""><a href="https://blog.csdn.net/weixin_61985100/article/details/123300540" target="_blank" rel="noopener">汉明码解释</a></p><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p><a href="https://blog.csdn.net/kid00013/article/details/123151776" target="_blank" rel="noopener">RAID磁盘阵列详解</a></p><p>1.什么是RAID磁盘阵列<br>RAID是英文Redundant Array of Independent Disks的缩写，中文翻译过来就是“独立冗余磁盘阵列”。简单的说，RAID是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。磁盘阵列还能利用同位检查（Parity Check）的观念，在数组中任意一个硬盘故障时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。</p><p>RAID功能实现</p><p>提高IO能力,磁盘并行读写</p><p>提高耐用性,磁盘冗余算法来实现</p><p>RAID实现的方式</p><p>外接式磁盘阵列：通过扩展卡提供适配能力</p><p>内接式RAID：主板集成RAID控制器，安装OS前在BIOS里配置</p><p>软件RAID：通过OS实现</p><p>2.RAID各种级别<br>2.1 RAID 0<br>RAID 0连续以位或字节为单位分割数据，并行读/写于多个磁盘上，因此具有很高的数据传输率，但它没有数据冗余<br>RAID 0只是单纯地提高性能，并没有为数据的可靠性提供保证，而且其中的一个磁盘失效将影响到所有数据<br>RAID 0不能应用于数据安全性要求高的场合</p><p>2.2 RAID 1<br>通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据<br>当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID1可以提高读取性能<br>RAID1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据</p><p>2.3 RAID 5<br>N（N&gt;=3）块盘组成阵列，一份数据产生N-1个条带，同时还有1份校验数据，共N份数据在N块盘上循环均衡存储<br>N块盘同时读写，读性能很高，但由于有校验机制的问题，写性能相对不高<br>（N-1）/N磁盘利用率<br>可靠性高，允许坏1块盘，不影响所有数据</p><p>. RAID 3 employs the strategy of byte-level striping with single parity disk, which is inefficient to detect errors.</p><p> 2.4 RAID 6<br>N（N&gt;=4）块盘组成阵列，（N-2）/N磁盘利用率<br>与RAID5相比，RAID6增加了第二个独立的奇偶校验信息块<br>两个独立的奇偶系统使用不同的算法，即使两块磁盘同时失效也不会影响数据的使用<br>相对于RAID5有更大的“写损失，因此写性能较差</p><p>2.5 RAID 10<br>RAID10其实是RAID 1+0</p><p>N（偶数，N&gt;=4）块盘两两镜像后，再组合成一个RAID0<br>N/2磁盘利用率<br>N/2块盘同时写入，N块盘同时读取<br>性能高，可靠性高</p><table><thead><tr><th>RAID等级</th><th>需要硬盘数量</th><th>容错能力</th><th>读写能力</th></tr></thead><tbody><tr><td>RAID 0</td><td>最少1个</td><td>无</td><td>读写性能高</td></tr><tr><td>RAID 1</td><td>N（偶数）</td><td>有</td><td>读性能高、写性能低</td></tr><tr><td>RAID 5</td><td>N&gt;=3</td><td>有（最多一个坏盘）</td><td>读写性能高</td></tr><tr><td>RAID 10</td><td>N&gt;=4(偶数)</td><td>有（每组最多坏一个盘）</td><td>读写性能高</td></tr></tbody></table><h1 id="Lecture-29-Security"><a href="#Lecture-29-Security" class="headerlink" title="Lecture 29: Security"></a>Lecture 29: Security</h1><h3 id="Heartbleed"><a href="#Heartbleed" class="headerlink" title="Heartbleed"></a>Heartbleed</h3><h3 id="Flush-Reload"><a href="#Flush-Reload" class="headerlink" title="Flush+Reload"></a>Flush+Reload</h3><p>Flash memory can be used as a disk cache to a magnetic hard disk.</p><h3 id="Meltdown"><a href="#Meltdown" class="headerlink" title="Meltdown"></a>Meltdown</h3><ul><li><p>covers： Virtual Memory; Protection Levels; Instruction Pipelining; Out-of</p><p>order Execution; Speculative Execution; CPU Caching.</p></li><li><p>Keywords: Cache, timing, speculative execution, memory paging, OS pages, data of another process (4 of those keywords are enough).<br>We want to read from OS pages that hold data of other processes. Those are in our<br>Virtual Memory space in order for the OS to process them quickly. But it is forbidden for our process to read them. If we try to read them the OS will check (with an ”if”) if we are allowed to read them and thus return with a page fault. But speculative execution will nevertheless cause those pages to be read (but the process doesn’t see the result).</p></li></ul><h3 id="Spectre"><a href="#Spectre" class="headerlink" title="Spectre"></a>Spectre</h3><p><img src="/2022/06/13/CA期末总结/41.png" alt=""></p><p>• Every part of a computer can be vulnerable</p><p>– Be vigilant and attentive in designing and</p><p>programming</p><p>• Security and privacy have different presences</p><p>– More than DoS, DDoS, virus, Trojan, ransomware,</p><p>spyware, and phishing emails</p><p>• The challenges for a computer architect</p><p>– To rule out any possibility of vulnerabilities</p><p>– To achieve both high performance and security</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lecture1-Introduction&quot;&gt;&lt;a href=&quot;#Lecture1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;Lecture1: Introduction&quot;&gt;&lt;/a&gt;Lecture1: Introduction</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="CA" scheme="http://yoursite.com/categories/CS/CA/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="计算机体系结构" scheme="http://yoursite.com/tags/计算机体系结构/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记</title>
    <link href="http://yoursite.com/2022/01/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/01/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-21T23:11:08.000Z</published>
    <updated>2022-06-13T08:37:27.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><p>总之是计算机系统所使用的一种比较低级的语言，比机器语言稍微高级一点，但也属于底层语言。</p><p>写出汇编语言给计算机编译器编译，翻译成机器语言，再由cpu来执行</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>汇编语言的组成</p><ul><li>汇编指令（机器码的助记符）</li><li>伪指令（由编译器执行）</li><li>其他符号（由编译器识别）</li></ul><p>核心是<strong>汇编指令</strong></p><ol><li>存储器：CPU是计算机的核心部件，我们需要提供指令和数据给它，然后指令和数据就在存储器中存放，也就是内存。</li></ol><p>在内存或者磁盘上，指令和数据没有区别，都是由二进制书写。</p><p>如100100111011000 89D8H（数据）四位数一读，12进制</p><p>10010011101100 MOV AX,BX（指令）</p><ol start="2"><li>存储单位：存储器被划分为若干个存储单元，每个单元从0开始顺序编号。</li></ol><p>单位换算：</p><p><code>1kb=1024b,1mb=1024kb,1gb=1024mb,1tb=1024gb</code></p><p>CPU对储存器的读写需要三类信息交互</p><ul><li>存储单元的地址（地址信息）</li><li>期间的选择，读或写命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul><p>分别为地址总线，数据总线，控制总线</p><h2 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h2><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>主板上有核心器件和一些主要部件，通过三类总线相连接，这些期间有CPU,存储器，外围芯片组，扩展插槽等，扩展插槽上一般有RAM内存条和各类接口卡</p><h3 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a>接口卡</h3><p>接口卡通过总线同CPU相连接，CPU可以控制这些接口卡，从而实现CPU对外设的间接控制</p><p>存储器芯片分类：随机存储器(RAM)，只读存储器（ROM）</p><ul><li>随机存储器</li><li>装有BIOS的ROM</li><li>接口卡上的RAM</li></ul><p><img src="/2022/01/21/汇编语言学习笔记/2.jpg" alt=""></p><p><img src="/2022/01/21/汇编语言学习笔记/3.jpg" alt=""></p><p>内存空间分配</p><p><img src="/2022/01/21/汇编语言学习笔记/4.jpg" alt=""></p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>8086CPU有14个寄存器，为AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</p><p>8086CPU所有的寄存器都是16位的，可以存放两个字节</p><p>AX,BX,CX,DX通常用来存放一般性数据被称为通用寄存器</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>最大可以存放2^16（4E20H）左右</p><p><img src="/2022/01/21/汇编语言学习笔记/1.jpg" alt=""></p><p>8086CPU的AX,BX,CX,DX这4个寄存器都分为两个独立使用的8位寄存器来用：</p><ul><li>AX可分为AH和AL</li><li>BX可分为BH和BL</li><li>CX可分为CH和CL</li><li>DX可分为DH和DL</li></ul><p><img src="/2022/01/21/汇编语言学习笔记/5.jpg" alt=""></p><p>AL低8位，AH高8位</p><p><strong>自在寄存器中的存储</strong></p><p>字节：byte 字：word，一个字由高位字节和低位字节组成</p><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><table><thead><tr><th>汇编指令</th><th>控制CPU完成的操作</th><th>用高级语言的语法描述</th></tr></thead><tbody><tr><td>mov ax,18</td><td>将18送入AX</td><td>AX=18</td></tr><tr><td>mov ah,78</td><td>将78送入AH</td><td>AH=78</td></tr><tr><td>add ax,8</td><td>AX中数值加8</td><td>AX=AX+8</td></tr><tr><td>mov ax,bx</td><td>BX送入AX</td><td>AX=BX</td></tr><tr><td>add ax,bx</td><td>AX加BX加后存在AX中</td><td>AX=AX+BX</td></tr></tbody></table><p>16位结构的CPU</p><ul><li>运算器一次最多可以处理16位数据</li><li>寄存器最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><p><img src="/2022/01/21/汇编语言学习笔记/6.jpg" alt=""></p><p>地址加法器采用物理地址=段地址x16+偏移地址，将两个16位地址合成一个20位的物理地址</p><p>每一个内存单元都有自己的物理地址</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>CS,DS,SS,ES4个</p><p><img src="/2022/01/21/汇编语言学习笔记/7.jpg" alt=""></p><p>CS储存短地址，IP为偏移地址，经过地址加法器后读取20000H的指令B8 23 01，通过数据总线传给执行控制器，使AX的值变为0123H，之后IP的值自动+3，因为指令长度为3，从此不断读取后面的指令</p><h3 id="内存访问"><a href="#内存访问" class="headerlink" title="内存访问"></a>内存访问</h3><p>字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元存放低位字节。</p><p>8086CPU中有一个DS寄存器，用来存放要访问的数据的段地址</p><pre class="line-numbers language-assembly"><code class="language-assembly">mov bx,1000Hmov ds,bxmov al,[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>[…]表示一个内存单元，…表示内存单元的偏移地址，1000H表示段地址</p><p>由于8086CPU不支持将数据直接送入段寄存器的操作，所以必须先把数据传给一个寄存器，再把这个数据传给ds寄存器</p><p>更形象理解寄存器</p><pre class="line-numbers language-assembly"><code class="language-assembly">mov ax,1000Hmov ds,axmov ax,[0]mov bx,[2]mov cx,[1]add bx,[1]add cx,[2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/01/21/汇编语言学习笔记/9.jpg" alt=""></p><p><img src="/2022/01/21/汇编语言学习笔记/8.jpg" alt=""></p><p><code>mov,add,sub</code>三种指令的对象既可以是寄存器，数据也可以使内存单元</p><p>数据段</p><h1 id="RISC-V指令"><a href="#RISC-V指令" class="headerlink" title="RISC-V指令"></a>RISC-V指令</h1><p>在RV32中，words为32bit</p><h2 id="基础指令-1"><a href="#基础指令-1" class="headerlink" title="基础指令"></a>基础指令</h2><p>RISC-V 寄存器编号为0-31，其中x0就是0</p><pre class="line-numbers language-assembly"><code class="language-assembly">add x1,x2,x3 #x1=x2+x3sub x1,x2,x3 #x1=x2-x3addi x1,x2,-10 #x1=x2-10,有数字的时候用这个add x1,x2,x0 #x1=x2,x0 is hard-wired to value 0add x0,x1,x2 #means nothing is No-Opmv rd,rs #addi rd,rs,0li rd,13# addi,rd,x0,13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="load，store指令"><a href="#load，store指令" class="headerlink" title="load，store指令"></a>load，store指令</h2><pre class="line-numbers language-assembly"><code class="language-assembly">lw x10,12(x15) # Reg x10 gets A[3]add x10,x13,x10 # a=b+A[3]sw x10,40(x15) # A[10]=b+A[3]lb x10,3(x11) # unsigned byte contents of register x11 is copied to the low byte position of register x10.# 不存在no unsigned store byte sbu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>12指代12bytes，12/4=3就是第三位的数，一位4个字节</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><img src="/2022/01/21/汇编语言学习笔记/10.jpg" alt=""></p><p>对于addi加的数最大值FF000000,</p><pre class="line-numbers language-assembly"><code class="language-assembly">slli x11,x12,2 #x11=x12<<2 2进制中左移2位srli x11,x12,2#x11=x12>>2srai x10,x10,4#x10=-25,x10=-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2022/01/21/汇编语言学习笔记/14.jpg" alt=""></p><p>变量名</p><pre class="line-numbers language-assembly"><code class="language-assembly">a0-a7#变量t0-t6#临时变量 s0-s11#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><pre class="line-numbers language-assembly"><code class="language-assembly">beq register1, register2, L1#if (value in register1) == (value in register2) go to statement labeled L1bne register1, register2, L1#if (value in register1) != (value in register2) go to statement labeled L1bne x13,x14,Exit #if(i==j)add x10,x11,x12#a=b+cExit:bne x13,x14,Exit #if(i==j)add x10,x11,x12#a=b+cj Exit #elseElse: sub x10,x11,x12 #a=b-cExit:blt reg1,reg2,label#if reg1<reg2 go to statement labelbltu reg1,reg2,label#if reg1<reg2 go to statement label unsigned integersbge reg1,reg2,label#if reg1>=eg2 go to statement labelbgeu reg1,reg2,label#if reg1>=reg2 go to statement labelunsigned integers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>汇编和C对照</p><p>先要调用内存，再加减乘除</p><p><img src="/2022/01/21/汇编语言学习笔记/11.jpg" alt=""></p><p><img src="/2022/01/21/汇编语言学习笔记/12.jpg" alt=""></p><p>C语言中内存分配</p><p><img src="/2022/01/21/汇编语言学习笔记/13.jpg" alt=""></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Unconditional branches (jumps):<code>j, jr</code></p><p>Functions called with<code>jal</code>, return with <code>jr ra</code></p><p>Calle<code>R</code>: the calling function</p><p>Calle<code>E</code>: the function being called</p><p><img src="/2022/01/21/汇编语言学习笔记/16.jpg" alt=""></p><p>关于内存分配</p><p><img src="/2022/01/21/汇编语言学习笔记/17.jpg" alt=""></p><h2 id="汇编指令的机器编码"><a href="#汇编指令的机器编码" class="headerlink" title="汇编指令的机器编码"></a>汇编指令的机器编码</h2><p><img src="/2022/01/21/汇编语言学习笔记/18.jpg" alt=""></p><p>6种指令格式</p><p><img src="/2022/01/21/汇编语言学习笔记/19.jpg" alt=""></p><h3 id="R指令"><a href="#R指令" class="headerlink" title="R指令"></a>R指令</h3><p><img src="/2022/01/21/汇编语言学习笔记/20.jpg" alt=""></p><p><code>add rd, rs1, rs2</code></p><h3 id="I指令"><a href="#I指令" class="headerlink" title="I指令"></a>I指令</h3><p><img src="/2022/01/21/汇编语言学习笔记/21.jpg" alt=""></p><p><code>imm[11:0]</code>代表12位数字，是需要立即指令的数字叫做immediate</p><p><code>shamtp[]</code>代表位移的位数</p><p><code>addi rd, rs1, imm</code></p><h3 id="Load指令"><a href="#Load指令" class="headerlink" title="Load指令"></a>Load指令</h3><p><img src="/2022/01/21/汇编语言学习笔记/22.jpg" alt=""></p><p><code>lw rd , imm (rs1)</code></p><h3 id="S指令"><a href="#S指令" class="headerlink" title="S指令"></a>S指令</h3><p><img src="/2022/01/21/汇编语言学习笔记/23.jpg" alt=""></p><p><code>sw rs2, offset (rs1)</code> <code>Imm[11:5]</code>存的是高位，<code>imm[4:0]</code>存的是低位</p><p><img src="/2022/01/21/汇编语言学习笔记/24.jpg" alt=""></p><h3 id="B指令"><a href="#B指令" class="headerlink" title="B指令"></a>B指令</h3><p><img src="/2022/01/21/汇编语言学习笔记/25.jpg" alt=""></p><p><img src="/2022/01/21/汇编语言学习笔记/26.jpg" alt=""></p><p><img src="/2022/01/21/汇编语言学习笔记/27.jpg" alt=""></p><h3 id="U指令"><a href="#U指令" class="headerlink" title="U指令"></a>U指令</h3><p><img src="/2022/01/21/汇编语言学习笔记/28.jpg" alt=""></p><p><code>lui rd, u-imm</code> <code>Auipc rd, 0</code></p><h3 id="J指令"><a href="#J指令" class="headerlink" title="J指令"></a>J指令</h3><p><img src="/2022/01/21/汇编语言学习笔记/29.jpg" alt=""></p><p><code>j Label = jal x0, Label</code> <code>jal ra, FuncName</code></p><h3 id="JALR指令"><a href="#JALR指令" class="headerlink" title="JALR指令"></a>JALR指令</h3><p><img src="/2022/01/21/汇编语言学习笔记/30.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇编语言&quot;&gt;&lt;a href=&quot;#汇编语言&quot; class=&quot;headerlink&quot; title=&quot;汇编语言&quot;&gt;&lt;/a&gt;汇编语言&lt;/h1&gt;&lt;p&gt;总之是计算机系统所使用的一种比较低级的语言，比机器语言稍微高级一点，但也属于底层语言。&lt;/p&gt;
&lt;p&gt;写出汇编语言给计算机编</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="ASSEMBLY_LANGUAGE" scheme="http://yoursite.com/categories/CS/ASSEMBLY-LANGUAGE/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="汇编语言" scheme="http://yoursite.com/tags/汇编语言/"/>
    
  </entry>
  
  <entry>
    <title>信号与系统学习笔记</title>
    <link href="http://yoursite.com/2021/11/11/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/11/11/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-12T03:37:22.000Z</published>
    <updated>2022-01-21T09:17:43.290Z</updated>
    
    <content type="html"><![CDATA[<p>大二复习</p><hr><h1 id="基础数学"><a href="#基础数学" class="headerlink" title="基础数学"></a>基础数学</h1><p><img src="/2021/11/11/信号与系统学习笔记/1.png" alt=""></p><p>$e^{j\theta}=cos(\theta)+jsin(\theta)$</p><p>$cos(\theta)=\frac{e^{j\theta}+e^{-j\theta }}{2}$</p><p>$sin(\theta)=\frac{e^{j\theta}-e^{-j\theta }}{2j}$<br>$$<br>\sum_{n=0}^{\infty}{(z_0)^n=\frac{1}{1-z_0}} ,|z_0|&lt;1<br>$$</p><h1 id="连续信号与离散信号"><a href="#连续信号与离散信号" class="headerlink" title="连续信号与离散信号"></a>连续信号与离散信号</h1><p><strong>信号的分类</strong><br>$$<br>E_{\infty}=\int_{-\infty}^{\infty}|x(t)|^2dt<br>=\sum_{n=-\infty}^{\infty}|x[n]|^2<br>$$</p><p>$$<br>P_{\infty}=\lim_{N \rightarrow \infty}\frac{1}{2T}\int_{-T}^{T}|x(t)|^2dt=<br>\lim_{N \rightarrow \infty}\frac{1}{2N+1}\sum_{-N}^{N}|x(t)|^2<br>$$</p><ul><li>有限能量信号（Finite‐energy signal）:$E_{\infty}&lt;\infty,P_{\infty}=0$</li><li>有限功率信号（Finite‐power signal）：$P_{\infty}&lt;\infty,E_{\infty}=\infty$</li><li>无限功率能量信号（Infinite energy &amp; power signal ）：$P_{\infty}\rightarrow\infty,E_{\infty}\rightarrow\infty$</li></ul><p><strong>信号的偶部与奇部</strong></p><p>$x(t)=x_e(t)+x_o(t)$</p><p>$x_e(t)=E_v[x(t)]=1/2[x(t)+x(-t)]$</p><p>$x_o(t)=O_d[x(t)]=1/2[x(t)-x(-t)]$</p><p><strong>信号的频率与周期</strong></p><p>对于连续信号$x(t)=e^{jw_0t}$，有$\frac{2\pi}{|k|w_0}=\frac{T_0}{|k|}$</p><p>对于离散信号$x[n]=e^{jw_0n}$有$\frac{w_0}{2\pi}=\frac{m}{N}$，周期满足$N=m(2\pi/w_0)$ 整数</p><p>区别就是离散信号N一定为正整数</p><h2 id="基础信号"><a href="#基础信号" class="headerlink" title="基础信号"></a>基础信号</h2><p>单位脉冲信号与单位阶跃信号</p><p>离散时间的定义</p><p><img src="/2021/11/11/信号与系统学习笔记/2.png" alt=""></p><p>一些性质     </p><ul><li>$\delta[n]=u[n]-u[n-1]$</li><li><p>$u[n]=\sum_{m=\infty}^{n}\delta[m]$</p></li><li><p>$x[n]\delta[n-n_0]=x[n_0]\delta[n-n_0]$</p></li></ul><p>连续时间的定义：</p><p><img src="/2021/11/11/信号与系统学习笔记/3.png" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/4.png" alt=""></p><p>一些性质：</p><ul><li>$u(t)=\int_{-\infty}^{t}\delta(\tau )d\tau$</li><li>$\delta(t)=\frac{du(t)}{dt}$</li><li>$x(t)\delta(t-t_0)=x(t_0)\delta(t-t_0)$</li></ul><h2 id="基本信号的性质"><a href="#基本信号的性质" class="headerlink" title="基本信号的性质"></a>基本信号的性质</h2><ul><li><p>记忆系统：输出决定于现在和以前的输入，（不管将来）非记忆就是只和现在状态相关</p><p>例子：$y[n]=\sum_{k=-\infty}^{n}x[k],y[n]=x[n-1]$</p></li><li><p>可逆性：不同输入对应不同输出</p><p>例子：$y[n]=0,y(t)=x^2(t)$不可逆</p></li><li><p>因果性：任何时间的输出都<strong>只由</strong>现在和以前的<strong>状态</strong>决定，注意和记忆区别</p><p>例子：$y[n]=x[n]-x[n+1],y(t)=x(t+1)$非因果</p></li><li><p>稳定性：输入有界，则输出有界一定稳定</p></li><li><p>时不变性：时间平移造成相同的输出平移</p><p><img src="/2021/11/11/信号与系统学习笔记/5.png" alt=""></p></li><li><p>线性：$x_1(t)-&gt;y_1(t),x_2(t)-&gt;y_2(t)$有$ax_1(t)+bx_2(t)-&gt;ay_1(t)+by_2(t)$</p></li></ul><p>易错例子：</p><p>$y(t)=\frac{dx(t)}{dt}=\lim_{\Delta t \rightarrow 0}\frac{x(t+\Delta t)-x(t)}{\Delta t}$</p><p>是记忆，不可逆，非因果，不稳定，时不变，非线性系统（因果用定义判断）</p><h1 id="卷积-Convolution"><a href="#卷积-Convolution" class="headerlink" title="卷积(Convolution)"></a>卷积(Convolution)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>已知x,y系统的关系，求$h(t)$就是把$x$换成$\delta$</p><p><strong>离散时间</strong></p><p><img src="/2021/11/11/信号与系统学习笔记/6.png" alt=""></p><p>例子：</p><p><img src="/2021/11/11/信号与系统学习笔记/7.png" alt=""></p><p><strong>连续时间</strong></p><p>$\int_{-\infty}^{\infty}x(\tau)h(t-\tau)d\tau=x(t)*h(t)$</p><p>同理</p><p><img src="/2021/11/11/信号与系统学习笔记/9.png" alt=""></p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p><strong>核心：以$t/n$的大小分类讨论</strong></p><p>一般习惯用画图法，画出$h(t-\tau)$的图来和$x(\tau)$相乘分类讨论</p><p>例子如下：</p><p><img src="/2021/11/11/信号与系统学习笔记/8.png" alt=""></p><p>若$h(t)=f(-t+a)$则画图时候还是处理成$\tau$不用取反，位移看成$h(\tau-(t-a))$，于是对应的位移坐标是$t-a$</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>以连续时间为例子，离散时间同理</p><ul><li><p>交换律： $x(t)<em>h(t)=h(t)</em>x(t)$</p></li><li><p>分配律： $x(t)<em>(h_1(t)+h_2(t))=x(t)</em>h_1(t)+x(t)*h_2(t)$</p></li><li><p>结合律： $x(t)<em>(h_1(t)</em>h_2(t))=(x(t)<em>h_1(t))</em>h_2(t))$ </p></li><li><p>当且仅当$h(t)=0,\forall t \neq 0$，该系统是没有记忆的很好理解因为$x(t)*h(t-\tau)$ 要保证$h(t-\tau)$只有$h(t)$有值</p></li><li><p>如果$h_0(t)*h_1(t)=\delta(t)$则$h_1(t)$是$h_0(t)$的逆系统</p><p>例子：$y(t)=x(t-t_0)$逆系统表达$y_1(t)=x(t+t_0)$因为 $\delta(t-t_0)<em>\delta(t+t_0)=\delta(t)$对应$h(t)</em>h_1(t)=\delta(t)$ </p></li><li><p>当$h(t)=0 ,t&lt;0$时，$y(t)=x(t)*h(t)$系统是因果的</p><p>这个条件相当于$h(t-\tau)=0,t-\tau &lt;0$ </p></li><li><p>当$h(t)$绝对可积，则该系统稳定$\int_{-\infty}^{\infty}|h(\tau)|d\tau &lt; \infty$</p></li><li><p>单位阶跃响应$s(t)$就是把$x(t)=u(t)$计算得到的值，即$s(t)=\int_{-\infty}^th(\tau)d\tau$</p></li></ul><h2 id="差分与求导"><a href="#差分与求导" class="headerlink" title="差分与求导"></a>差分与求导</h2><p>本质好像就是求微分方程，先根据形式猜测特解，再找出齐次通解，最后用条件求解</p><p><img src="/2021/11/11/信号与系统学习笔记/10.png" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/11.png" alt=""></p><p><strong>注意课件上最后带入的时候写错了，负号消失了</strong></p><p>至于差分就是等比\等差数列求解</p><p>然后有一个画图表示的</p><p><img src="/2021/11/11/信号与系统学习笔记/12.png" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/13.png" alt=""></p><h1 id="傅里叶系数-Fourier-Series-Representation"><a href="#傅里叶系数-Fourier-Series-Representation" class="headerlink" title="傅里叶系数(Fourier Series Representation )"></a>傅里叶系数(<strong>Fourier</strong> <strong>Series</strong> <strong>Representation</strong> )</h1><h2 id="前置信息"><a href="#前置信息" class="headerlink" title="前置信息"></a>前置信息</h2><p>当输入是负数信号时候输出的形式，引入LTI系统中$H(s)$的概念</p><p><img src="/2021/11/11/信号与系统学习笔记/14.png" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/15.png" alt=""></p><p>离散时间同理</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>前面提到输入是复数信号的输出形式有一种比较便捷的表达形式，那么如何将任意$x(t)$改写成复数信号的线性组合呢，我们引入傅里叶级数</p><p>连续时间：<br>$$<br>x(t)=\sum_{k=-\infty}^{\infty}a_ke^{jk(2\pi /T_0)t}<br>$$<br>这里的$a_k$就是傅里叶级数，$w_0=2\pi/T_0$</p><p>若$x(t)$是实信号，有另一个表达方法</p><p><img src="/2021/11/11/信号与系统学习笔记/16.png" alt=""></p><p>利用的是$a_k=a_{-k}^*$的性质</p><p>离散时间：<br>$$<br>x[n]=\sum_{k=<n>}a_ke^{jk(2\pi/N)n}<br>$$</n></p><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>已知$x(t)$如何求$a_k$，有公式<br>$$<br>a_k=\frac{1}{T}\int_Tx(t)e^{-jkw_0t}dt<br>$$<br>其中<br>$$<br>a_0=\frac{1}{T}\int_Tx(t)dt<br>$$<br>离散时间：<br>$$<br>a_k=\frac{1}{N}\sum_{k=<n>}x[n]e^{-jk(2\pi/N)n}<br>$$</n></p><p><strong>ps:写答案的时候，$a_k=0$的情况也要写出来,不能不写</strong></p><p>例子：常见信号的傅里叶级数，方波，记下来比较好</p><p><img src="/2021/11/11/信号与系统学习笔记/17.png" alt=""></p><p>离散时间的方波：</p><p><img src="/2021/11/11/信号与系统学习笔记/19.png" alt=""></p><h2 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h2><p>不是所有信号都有傅里叶级数，若级数趋于无穷则无法准确表示该信号，故要判断$x(t)$的收敛性</p><ul><li>条件1：有限能量条件$\int_T|x(t)|^2dt&lt;\infty$，则可以用傅里叶级数</li><li>条件2：迪利克雷条件：1.绝对可积$\int_T|x(t)|dt&lt;\infty$2.在任意有限时间，$x(t)$有界，满足有限个的最大最小值点。3.任意有限时间，只有有限的点是不连续的。</li></ul><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>仍然以连续时间为例子，以下表示傅里叶级数，性质将简化处理</p><p><img src="/2021/11/11/信号与系统学习笔记/18.png" alt=""></p><ul><li><p>线性：$Ax(t)+By(t)\to c_k=Aa_k+Bb_k$</p></li><li><p>时间平移：$x(t-t_0)\to b_k=e^{-jkw_0t_0}a_k$</p></li><li><p>时间反转：$x(-t)\to b_k=a_{-k}$</p></li><li><p>时间翻倍：$x(\alpha t)\to b_k=a_k,w=\alpha w_0$只改变频率</p></li><li><p>相乘：$z(t)=x(t)y(t)\to h_k=\sum_{l=-\infty}^{\infty} a_lb_{k-l}$</p></li><li><p>共轭：$z(t)=x^<em>(t)\to b_k=a^</em>_{-k}$</p><p>$x(t)$实信号，$a_k^*=a_{-k}\to |a_k|=|a_{-k}|$</p><p>$x(t)$实且偶信号，$a_k=a_{-k}\to a_k=a_k^*\to a_k$实且偶</p><p>$x(t)$实且奇信号，$a_k=-a_{-k}\to a_k=-a_k^*\to a_k$纯虚且奇</p></li><li><p>求导与积分：$dx(t)/dt \to jkw_0a_k;\int_{-\infty}^{t}x(\tau)d\tau \to a_k/(jkw_0)$</p></li><li><p>频率移动：$e^{jMw_0t}x(t) \to a_{k-M}$</p></li><li><p>卷积：$\int_Tx(\tau)y(t-\tau)d\tau \to Ta_kb_k$</p></li><li><p>帕斯瓦尔关系式：$\frac{1}{T}\int_T|x(t)|^2dt=\sum_{k=-\infty}^{\infty}|a_k|^2$</p></li></ul><h2 id="傅里叶级数与LTI系统"><a href="#傅里叶级数与LTI系统" class="headerlink" title="傅里叶级数与LTI系统"></a>傅里叶级数与LTI系统</h2><p>与part1结合，我们可以利用傅里叶级数算出输出信号的傅里叶级数表达形式</p><p><img src="/2021/11/11/信号与系统学习笔记/20.png" alt=""></p><p><strong>注意其中$w=kw_0$</strong> 带数据不能带错了</p><h1 id="傅里叶变换-Fourier-Transform"><a href="#傅里叶变换-Fourier-Transform" class="headerlink" title="傅里叶变换( Fourier Transform)"></a>傅里叶变换( <strong>Fourier</strong> Transform)</h1><p>傅里叶级数表示的都是周期信号，那每周期信号如何处理，我们引入傅里叶变换。</p><p>傅里叶变换的思路是将没有周期的信号扩展成周期信号，再对这个周期信号求傅里叶级数，因为原信号没有周期可以引入$X(jw)=\int_{-\infty}^{\infty}x(t)e^{-jwt}dt$</p><p><img src="/2021/11/11/信号与系统学习笔记/21.png" alt=""></p><p>故得到<br>$$<br>X(jw)=\int_{-\infty}^{\infty}x(t)e^{-jwt}dt<br>$$</p><p>$$<br>x(t)=\frac{1}{2\pi}\int_{-\infty}^{\infty}X(jw)e^{jwt}dw<br>$$</p><p>$X(jw)$称作频谱(spectrum)</p><p>对比FT和FS有$a_k=\frac{1}{T}X(jw),w=kw_0 $</p><p>关于收敛性和上述一致，不再重复讨论</p><p><strong>一些典型例子</strong></p><p>指数型：</p><p><img src="/2021/11/11/信号与系统学习笔记/22.png" alt=""></p><p>绝对值指数型：</p><p><img src="/2021/11/11/信号与系统学习笔记/23.png" alt=""></p><p>方波型：</p><p><img src="/2021/11/11/信号与系统学习笔记/24.png" alt=""></p><h2 id="周期信号的傅里叶变换"><a href="#周期信号的傅里叶变换" class="headerlink" title="周期信号的傅里叶变换"></a>周期信号的傅里叶变换</h2><p>寻找$a_k$和$X(jw)$的关系</p><p><img src="/2021/11/11/信号与系统学习笔记/25.png" alt=""></p><p>反正得到结论是<br>$$<br>X(jw)=\sum_{K=-\infty}^{\infty}a_k2\pi\delta(w-kw_0)<br>$$<br>还是方波的例子：</p><p><img src="/2021/11/11/信号与系统学习笔记/26.png" alt=""></p><p>正弦和余弦信号：</p><p><img src="/2021/11/11/信号与系统学习笔记/27.png" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/28.png" alt=""></p><h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><p>和傅里叶级数有很多类似性质，以下为简化记录</p><p><img src="/2021/11/11/信号与系统学习笔记/29.png" alt=""></p><ul><li><p>线性：$ax(t)+by(t)\to aX(jw)+bY(jw)$</p></li><li><p>时间平移：$x(t-t_0)\to e^{-jkwt_0}X(jw)$</p></li><li><p>时间反转：$x(-t)\to X(-jw)$</p></li><li><p>共轭：$z(t)=x^<em>(t)\to X^</em>(-jw)$</p><p>$x(t)$偶信号，$X(jw)=X(-jw)$，$x(t)$实信号，$X(-jw)=X^*(jw)$</p><p>$x(t)$实且偶信号，$X(j w)$实且偶</p><p>$x(t)$实且奇信号，$X(j w)$纯虚且奇</p><p>$x(t)$实信号，$E_v[x(t)] \to R_e[X(jw)],O_d[x(t)]\to j I_m[X(jw)]$</p></li><li><p>求导与积分：$dx(t)/dt \to jwX(jw);\int_{-\infty}^{t}x(\tau)d\tau \to \frac{1}{jw}X(jw)+\pi X(0)\delta(w)$</p></li><li><p>翻倍：$x(at)\to\frac{1}{|a|}X(jw/a),a \neq 0$</p></li><li><p>帕斯瓦尔关系式：$\int_{-\infty}^{\infty}|x(t)|^2dt=\frac{1}{2\pi}\int_{-\infty}^{\infty}|X(jw)|^2dw$</p></li><li><p><strong>对偶性</strong>：</p><p>已知$x(t)=\frac{1}{2\pi}\int_{-\infty}^{\infty}X(jw)e^{jwt}dw$</p><p>$x(jw)=\frac{1}{2\pi}\int_{-\infty}^{\infty}X(t)e^{jwt}dt$</p><p>$x(-jw)=\frac{1}{2\pi}\int_{-\infty}^{\infty}X(t)e^{-jwt}dt$</p></li></ul><p>例子：</p><p><img src="/2021/11/11/信号与系统学习笔记/30.png" alt=""></p><h3 id="卷积性质"><a href="#卷积性质" class="headerlink" title="卷积性质"></a>卷积性质</h3><p><img src="/2021/11/11/信号与系统学习笔记/31.png" alt=""></p><p>一个比较特殊的$h(t)=\int_{-\infty}^t\delta(\tau)d\tau=u(t)$</p><p>$H(jw)=1/jw+\pi \delta(w)$</p><h3 id="乘积性质"><a href="#乘积性质" class="headerlink" title="乘积性质"></a>乘积性质</h3><p><img src="/2021/11/11/信号与系统学习笔记/32.png" alt=""></p><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><p>一阶导数，两边都做傅里叶变换来求</p><p><img src="/2021/11/11/信号与系统学习笔记/33.png" alt=""></p><p>二阶的</p><p><img src="/2021/11/11/信号与系统学习笔记/34.png" alt=""></p><h2 id="相位与相角"><a href="#相位与相角" class="headerlink" title="相位与相角"></a>相位与相角</h2><p>$\angle H(jw)$计算方法，基本分数形式就是分母的相角减去分子的相，若有乘法就是加</p><p>$H(jw)=|H(jw)|e^{j\angle H(jw)}$</p><p>例子：$ H(jw)=\frac{jw+2}{(jw)^2+4(jw)+3},$ $tan \theta=\frac{w}{2}-\frac{4w}{3-w^2}$</p><p>$arg(H(jw))=arctan[\frac{w}{2}-\frac{4w}{3-w^2}]$</p><p>group delay：$\tau (w)=-\frac{d}{dw}[\angle H(jw)]$</p><h3 id="Log-Magnitude-and-Bode-Plots"><a href="#Log-Magnitude-and-Bode-Plots" class="headerlink" title="Log-Magnitude and Bode Plots"></a>Log-Magnitude and Bode Plots</h3><p>在卷积中相角的应用</p><p>$y(t)=x(t)*h(t)$ $Y(jw)=H(jw)X(jw)=|H(jw)||X(jw)|e^{j(\angle H(jw) + \angle X(jw))}$</p><p>$\angle Y(jw)= \angle H(jw)+ \angle X(jw)$两边取log</p><p>$log|Y(jw)|=log|H(jw)|+log|X(jw)|$</p><p>波得图(Bode plot)：一阶系统</p><p><img src="/2021/11/11/信号与系统学习笔记/35.png" alt=""></p><p>二阶系统</p><p><img src="/2021/11/11/信号与系统学习笔记/36.png" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/37.png" alt=""></p><h1 id="信号的采样与恢复"><a href="#信号的采样与恢复" class="headerlink" title="信号的采样与恢复"></a>信号的采样与恢复</h1><p><img src="/2021/11/11/信号与系统学习笔记/38.png" alt=""></p><p>上图就是用一个离散的周期信号去采样$x(t)$的过程</p><p>但若$x(t)$是一个非周期的又带限的信号</p><p><img src="/2021/11/11/信号与系统学习笔记/39.png" alt=""></p><p>$X_p(jw)=\frac{1}{2\pi}X(jw)*P(jw)$</p><p>$P(jw)=\frac{2\pi}{T}\sum_{k=-\infty}^{\infty}\delta(w-kw_s)=\frac{2\pi}{T} \sum_{k=-\infty}^{\infty} \delta(w-k\frac{2\pi}{T})$</p><p>$X_p(jw)=\frac{1}{2\pi}\sum_{k=-\infty}^{\infty}X(j(w-kw_s))$</p><p>观察得知，当$w_m&lt;w_s+w_m$时候，信号采样的hi和不会出现重叠，若$w_m&gt;w_s-w_m$信号会重复被采样，故部分信号缺失造成误差</p><p>故对有带限的信号，采样频率要满足$w_s&gt;2w_m$这也就是采样定理</p><h2 id="零阶保持"><a href="#零阶保持" class="headerlink" title="零阶保持"></a>零阶保持</h2><p><img src="/2021/11/11/信号与系统学习笔记/40.png" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/41.png" alt=""></p><p>这是一种采样后恢复的方式</p><p><img src="/2021/11/11/信号与系统学习笔记/43.png" alt=""></p><h2 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h2><p><img src="/2021/11/11/信号与系统学习笔记/42.png" alt=""></p><p>$h(t)=\frac{Tw_c}{\pi} \frac{sinw_ct}{w_ct}$</p><p>$x_r(t)=\sum_{n=-\infty}^{\infty}x(nT)\frac{Tw_c}{\pi} \frac{sinw_c(t-nT)}{w_c(t-nT)}$</p><h2 id="一阶保持"><a href="#一阶保持" class="headerlink" title="一阶保持"></a>一阶保持</h2><p><img src="/2021/11/11/信号与系统学习笔记/44.png" alt=""></p><p>$H(jw)=\frac{1}{T}[\frac{sin(wT/2)}{w/2}]^2$</p><h2 id="混叠-Aliasing"><a href="#混叠-Aliasing" class="headerlink" title="混叠(Aliasing)"></a>混叠(Aliasing)</h2><p>当$w_s&lt;2w_m$时，取样后会出现混叠现象</p><h2 id="离散与连续时间信号转化"><a href="#离散与连续时间信号转化" class="headerlink" title="离散与连续时间信号转化"></a>离散与连续时间信号转化</h2><h3 id="C-D-conversion"><a href="#C-D-conversion" class="headerlink" title="C/D conversion"></a>C/D conversion</h3><p><img src="/2021/11/11/信号与系统学习笔记/45.png" alt=""></p><p>$x_p(t)=\sum_{n=-\infty}^{\infty}x(nT)\delta(t-nT)$</p><p>$x_d[n]=x_c(nT)$</p><p>推理过程：</p><p>$X_d(e^{j\Omega})=\sum_{-\infty}^{\infty}x_d[n]e^{-jn\Omega}=\sum_{-\infty}^{\infty}x_c(nT)e^{-jn\Omega}$</p><p>$x_p(t)=\sum_{n=-\infty}^{\infty}x_c(nT)\delta(t-nT) \rightarrow X_p(jw)=\sum_{n=-\infty}^{\infty}x_c(nT)e^{-jwnT}$</p><p>如果$w=\Omega /T,X_d(e^{j\Omega})=X_p(j\Omega/T)$</p><p>$X_d(e^{j\Omega})=1/T\sum_{k=-\infty}^{\infty}X(j(\Omega-2k\pi)/T)$</p><h3 id="D-C-conversion"><a href="#D-C-conversion" class="headerlink" title="D/C conversion"></a>D/C conversion</h3><p><img src="/2021/11/11/信号与系统学习笔记/46.png" alt=""></p><p>$y_c(t)=y[n/T]$</p><h3 id="全系统"><a href="#全系统" class="headerlink" title="全系统"></a>全系统</h3><p><img src="/2021/11/11/信号与系统学习笔记/47.png" alt=""></p><h2 id="离散信号的采样"><a href="#离散信号的采样" class="headerlink" title="离散信号的采样"></a>离散信号的采样</h2><p><img src="/2021/11/11/信号与系统学习笔记/48.png" alt=""></p><p>$X_p(e^{jw})=1/N\sum_{k=0}^{N-1}X(e^{j(w-kw_s)})$</p><h2 id="离散信号的恢复"><a href="#离散信号的恢复" class="headerlink" title="离散信号的恢复"></a>离散信号的恢复</h2><p>$x_r[n]=\sum_{k=-\infty}^{\infty}x[kN]\frac{Nw_c}{\pi}\frac{sinw_c(n-kN)}{w_c(n-kN)}$</p><p><img src="/2021/11/11/信号与系统学习笔记/1.jpg" alt=""></p><p>向下取样(SRI)因子M： $y[n]=x[Mn]$</p><h1 id="拉普拉斯变换-The-Laplace-transform"><a href="#拉普拉斯变换-The-Laplace-transform" class="headerlink" title="拉普拉斯变换(The Laplace transform)"></a>拉普拉斯变换(<strong>The</strong> <strong>Laplace</strong> transform)</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>傅里叶变换的拓展版</p><p>$x(t)\rightarrow X(s),X(s)=\int_{-\infty}^{\infty}x(t)e^{-st}dt,s=\sigma +jw$</p><p>当$s=jw$，就是傅里叶变换</p><h2 id="定义域，零点，极点"><a href="#定义域，零点，极点" class="headerlink" title="定义域，零点，极点"></a>定义域，零点，极点</h2><p>这个是拉普拉斯变换区别于傅里叶变换特有的</p><p>定义域主要是看s的实部取值范围记为$Re[s]$</p><p>$X(s)=\frac{N(s)}{D(s)}$零点就是分子等于零时候s取值，极点是分母等于0的时候s取值</p><p>定义域一定不包括极点，零点无所谓</p><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><ol><li><p>The ROC of 𝑋 𝑠 consists of strips parallel to the 𝑗𝜔‐axis in the 𝑠‐p</p><p>$\int_{-\infty}^{\infty}|x(t)|e^{\sigma t}dt&lt;\infty$ 用绝对可积来求定义域</p></li><li><p>For rational Laplace transforms, the ROC does not contain any poles.极点一定不在定义域之内</p></li><li>If $x(t)$is of finite duration and is absolutely integrable, then the ROC is the entire s-plane.绝对可积则包含整个s平面</li><li>后面关于ROC和极点的性质不多赘述</li></ol><h2 id="反拉普拉斯变换"><a href="#反拉普拉斯变换" class="headerlink" title="反拉普拉斯变换"></a>反拉普拉斯变换</h2><p>根据$X(s)$求$x(t)$</p><p>$x(t)=\frac{1}{2\pi j}\int_{\sigma-j\infty}^{\sigma+j\infty}X(s)e^{st}ds$</p><h2 id="图像性质"><a href="#图像性质" class="headerlink" title="图像性质"></a>图像性质</h2><p><img src="/2021/11/11/信号与系统学习笔记/2.jpg" alt=""></p><h2 id="常用性质"><a href="#常用性质" class="headerlink" title="常用性质"></a>常用性质</h2><ul><li><p>线性：$x(t)=ax_1(t)+bx_2(t)\rightarrow aX_1(s)+bX_2(s),ROC :R_1 \and R_2$</p></li><li><p>时间平移：$x(t-t_0)\rightarrow e^{-st_0}X(s),ROC:R$ </p><p>$X(s-s_0)\rightarrow e^{jw_0t}x(t),ROC:R$</p></li><li><p>翻倍：$x(at)\rightarrow \frac{1}{|a|}X(\frac{s}{a}),ROC:aR$</p></li><li><p>共轭：$x^<em>(t)\rightarrow X^</em>(s^*),ROC:R$</p></li><li><p>卷积：$x_1(t)*x_2(t)\rightarrow X_1(s)X_2(s),ROC:R_1\and R_2$</p></li><li><p>求导：$\frac{dx(t)}{dt}\rightarrow sX(s),ROC$ :contains $R$</p><p>$-tx(t)\rightarrow \frac{dX(s)}{ds}$</p></li><li><p>积分：$\int_{-\infty}^tx(\tau)d\tau \rightarrow \frac{1}{s}X(s),ROC:R\and [Re[s]&gt;0]$</p></li></ul><p>Initial‐value theorem:$x(0^+)= \lim_{s \rightarrow \infty}sX(s) $</p><p>Final‐value theorem:$\lim_{t \rightarrow \infty}x(t)=\lim_{s \rightarrow0}sX(s)$</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p>因果性(Causality)：定义域包括右半平面</p></li><li><p>反因果性(Anti‐causal)：定义域包括左半平面</p></li><li><p>稳定性(Stability)：$H(s)$的脉冲响应绝对可积，定义域包括整个$jw$轴，即虚轴</p><p>对于因果系统，所有极点都在左半平面，即所有极点都有负实部</p></li></ul><p>经典例题</p><p><img src="/2021/11/11/信号与系统学习笔记/3.jpg" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/4.jpg" alt=""></p><h2 id="框图表示-Block-Diagram-Representation"><a href="#框图表示-Block-Diagram-Representation" class="headerlink" title="框图表示(Block Diagram Representation)"></a>框图表示(Block Diagram Representation)</h2><p><img src="/2021/11/11/信号与系统学习笔记/5.jpg" alt=""></p><p>一阶系统</p><p><img src="/2021/11/11/信号与系统学习笔记/6.jpg" alt=""></p><p>二阶系统的三种表示</p><p><img src="/2021/11/11/信号与系统学习笔记/7.jpg" alt=""></p><p>如何看八爪鱼</p><p><img src="/2021/11/11/信号与系统学习笔记/8.jpg" alt=""></p><p>上面系数直接写，从幂高到低，下面系数取反。系数也是高到低写，没有框就是1</p><h2 id="单边拉普拉斯变换"><a href="#单边拉普拉斯变换" class="headerlink" title="单边拉普拉斯变换"></a>单边拉普拉斯变换</h2><p>$X(s)= \int_{0^-}^{\infty}x(t)e^{-st}dt$</p><p>$x(t)=0$ for $t&lt;0$ the unilateral and bilateral transforms are identical</p><h3 id="不同的性质点"><a href="#不同的性质点" class="headerlink" title="不同的性质点"></a>不同的性质点</h3><ul><li>求导：$\frac{dx(t)}{dt}\rightarrow sX(s)-x(0^-)$</li><li>卷积：$x_1(t)*x_2(t)\rightarrow X_1(s)X_2(s),ROC:R_1\and R_2$只有$x_1(t),x_2(t)$都满足$t&lt;0,x_1(t)=0,x_2(t)=0$才能用</li></ul><p>用处：求LTI系统的零输入响应，和零状态响应</p><p><img src="/2021/11/11/信号与系统学习笔记/9.jpg" alt=""></p><h1 id="Z变换-The-z‐transform"><a href="#Z变换-The-z‐transform" class="headerlink" title="Z变换(The z‐transform)"></a>Z变换(The z‐transform)</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>拉普拉斯变换的离散信号版本</p><p>$X(z)=\sum_{n=-\infty}^{+\infty}x[n]z^{-n}$</p><p>定义域都是圆型的</p><p>相似性质都和拉普拉斯相同不多赘述</p><h2 id="反Z变换"><a href="#反Z变换" class="headerlink" title="反Z变换"></a>反Z变换</h2><p>$x[n]=\frac{1}{2\pi j}\int X(z)z^{n-1}dz$</p><p>注意定义域范围来确定最后得到函数</p><h2 id="图像性质-1"><a href="#图像性质-1" class="headerlink" title="图像性质"></a>图像性质</h2><p><img src="/2021/11/11/信号与系统学习笔记/10.jpg" alt=""></p><h2 id="常用性质-1"><a href="#常用性质-1" class="headerlink" title="常用性质"></a>常用性质</h2><ul><li><p>线性：$ax_1[n]+bx_2[n]\rightarrow aX_1(z)+bX_2(z),ROC:R_1 \and R_2$</p></li><li><p>时间平移：$x[n-n_0]\rightarrow z_{-n_0}X(z),ROC:R$</p><p>$X(e^{-jw_0}z)\rightarrow e^{jw_0n}x[n],ROC:R$</p></li><li><p>共轭：$x^<em>[n]\rightarrow X^</em>(z^*),ROC:R$</p></li><li><p>求导：$nx[n]\rightarrow -z\frac{dX(z)}{dz},ROC:R$</p></li><li><p>$x[n]-x[n-1]\rightarrow (1-z^{-1})X(z),ROC :R$,</p><p>$\sum_{k=-\infty}^{n}x[k]\rightarrow \frac{1}{1-z^{-1}}X(z)$</p></li></ul><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul><li><p>因果性(Causality)：定义域在某个圆的外侧，包括无穷，$H(z)$分子的最高次数不能高于分母的最高次数</p></li><li><p>稳定性(Stability)：定义域包含单位圆</p><p>如果系统因果，所有极点都在单位圆里面</p></li></ul><p>经典例题：</p><p><img src="/2021/11/11/信号与系统学习笔记/11.jpg" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/12.jpg" alt=""></p><p><img src="/2021/11/11/信号与系统学习笔记/13.jpg" alt=""></p><h2 id="框图表示-Block-Diagram-Representation-1"><a href="#框图表示-Block-Diagram-Representation-1" class="headerlink" title="框图表示(Block Diagram Representation)"></a>框图表示(Block Diagram Representation)</h2><p>异曲同工</p><p>一阶系统</p><p><img src="/2021/11/11/信号与系统学习笔记/14.jpg" alt=""></p><p>二阶系统</p><p><img src="/2021/11/11/信号与系统学习笔记/15.jpg" alt=""></p><p>八爪鱼</p><p><img src="/2021/11/11/信号与系统学习笔记/16.jpg" alt=""></p><h2 id="单边Z变换"><a href="#单边Z变换" class="headerlink" title="单边Z变换"></a>单边Z变换</h2><p>$X(z)=\sum_{n=0}^{\infty}x[n]z^{-n}$</p><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>$x[n+1]\rightarrow zX(z)-zx[0]$</li><li>$x[n-1]\rightarrow z^{-1}X(z)+x[-1]$</li><li>$x[n-2]\rightarrow z^{-2}X(z)+z^{-1}x[-1]+x[-2]$</li></ul><p>主要和单边拉普拉斯变换有相同用处</p><p><img src="/2021/11/11/信号与系统学习笔记/17.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大二复习&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;基础数学&quot;&gt;&lt;a href=&quot;#基础数学&quot; class=&quot;headerlink&quot; title=&quot;基础数学&quot;&gt;&lt;/a&gt;基础数学&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2021/11/11/信号与系统学习笔记/1.png&quot; alt=&quot;&quot;</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="SIGNAL_PROCESSING" scheme="http://yoursite.com/categories/CS/SIGNAL-PROCESSING/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="信号与系统" scheme="http://yoursite.com/tags/信号与系统/"/>
    
  </entry>
  
  <entry>
    <title>算法复习</title>
    <link href="http://yoursite.com/2021/11/08/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/11/08/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-11-09T03:37:22.000Z</published>
    <updated>2023-10-06T21:34:02.197Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="https://www.zhihu.com/people/aokihao" target="_blank" rel="noopener">背包</a> <a href="https://www.shangmayuan.com/a/6c325edebbc54ef0a85917a9.html" target="_blank" rel="noopener">N,NP,NPC</a> <a href="https://zhuanlan.zhihu.com/p/54510444" target="_blank" rel="noopener">A*</a>这几个比较难所有参考比较多</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Poly-time: There exists constants $c &gt; 0$ and $d &gt; 0 $such that on every input of size N, its running time is bounded by $cN^d$ steps</p><h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><h2 id="链表-List"><a href="#链表-List" class="headerlink" title="链表(List)"></a>链表(List)</h2><p>记录头尾指针代表链表的开始和结束，中间用next表示前后关系的线性结构。</p><h3 id="支持的操作与其复杂度"><a href="#支持的操作与其复杂度" class="headerlink" title="支持的操作与其复杂度"></a>支持的操作与其复杂度</h3><p>· 头尾插入元素$O(1)$，删除尾部$O(n)$</p><p>· 其他位置插入删除都是$O(n)$（先要找到这个元素再在前后插入，知道位置只用$O(1)$)</p><p>双向链表就是多记录了一个$pre$，没啥大区别</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><p><img src="/2021/11/08/算法复习/1.png" alt="  "></p><p>尾进尾出的结构，一般只需要一个指针，画成竖直状态比较方便理解</p><p>具体运用：逆波兰表达式，树的深度优先遍历</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><p>尾进头出的结构，有头尾两个指针的线性结构</p><p><img src="/2021/11/08/算法复习/2.png" alt=""></p><p>环形队列</p><p><img src="/2021/11/08/算法复习/3.png" alt=""></p><h2 id="哈希表-Hash-List"><a href="#哈希表-Hash-List" class="headerlink" title="哈希表(Hash List)"></a>哈希表(Hash List)</h2><p>自定义一种哈希方式，得到对应的哈希数，然后放在对应的数组格子里面。</p><p>但如果对应格子已经满了，就采用线性或者更跳跃的方式往后找空余的格子</p><p>线性探查(probe)——直接一个一个往后找</p><p>二次探查——$ (k+k*k)/2$     1，2，4，7，11 优点为花费时间更少</p><h2 id="树-Trees"><a href="#树-Trees" class="headerlink" title="树(Trees)"></a>树(Trees)</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>深度(depth)：<strong>根节点记为深度0</strong>，树的高度指最大深度</li><li>父亲(parent)与孩子(children)节点：从根节点往下遍历，由一条边相连的两个节点互为父亲与孩子节点，深度小的为父亲</li><li>度数(degree)：父亲节点的孩子数量</li><li>叶子节点(leaf)：孩子数量为0即度数为0的节点</li><li>根节点(root)：没有父亲的节点</li><li>祖先(ancestor)与子孙(descendant)：<strong>此概念均包括节点自己</strong>，子孙指以该节点为根的子树里所有的节点，祖先指从该节点到根节点路径上经过的所有节点</li></ul><h3 id="遍历方法-traversal"><a href="#遍历方法-traversal" class="headerlink" title="遍历方法(traversal)"></a>遍历方法(traversal)</h3><h4 id="广度优先遍历-Breadth-First-Traversal-BFS"><a href="#广度优先遍历-Breadth-First-Traversal-BFS" class="headerlink" title="广度优先遍历(Breadth-First Traversal) BFS"></a>广度优先遍历(Breadth-First Traversal) BFS</h4><p><img src="/2021/11/08/算法复习/8.png" alt=""></p><p>很显然的遍历，运用queue队列来进行，每次先pop对头节点，再push进去当前 对头节点所 </p><p>有的孩子</p><h4 id="深度优先搜索-Depth-first-Traversal-DFS"><a href="#深度优先搜索-Depth-first-Traversal-DFS" class="headerlink" title="深度优先搜索(Depth-first Traversal) DFS"></a>深度优先搜索(Depth-first Traversal) DFS</h4><p>每次pop出栈头节点，push进去其孩子节点（<strong>从右到左</strong>）</p><p>用栈stack来实现</p><p><img src="/2021/11/08/算法复习/9.png" alt=""></p><h3 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h3><p>一种孩子最多只有两个的结构</p><h4 id="二叉树的深度遍历"><a href="#二叉树的深度遍历" class="headerlink" title="二叉树的深度遍历"></a>二叉树的深度遍历</h4><ul><li>前序遍历(pre-order)：根左右</li><li>中序遍历(in-order)：左根右</li><li>后序遍历(post-order)：左右根</li></ul><p><strong>都是以根的位置而记忆的</strong></p><h4 id="易混淆概念"><a href="#易混淆概念" class="headerlink" title="易混淆概念"></a>易混淆概念</h4><ul><li>满二叉树(full binary tree)：只要有孩子就必须满足两个，要么就没有</li></ul><p>​       性质：$n $ 个叶子节点，$2n-1$ 所有节点</p><ul><li><p>完美二叉树(perfect binary tree)：每层的节点全部是满的</p><p>性质：节点为$n=2^{h+1}-1$，高度为$h=\Theta(lnn)$，该层有$2^h$个叶子节点</p></li><li><p>完全二叉树(complete binary tree)：倒数第二层前都满足完美二叉树性质，最后一层可以不满</p><p>性质：节点为n，高度为$h=\lfloor lg(n) \rfloor$ </p></li></ul><h1 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h1><h2 id="三种复杂度表示的定义和证明"><a href="#三种复杂度表示的定义和证明" class="headerlink" title="三种复杂度表示的定义和证明"></a>三种复杂度表示的定义和证明</h2><p>• Upper bounds. T(n) is $ O(f(n))$ if there exist constants c &gt; 0 and $n_0 \geq  0$ such that for all $n \geq n_0$we have$ T(n) \leq c・f(n)$</p><p>• Lower bounds. T(n) is $Ω(f(n))$ if there exist constants $ c &gt; 0 $and $ n_0 \geq 0 $such that for all $n \geq n_0$ we have $T(n) \geq c・f(n)$</p><p>• Tight bounds. T(n) is $ Θ(f(n))$ if T(n) is both $ O(f(n))$ and $ Ω(f(n))$.</p><p>• Exist constants$ c_1, c_2, n_0$, such that$ c_1f(n) \leq T(n) \leq c_2f(n) $for all$ n \geq n_0$</p><p><img src="/2021/11/08/算法复习/24.png" alt=""></p><p><img src="/2021/11/08/算法复习/4.png" alt=""></p><p><img src="/2021/11/08/算法复习/5.png" alt=""></p><p><strong>关于复杂度的加法原则</strong></p><p><img src="/2021/11/08/算法复习/25.png" alt=""></p><p>多项式的一些复杂度定理：</p><p><img src="/2021/11/08/算法复习/26.png" alt=""></p><p>$O(k^2n^k/k!)=O(n^k)$</p><h1 id="数据结构相关算法"><a href="#数据结构相关算法" class="headerlink" title="数据结构相关算法"></a>数据结构相关算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>逆序对定义：原先数组内和排序后数组顺序相反的数对</p><p>计算逆序对：用归并排序</p><h3 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h3><p>将序列分为有序序列和无序序列两段，每次将无序序列开头的数插入前面的有序序列中，直到所有数都有序</p><p>复杂度：最坏$O(n^2)$,平均$O(n+d)$，原地排序，稳定排序</p><p>若有$d$对逆序对，则时间为$\Theta (n+d)$ </p><p>若$d=O(n)$，时间为$\Theta(n)$</p><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h3><p>从前到后比较相邻两个数的大小，交换逆序对</p><p>同时分带不带flag判断，带的话有最优复杂度，不带就没有</p><p>复杂度：最坏$O(n^2)$ 最优$O(n)$ ，原地排序，稳定排序</p><h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h3><p>归并思路，合并两个子数列的时候就是利用队列合并，所以需要新开一个数组来合并序列</p><p>复杂度：$O(nlogn)$ 非原地排序，空间$O(n)$，稳定排序</p><p>计算逆序对，直接在$b_j&lt;a_i$时候$ans+=mid-i+1$</p><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h3><p>每次选一个pivot找到他正确的位置，然后以pivot为中心再分为两个子序列，于是剩下的就是分治思路。</p><p>找位置的方法是，从pivot开始从左到右找第一个比pivot大的数，从右到左找第一个比pivot小的数</p><p>同时每次把pivot找到的正确位置之后，就是建立一颗二叉搜索树。</p><p>从这个角度思考复杂度$a_i,a_j$会被比较到的概率为$2/j-i+1$，只有互为孩子父亲才会被比较到</p><p>故复杂度就为所有数对的可能性相加  $2n(lnn+1)$</p><p>复杂度：平均$O(nlogn)$ 最坏$O(n^2)$，原地排序，非稳定排序</p><h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h3><p>先把数据建成大根堆，每次再将堆头和最末尾的元素交换，然后pop掉这个最大的元素，再重新调成大根堆结构，这样保证每次操作都能找到现在无序序列中最大的元素，依次把大根堆规模变小，使无序序列长度逐渐变小为0。</p><p>复杂度：$O(nlogn)$，非原地排序，非稳定排序</p><h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h3><p>每次从前往后找出无序序列中最小的一个数和无序序列第一个数交换位置，暴力找，很慢。</p><p>复杂度：$O(n^2)$，原地排序，非稳定排序</p><h3 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h3><p>一个在归并算法中运用的求复杂度的理论<br>$<br>T(n)=aT(\frac{n}{b})+f(n),T(0)=0,T(1)=\Theta(1)<br>$<br>a代表子问题的数量，n/b指子问题的大小，f(n)是divide and combine</p><p><img src="/2021/11/08/算法复习/6.png" alt=""></p><p>这个理论运用的实例：求矩阵乘法</p><p><img src="/2021/11/08/算法复习/7.png" alt=""></p><h2 id="哈夫曼编码-Huffman-Coding"><a href="#哈夫曼编码-Huffman-Coding" class="headerlink" title="哈夫曼编码(Huffman Coding)"></a>哈夫曼编码(Huffman Coding)</h2><p>一种按字符出现频率来实现编码的方式，以此来节省空间，利用二叉树，优先队列来存储</p><p>先用优先队列记录每个字符的出现频率，频率越高在优先队列中优先级越低，就放在队列越后面</p><p><img src="/2021/11/08/算法复习/11.png" alt=""></p><p>建树过程使从前到后两两合并，得到的子树顺次插入序列，期中单字符优先级大于多个字符</p><p><img src="/2021/11/08/算法复习/12.png" alt=""></p><h2 id="二叉堆与优先队列-Heap"><a href="#二叉堆与优先队列-Heap" class="headerlink" title="二叉堆与优先队列(Heap)"></a>二叉堆与优先队列(Heap)</h2><p>优先队列就是队头固定最大最小值的数组，感觉就是排好序的数列</p><p>二叉堆的性质：大根堆就是父亲节点大于左右孩子，但左右孩子大小关系不确定，小根堆就是大小关系反一下</p><p>堆是一个完全二叉树，将数据储存在数组里的，利用下标一个父亲节点为$n$则左孩子为$2n$，右孩子$2n+1$</p><h3 id="操作与复杂度"><a href="#操作与复杂度" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><ul><li><p>push：直接先新节点顺次加入树的最后一个节点，然后执行percolate操作，我的理解是向上翻，每次比较第$\lceil n/2 \rceil(n&gt;&gt;1)$节点和自己的大小，若不符合定义就交换。</p></li><li><p>pop：将需要pop的节点与当前堆最后一个元素交换，直接抛弃现在最后一个元，再执行percolate操作，在这里是下沉，再从根节点往下比较自己孩子$(2n,2n+1)$与自己的大小，不符合定义就交换。</p></li><li><p>build：push每个元素或者用Floyd’s Method $O(nlogn)$</p><p>大体看push和pop都当成$O(nlogn)$</p></li></ul><p>空间都是$O(n)$</p><p><img src="/2021/11/08/算法复习/10.png" alt=""></p><p>Floyd’s Method将小根堆调成为大根堆（或者将普通堆调整），就是思路是先从上往下找到所有不符合定义的根节点，从编号最大的节点依次往上做percolate操作调成，依次调整完就行。</p><h2 id="斐波那契堆-Fibonacci-Heap"><a href="#斐波那契堆-Fibonacci-Heap" class="headerlink" title="斐波那契堆(Fibonacci Heap)"></a>斐波那契堆(Fibonacci Heap)</h2><p><img src="/2021/11/08/算法复习/19.jpg" alt=""></p><p>$FibNode$是斐波那契堆的节点类，它包含的信息较多。$key$是用于比较节点大小的，$degree$是记录节点的度，$left$和$right$分别是指向节点的左右兄弟，$child$是节点的第一个孩子，$parent$是节点的父节点，$marked$是记录该节点是否被删除第1个孩子($marked$在删除节点时有用)。</p><p>$FibHeap$是斐波那契堆对应的类。$min$是保存当前堆的最小节点，$keyNum$用于记录堆中节点的总数，$maxDegree$用于记录堆中最大度，而$cons$在删除节点时来暂时保存堆数据的临时空间。<br>不具体介绍每部操作如何实现<a href="https://blog.csdn.net/qq_40061421/article/details/81571132" target="_blank" rel="noopener">教学指路</a></p><table><thead><tr><th>过程</th><th>二叉堆</th><th>斐波那契堆</th></tr></thead><tbody><tr><td>INSERT</td><td>$O(logn)$</td><td>$O(1)$</td></tr><tr><td>MINIMUM</td><td>$O(logn)$</td><td>$O(1)$</td></tr><tr><td>UNION</td><td>$O(logn)$</td><td>$O(1)$</td></tr><tr><td>DELETE</td><td>$O(logn)$</td><td>$O(logn)$</td></tr></tbody></table><h2 id="二叉搜索树-Binary-Search-Trees"><a href="#二叉搜索树-Binary-Search-Trees" class="headerlink" title="二叉搜索树(Binary Search Trees)"></a>二叉搜索树(Binary Search Trees)</h2><p>满足根节点的左子树所有值都小于自己，右子树所有值都大于自己的二叉数</p><p>理解：$BST$的结构主要和插入元素的顺序有关，优不优化完全取决顺序，所以才有了$AVL$树</p><h3 id="操作与复杂度-1"><a href="#操作与复杂度-1" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><ul><li>Insert：总的来说就是顺着根节点往下比较，每次看是比当前节点大还是小，小就往左边走，大就往右边走，知道找到一个空位置就行</li><li>Find：和插入同理，顺着树往下走就完了</li><li>Erase：这个分三种情况，若该节点为叶子节点直接删除就行，如果有一个子树，把这个子树接上去就行，如果有两个子树，找到右子树中最小的元素和根换位置再删掉根就行，这样能保证现在右子树所有值还是大于根（最小元素），左子树所有值也小于根。同时这个最小的值一定只有一个子树或者右节点可以证明，因为使最小的不可能有左子树</li></ul><p>由于所有操作都等于$O(h)$，但高度决定于顺序所以没有定值，但最优$O(lognn)$，最坏$O(n)$</p><p><strong>一些进阶设计</strong></p><p>设计$next$边：如果该节点有右子树，根向右子树最小的值连next边</p><p>设计$previous$边：如果该节点没有右子树，找到第一个大于自己的节点向他连一条边</p><p>这个课件里没有讲有啥用，我感觉就和AC自动机一样，但不知道有啥实际运用</p><p>感觉是next在删除中比较有用吧</p><p>用$BST$找第k大：直接看根节点左右子树大小，若左子树大小$l=k$，就是root。若$l&gt;k$继续在左子树中找最大的，否则在右子树中找$k-l-1$大的，就是一个递归思路</p><h2 id="二叉平衡搜索树-AVL-Trees"><a href="#二叉平衡搜索树-AVL-Trees" class="headerlink" title="二叉平衡搜索树(AVL Trees)"></a>二叉平衡搜索树(AVL Trees)</h2><p><del>就你是我以前天天写到吐的玩意是吧！</del></p><p>就是$BST$升级版，需要保证左右子树高度差距不大于1，于是所有操作的复杂度就能在$O(logn)$了</p><p>完全二叉搜索树=平衡树</p><p>计算满足高度为h的最小平衡树$F(h)$：可得此为斐波那契数列</p><p><img src="/2021/11/08/算法复习/13.png" alt=""></p><p>得到$F(h)\approx 1.8994\phi ^h-1,\phi \approx 1.6180$</p><p>$F(h)=\Theta (\phi ^h)$</p><p>所以可得高度为h的最大平衡树$log_{\phi}{(\frac{n+1}{1.8944})}=log_{\phi}{(n+1)-1.3277}=1.4404*lg(n+1)-1.3277$</p><h3 id="操作与复杂度-2"><a href="#操作与复杂度-2" class="headerlink" title="操作与复杂度"></a>操作与复杂度</h3><p>所有操作和$BST$一样，只是插入和删除都多了一个维和操作，这里具体分析如何维护也就是$Splay$核心，同时维护都是$O(1)$</p><p>基本操作分为左旋和右旋</p><p>右旋</p><p><img src="/2021/11/08/算法复习/15.jpg" alt=""></p><p>左旋</p><p><img src="/2021/11/08/算法复习/16.jpg" alt=""></p><p>核心是找到处于不平衡状态的根，看是怎么样子不平衡</p><h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p>左子树大于右子树两个高度，直接右旋一次就行</p><p><img src="/2021/11/08/算法复习/14.jpg" alt=""></p><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p>右子树大于左子树两个高度，直接左旋一次就行</p><p><img src="/2021/11/08/算法复习/17.jpg" alt=""></p><h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p>将新的节点插入到了 n 的左孩子的右子树上导致的不平衡的情况。这时我们需要的是先对 i 进行一次左旋再对 n 进行一次右旋。</p><p><img src="/2021/11/08/算法复习/18.jpg" alt=""></p><h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p>和LR同理不知道为啥没有图给我偷了（</p><p>总之是将新的节点插入到了 n 的右孩子的左子树上导致的不平衡的情况。这时我们需要的是先对 i 进行一次右旋再对 n 进行一次左旋。</p><p>再来看基本操作</p><ul><li>Insertion 只可能需要一次维护 $O(1)$</li><li>Erase 可能需要$O(h)$次数，需要沿着删除的节点从下到上沿着到根节点的路径往上检查节点是否需要为维护 故复杂度$O(log n)$</li></ul><h2 id="并查集-Disjoint-Set"><a href="#并查集-Disjoint-Set" class="headerlink" title="并查集(Disjoint Set)"></a>并查集(Disjoint Set)</h2><h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h3><p>主要操作是$findf()$和$union$，每次$union就是把两个节点接到一颗树上，findf就是找到这个节点对应的根节点。</p><p>关于这个add的方式主要分为两种</p><p>例子$union(A,B)，root(A)=C,root(B)=D$</p><p>1.Only with path compression</p><p>指只看前后顺序来merge，把D接在C下面</p><p>2、Only with union-by-size optimization(又称rank优化)</p><p>指当两颗子树高度一直时按前后顺序加，若不同就把高度更低的加到高度高的树根下面</p><p>如果$height(C)&gt;height(D)$，把D接在C下面，否则和1相同</p><p>还有一种size优化，是比较每颗子树的size来合并，但没有rank好</p><p>一般写代码会用到路径压缩的方式，即所有子树高度都压缩到1，就是最常见的写法。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findf</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token punctuation">)</span><span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">findf</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dij_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fx<span class="token operator">=</span><span class="token function">findf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> fy<span class="token operator">=</span><span class="token function">findf</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fx<span class="token operator">==</span>fy<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">;</span>    fa<span class="token punctuation">[</span>fx<span class="token punctuation">]</span><span class="token operator">=</span>fy<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若不使用路径压缩，我们通过并查集得到的树有一下结论。</p><p><img src="/2021/11/08/算法复习/17.png" alt=""></p><p>假如这颗树高度为$h$，有节点数$\sum_{k=0}^{h}\dbinom{h}{k}=2^h=n$</p><p>深度$\sum_{k=0}^{h}k\dbinom{h}{k}=h2^{h-1}$</p><p>平均深度$\frac{h2^{h-1}}{2^h}=\frac{h}{2}=\frac{lg(n)}{2}$</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$findf$：优化前$O(n)$，rank优化+路径压缩后$O(log^*n)$</p><p><img src="/2021/11/08/算法复习/18.png" alt=""></p><table><thead><tr><th>n</th><th>log* n</th></tr></thead><tbody><tr><td>(−∞, 1]</td><td>0</td></tr><tr><td>(1, 2]</td><td>1</td></tr><tr><td>(2, 4]</td><td>2</td></tr><tr><td>(4, 16]</td><td>3</td></tr><tr><td>(16, 65536]</td><td>4</td></tr><tr><td>(65536, 2^65536]</td><td>5</td></tr></tbody></table><p>总之这个$log^*n$优于$logn$</p><hr><hr><p>以上为数据结构的相关算法，接下来是图论。</p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>有向图(Directed graph)：点之间的边指定方向。如由A→B最大边数$|E|\le O(2|V|^2)=O(|V|^2)$</li><li>无向图(Undirected graph)：点之间的边不指定方向。最大边数$|E|\le O(|V|^2)$</li><li>度(Degree)： 出度(Out)入度(In)针对有向图，计数从一个点出去的边数和接受的边数。对于无向图就是一个点连了多少条边</li><li>子图(Sub-graph)：从原图中选取部分边和点</li><li>顶点导出子图(Vertex-induced sub-graphs)：所有的点都选，边部分不选</li><li>路径(Path)：两点之间遍历到的点集合</li><li>最简路径(Simple path)：点边不可重复走</li><li>最简回路(Simple cycle)：（除去头尾）点边不可重复走的环</li><li>联通(Connectedness)：两点之间存在路径则联通</li><li>树(Tree)：每两点间都只有一条独立的路径</li><li>森林(Forest)：没有任何回路的图，树的合集</li><li>联通分量(Connected Components)：连通的子图</li></ul><h2 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h2><ul><li><p>邻接矩阵(Adjacency Matrix)：空间$O(|V|^2)$，遍历所有邻接的点$\Theta(|V|)$</p></li><li><p>邻接表(Adjacency List)：空间$\Theta (|V|+|E|)$，遍历所有邻接的点$\Theta(|E|/|V|)$ 更适合于</p></li></ul><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul><li>深度优先搜索（用栈）：递归或者栈，一次性一条路走到底，若到底则返回遍历，继续往下找</li><li>广度优先搜索（用队列）每次push进去邻接的点，pop出去的点就是遍历顺序</li></ul><p>两种遍历都可以检查图的联通性</p><p><strong>关于二分图：</strong></p><p>如果某个图为二分图，那么它至少有两个顶点，且其所有回路的长度均为偶数，任何无回路的的图均是二分图。</p><p>算法判定：用二分图染色</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="最小生成树-Minimum-Spanning-Tree"><a href="#最小生成树-Minimum-Spanning-Tree" class="headerlink" title="最小生成树(Minimum Spanning Tree)"></a>最小生成树(Minimum Spanning Tree)</h3><p>总之是求图上构造一棵树是所有点连通，并且边的权值之和最小。</p><p>默认是邻接矩阵实现</p><p><strong>prim算法</strong></p><ul><li>首先初始化距离为INF</li><li>随机从一个点开始，先遍历他邻接的点更新一下初始距离，再遍历所有的点找到一个距离最短的点，并记录下来 $O(|V|^2)$,相当于pop小根堆堆顶的点</li><li>再从这个点开始遍历邻接所有的点，更新距离$O(|E|)$，相当于加入小根堆</li><li>直到遍历到所有点</li></ul><p>此算法需要储存邻接的边信息，比如需要前向星</p><p>故总的时间复杂度$O(|V|^2+|E|)=O(|V|^2)$</p><p>用邻接表$O(|V|ln|V|+|E|ln|V|)=O(|E|ln|V|)$</p><p>斐波那契堆$O(|V|ln|V|+|E|)$二叉堆$O(|V|ln|V|+|E|ln|V|)=O(|E|ln|V|)$</p><p><strong>Kruskal</strong>算法</p><ul><li>先将边按照权值排序（从小到大）$O(ln|E|)$</li><li>遍历所有的边，对于每条边的连接的两点$u,v$，对其进行一次并查集的判断，看这两个点是否联通，如果联通则放弃，不连通则加入生成树$O(|E|ln|V|)$</li></ul><p>复杂度$O(ln|E|+|E|ln|V|)=O(|E|ln|V|)$</p><p>不需要前向星只需要结构体</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>就是根据图上每个点的入度来排序的算法，每次找到所有点中入度为0的点，将其pop出队列，然后将这个点所邻接的点的入度–，更新后重新寻找入度为0的点。</p><p>一些结论：</p><ul><li>DAG一定有拓扑排序，有拓扑排序一定是DAG（有向无环图）</li><li>DAG一定至少有一个入度为0的点</li><li>DAG的子图一定是DAG</li><li>不是DAG一定没有拓扑排序</li></ul><p><strong>复杂度：</strong></p><p>$O(|V|+|V|^2)=O(|V|^2)$不使用堆，每次遍历所有的点找入度为0的点</p><p>若使用堆优化$O(|V|+|E|)$邻接表，$O(|V|^2)$邻接矩阵</p><p>若某次操作后，所有剩下的点没有入度为0的点，则有环，因此可以用拓扑排序判环</p><p>用拓扑排序找critical path</p><p>总之描述是每个点带一个时间权值，当入度都为0的时候可以同时进行操作，求所有任务完成的最短时间和路径。</p><p>就用拓扑排序，每次记录一下前一个点是哪个就可以了，删除点的时候顺便更新邻接点的最短时间就可以了</p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>声明：所有最短路算法遇到负环均没有答案</p><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>方法是先将所有点的距离都赋值为INF，从起点开始，每次找到距离最短的点，从这个点来更新邻接的点的距离</p><p>$dis[u]=min(dis[u],dis[v]+w(u,v))$</p><p><strong>注意：</strong></p><ul><li>$dijkstra$不能计算有副边边权的最短路</li><li>有向图无向图都一样</li></ul><p><strong>复杂度：</strong></p><p>邻接矩阵：$O(|V|(|V|+|V|))=O(|V|^2)$</p><p>邻接表：$O(|V|^2+|E|)=O(|V|^2)$</p><p>堆优化+邻接表：二叉堆 $O(|V|ln|V|+|E|ln|V|)=O(|E|ln|V|)$</p><p>斐波那契堆 $O(|V|ln|V|+|E|)$</p><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>我认为十分垃圾的算法，总之唯一优点是可以处理负边</p><p><img src="/2021/11/08/算法复习/19.png" alt=""></p><p>最后的循环是用来判断负环</p><p><strong>复杂度：</strong></p><p>$O(|V|+|V||E|)=O(|V||E|)$</p><h3 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h3><p>Bellman-Ford 的队列优化 和Dijkstra就是孪生兄弟</p><p>基本写法只有vis数组的更新以及堆和队列区别，一旦入队，vis变为1，出队就变为0，松弛的时候遇到不在队列里的点就进队，在队列里面就只是更新距离</p><p>Dijkstra是一旦出堆一次就不会再进去</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//队列存的是待更新的点</span>queue⬅st<span class="token keyword">while</span><span class="token punctuation">(</span>queue不空<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Ⅰ<span class="token punctuation">.</span>t<span class="token operator">=</span>queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取出队首元素</span>       q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Ⅱ<span class="token punctuation">.</span>更新t的所有出边 t→b（权值为w）       <span class="token comment" spellcheck="true">//如果更新成功的话，就把b加入队列，b就是待更新的点，先判断b是否已经被更新过了，如果已经更新过了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况下时间复杂度：$O ( |E| )$，最坏的情况下是：$O(|V||E|)$</p><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>当$|E|=\Theta(|V|^2)$，用$Dijkstra$求所有点对的最短路$O(|V|^3ln|V|)$太拉了所以用Floyd</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>如果是无向图，第二层只需要遍历$k+1-n$，时间节约约1/2</p><p>可以用Flody判断联通性以及负环，跑完后只要有负值就是负环</p><h3 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h3><p>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</p><p>其原理也很简单。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p><p><img src="/2021/11/08/算法复习/1.gif" alt=""></p><p>启发式搜索，为每个点添加一个优先级函数</p><p>A*算法通过下面这个函数来计算每个节点的优先级。</p><p>$f(n)=g(n)+h(n)$</p><p>其中：</p><ul><li>$f(n)$是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</li><li>$g(n) $是节点n距离起点的代价。</li><li>$h(n)$是节点n距离终点的预计代价，这也就是A*算法的启发函数。关于启发函数我们在下面详细讲解。</li></ul><p>A*算法在运算过程中，每次从优先队列中选取$f(n)$值最小（优先级最高）的节点作为下一个待遍历的节点。</p><pre><code>* 初始化open_set和close_set；* 将起点加入open_set中，并设置优先级为0（优先级最高）；* 如果open_set不为空，则从open_set中选取优先级最高的节点n：    * 如果节点n为终点，则：        * 从终点开始逐步追踪parent节点，一直达到起点；        * 返回找到的结果路径，算法结束；    * 如果节点n不是终点，则：        * 将节点n从open_set中删除，并加入close_set中；        * 遍历节点n所有的邻近节点：            * 如果邻近节点m在close_set中，则：                * 跳过，选取下一个邻近节点            * 如果邻近节点m也不在open_set中，则：                * 设置节点m的parent为节点n                * 计算节点m的优先级                * 将节点m加入open_set中</code></pre><p>close_set：储存出队的节点，open_set：目前队列，已$f(n)$为依据的小根堆，parent用来记录路径</p><p><strong>一些结论：</strong></p><ul><li>在极端情况下，当启发函数$h(n)$始终为0，则将由$g(n)$决定节点的优先级，此时算法就退化成了$Dijkstra$算法。</li><li>如果$h(n)$始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当$h(n)$的值越小，算法将遍历越多的节点，也就导致算法越慢。</li><li>如果$h(n)$完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。</li><li>如果$h(n)$的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。</li><li>在另外一个极端情况下，如果$h(n)$相较于$g(n)$大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。</li></ul><p>Tree Search：不设置vis数组，不考虑节点有无被遍历过</p><p>Graph Search：设置vis数组，每次出堆的时候就标记visited，每次只遍历邻接的unvisited的点</p><p>$h(n)$又称heuristic distance，关于这个距离有两个性质</p><ul><li>Admissible Heuristics，就是$h(n)$始终小于等于节点n到终点的代价</li></ul><p><strong>Theorem: If <em>h(n)</em> is admissible, A* using TREE-SEARCH is optimal </strong></p><ul><li>Consistent Heuristics</li></ul><p><img src="/2021/11/08/算法复习/20.png" alt=""></p><p>A heuristic is consistent if for every node <em>n</em>, every successor <em>n’</em> of <em>n</em></p><p>generated by any action <em>a</em>, we have <strong>h(n) ≤ c(n,a,n’) + h(n’)</strong></p><p>If <em>h</em> is consistent, we have</p><p>f(n’) = g(n’) + h(n’) =g(n) + c(n,a,n’) + h(n’) (g(n’)=g(n)+c(n.a.n’)) </p><p>≥ h(n) + h(n) = f(n) (consistency)</p><p>f(n’) ≥ f(n)</p><p>这个性质只针对两个点，基本就看$h(n),h(n’)+w(n,n’)$</p><p><strong>Theorem: If <em>h(n)</em> is consistent, A* using GRAPH-SEARCH is optimal</strong></p><h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>主要列举一下证明，反证法</p><p><img src="/2021/11/08/算法复习/27.png" alt=""></p><h3 id="Inversions"><a href="#Inversions" class="headerlink" title="Inversions"></a>Inversions</h3><p>An inversion in schedule S is a pair of jobs i and j such that: i &lt; j but j scheduled before i</p><p><img src="/2021/11/08/算法复习/28.png" alt=""></p><p>贪心没有inversions，inversions一定相邻</p><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>这个就不说理论了，直接上例题</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ul><li><p>01背包</p><p>$dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]),j &gt;= w[i]$</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>完全背包</p><p>$dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) ,j &gt;= w[i]$</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>多重背包</p><p>前面不同就是每种物品是有限个$n[i]$</p><p>$dp[i][j] = max{(dp[i-1][j − k<em>w[i]] + k</em>v[i]) for every k},k &lt;= min(n[i], j/w[i])$</p></li></ul><p>其他情形：</p><ul><li><p>恰好装满：</p></li><li><p>背包问题有时候还有一个限制就是必须恰好装满背包，此时基本思路没有区别，只是在初始化的时候有所不同。</p><p>如果没有恰好装满背包的限制，我们将dp全部初始化成0就可以了。因为任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。如果有恰好装满的限制，那只应该将$dp[0,1,..N][0]$初始为0，其它dp值均初始化为<code>-inf</code>，因为此时只有容量为0的背包可以在什么也不装情况下被“恰好装满”，其它容量的背包初始均没有合法的解，应该被初始化为<code>-inf</code>。</p></li><li><p>求方案数量：$dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]]) // j &gt;= w[i]$</p></li></ul><h4 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h4><ol><li>Partition Equal Subset Sum（分割等和子集）</li></ol><p>题目给定一个只包含正整数的非空数组。问是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>由于所有元素的和sum已知，所以两个子集的和都应该是sum/2（所以前提是sum不能是奇数），即题目转换成从这个数组里面选取一些元素使这些元素和为sum/2。如果我们将所有元素的值看做是物品的重量，每件物品价值都为1，所以这就是一个恰好装满的01背包问题。</p><ol start="2"><li>Coin Change（零钱兑换）</li></ol><p>题目给定一个价值amount和一些面值，假设每个面值的硬币数都是无限的，问我们最少能用几个硬币组成给定的价值。</p><p>如果我们将面值看作是物品，面值金额看成是物品的重量，每件物品的价值均为1，这样此题就是是一个恰好装满的完全背包问题了。不过这里不是求最多装入多少物品而是求最少，我们只需要将完全背包的转态转移方程中的max改成min即可，又由于是恰好装满，所以除了dp[0]，其他都应初始化为<code>INT_MAX</code>。</p><ol start="3"><li>Target Sum（目标和）</li></ol><p>这道题给了我们一个数组（元素非负），和一个目标值，要求给数组中每个数字前添加正号或负号所组成的表达式结果与目标值S相等，求有多少种情况。</p><p>假设所有元素和为sum，所有添加正号的元素的和为A，所有添加负号的元素和为B，则有<code>sum = A + B</code> 且 <code>S = A - B</code>，解方程得<code>A = (sum + S)/2</code>。即题目转换成：从数组中选取一些元素使和恰好为<code>(sum + S) / 2</code>。可见这是一个恰好装满的01背包问题，要求所有方案数，将1.2节状态转移方程中的max改成求和即可。需要注意的是，虽然这里是恰好装满，但是dp初始值不应该是<code>inf</code>，因为这里求的不是总价值而是方案数，应该全部初始为0（除了dp[0]初始化为1）。</p><p><strong>一些其他的dp问题</strong></p><ul><li><p>最长公共子串</p><p>$dp[i][j]$表示比较到$A[i],B[j]$时候的最长公共子串，且此时$A[i],B[j]$为最长公共子串的最后一个元素，故要求$A[i]=B[j]$</p><p>当$A[i]=B[j],dp[i][j]=dp[i-1][j-1]+1$，当$A[i]!=B[j],dp[i][j]=0$</p><p>答案是每次更新以后，记一个最大值就是答案</p></li><li><p>最长公共子序列</p><p>$dp[i][j]$表示比较到$A[i],B[j]$时候的最长公共子序列</p><p>当$A[i]=B[j],dp[i][j]=dp[i-1][j-1]+1$，$A[i]!=B[j],dp[i][j]=max(dp[i-1][j],dp[i][j-1])$</p></li><li><p>最长回文子序列</p><p>$dp[i][j]$表示字串从i到j的最长回文子序列长度</p><p>当$s[i]=s[j],dp[i][j]=dp[i+1][j-1]+2$，当$s[i]!=s[j],dp[i][j]=max(dp[i+1][j],dp[i][j-1])$注意i从n到1枚举，j从i+1到n枚举</p></li><li><p>最长回文子串</p><p>$dp[i][j]$表示$S_i,…,S_j$是否回文子串，1为是，0为否</p><p>当$s[i]=s[j],dp[i][j]=dp[i+1][j-1]+2$，当$s[i]!=s[j],dp[i][j]=0$</p><p> 但枚举方式有区别，不能直接像回文序列一样枚举，因为不能保证$dp[i+1][j-1]$已经被计算过，故我们采取按回文子串长度来枚举，用一个数记录L最长长度</p><p>先初始化$dp[i][i]=1,dp[i][i+1]=1 (s[i]=s[i+1])$</p><p>之后从L从3到n，i从1到i+L-1&lt;n枚举就行</p></li></ul><h2 id="N-NP-NPC-NP-hard"><a href="#N-NP-NPC-NP-hard" class="headerlink" title="N,NP,NPC,NP-hard"></a>N,NP,NPC,NP-hard</h2><h3 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h3><ul><li>P Problem：这个应该最易理解，就是一个问题能够在Polynominal的时间的获得解决，固然，是对于任意input size。</li><li>NP Problem：对于一类问题，咱们可能没有一个已知的快速的方法获得问题的答案，可是若是给咱们一个candidate answer，咱们可以在polynominal的时间内验证这个candidate answer究竟是不是咱们已知问题的答案，这类问题叫作NP problem。因此很显然 P Problem是NP problem的一个子集。</li><li>NP-hard Problem：对于这一类问题，用一句话归纳他们的特征就是“at least as hard as the hardest problems in NP Problem”， 就是NP-hard问题至少和NP问题同样难。</li><li>NP-Complete Problem：对于这一类问题，他们知足两个性质，一个就是在polynomial时间内能够验证一个candidate answer是否是真正的解，另外一个性质就是咱们能够把任何一个NP问题在polynomial的时间内把他的input转化，使之成为一个NP-complete问题（即<strong>规约</strong>）。NP-Complete Problem问题能够互相转换 (在多项式时间内)，只要其中一个问题能够在多项式时间内解决，那么其余问题也都将能够在多项式时间内解决。</li></ul><p><img src="/2021/11/08/算法复习/21.png" alt=""></p><h3 id="规约——一种技巧"><a href="#规约——一种技巧" class="headerlink" title="规约——一种技巧"></a>规约——一种技巧</h3><ol><li>把P的输入转化到Q的输入；</li><li>把Q的输出转化到P的输出。</li><li>下图展现了上述规约过程。其中 $T_1 $在多项式时间将 P的输入 $P_{input }$转化成Q的输入 $Q_{input}$ ; T2 在多项式时间将 Q的输出$ Q_{output} $转化成P的输出$ P_{output} $。也就是说NP-hard问题 P 能够依赖于对问题 Q 的解决而解决。那么 Q 至少比 P 要难，即 P&lt;=Q 。</li></ol><p><img src="/2021/11/08/算法复习/22.png" alt=""></p><h3 id="如何对问题证实"><a href="#如何对问题证实" class="headerlink" title="如何对问题证实"></a>如何对问题证实</h3><p>下面来列出了一些常见的证实问题及其证实套路。</p><ul><li><p><strong>证实NP问题</strong>：这个容易，即给你一个结果，你能在polynomial的时间内验证该结果的正确性。</p></li><li><p><strong>证实NP-hard问题</strong>：咱们要证实一个问题是NP-hard的时候，咱们一般要作的是找到一个已被证实了的NPC问题，并把这个NPC问题归约到该问题上去（即NPC&lt;=NP-hard）。</p></li><li><p><strong>证实NP-Complete问题</strong></p><p>分如下两步：</p><ol><li>第一步证实这个问题属于NP；</li><li>第二步，证实这个问题是NP-hard的。也就是找一个NPC问题把它规约过去</li></ol></li></ul><p><img src="/2021/11/08/算法复习/23.png" alt=""></p><p>下图列出了几个已被发现NP-Complete问题，及其规约关系。能够看出全部的<strong>NP</strong>问题均可以规约到<strong>SAT</strong>(即<strong>NP</strong>&lt;=<strong>SAT</strong>)，也就是说<strong>SAT</strong>至少与<strong>NP</strong>问题同样难，或者若是解决了<strong>3SAT</strong>问题，全部的NP问题就解决了。一样的，<strong>SAT</strong>&lt;=<strong>3SAT</strong>，<strong>3SAT</strong>&lt;=<strong>Independent Set</strong>，<strong>Independent Set</strong>&lt;=<strong>Vertex Cover</strong> OR <strong>Clique</strong>。算法</p><p>规约关系具备传递性，因此有<strong>3SAT</strong>&lt;=<strong>Vertex Cover</strong>，<strong>NP</strong>&lt;=<strong>NP-Complete</strong>。 事实上，因为<strong>NP-Complete</strong> ⊂ <strong>NP</strong> 且 <strong>NP</strong>&lt;=<strong>NP-Complete</strong>，能够推导出 全部的<strong>NP-Complete</strong> 能够相互规约，也就是全部的<strong>NP-Complete</strong>都是等价的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考博客：&lt;a href=&quot;https://www.zhihu.com/people/aokihao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;背包&lt;/a&gt; &lt;a href=&quot;https://www.shangmayuan.com/a/6c325ede</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="ALGORITHM" scheme="http://yoursite.com/categories/CS/ALGORITHM/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="算法分析" scheme="http://yoursite.com/tags/算法分析/"/>
    
  </entry>
  
  <entry>
    <title>数学分析II总结归纳</title>
    <link href="http://yoursite.com/2021/04/23/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90II%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/04/23/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90II%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-24T02:37:22.000Z</published>
    <updated>2021-06-19T09:19:31.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h1><h2 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h2><ol><li>分离变量法 ：$\frac{dy}{dx}=g(x)h(y) \rightarrow \int {\frac{dy}{h(y)}}=\int {g(x)dx}$</li><li>令$ u=\frac{y}{x},y’=u+xu’$</li><li>令$u=x+y,y’=u’-1$</li></ol><h2 id="一阶线性方程"><a href="#一阶线性方程" class="headerlink" title="一阶线性方程"></a>一阶线性方程</h2><p>形如$y’+P(x)y=Q(x)$ 公式$y=e^{-\int P(x)dx}(\int Q(x)e^{\int P(x)dx}dx+C)$</p><p>$Berroulli$方程形如$y’+P(x)y=Q(x)y^n (n \neq 0,1)$令$u=y^{1-n}$  有$u’+(1-n)P(x)u=(1-n)Q(x)$</p><p>有$y^{1-n}=e^{-(1-n)\int P(x)dx}(\int (1-n)Q(x)e^{\int (1-n)P(x)dx}dx+C)$</p><ul><li>可降阶微分方程</li></ul><ol><li>无y型，令$p=y’,y’’=p’$先求$y’$</li><li>无x型，令$p=y’,y’’=p \frac{dp}{dy}$</li></ol><h2 id="二阶线性方程"><a href="#二阶线性方程" class="headerlink" title="二阶线性方程"></a>二阶线性方程</h2><p>基本定义：$y’’+P(x)y’+Q(x)y=f(x)(NHL)$     $y’’+P(x)y’+Q(x)y=0(HL)$</p><p>唯一性定理：若函数p(x),q(x),f(x)在区间I上连续，$x_0 \in I $，则对任何给定的数值$\alpha ,\beta$有</p><p>$$\begin{cases} y’’+p(x)y’+q(x)y=f(x)&amp; \y(x_0)=\alpha,y’(x_0)=\beta&amp;  \end{cases}$$</p><p>存在唯一解y(x)，当$\alpha =\beta =0$该(HL)只有零解</p><p>线性相关：对函数$y_1(x),y_2(x)$若存在不全为零的常数$c_1,c_2$使$c_1y_1(x)+c_2y_2(x)\equiv 0 (x\in I)$,则这两个函数线性相关，否则使线性无关。</p><p>若$W(x)\equiv 0 \Leftrightarrow$$y_1(x),y_2(x)$线性相关</p><p>定理：设$y_1(x),y_2(x)$为HL的解，有$Liouville$公式$W(x)=W(x_0)e^{-\int_x^{x_0} p(t)dt}$</p><h3 id="解的结构"><a href="#解的结构" class="headerlink" title="解的结构"></a>解的结构</h3><p>$Liouville$公式：先找出非零特解$y_1(x)$，有$y_2(x)=y_1(x)\int  \frac{1}{y_1^2} e^{\int p(x)dx}$</p><p>一般带$x^m,e^{ax},sinmx,cosmx$ </p><h2 id="常数变易法"><a href="#常数变易法" class="headerlink" title="常数变易法"></a>常数变易法</h2><p>针对(NHL)，非齐次通解=非齐次特解+齐次通解</p><p>NHL $ y’’+p(x)y’+q(x)y=f(x)$</p><p>步骤：</p><ol><li><p>先求出齐次通解$y_1(x),y_2(x)$</p></li><li><p>求出行列式$W(x)$，求出$c_1’(x)=\frac{-y_2(x)f(x)}{W(x)},c_2’(x)=\frac{y_1(x)f(x)}{W(x)}$</p></li><li>得到非齐次特解$y^*=c_1(x)y_1(x)+c_2(x)y_2(x)$</li><li>非齐次通解$y=y^*+c_1y_1(x)+c_2y_2(x)$</li></ol><h3 id="二阶常系数齐次线性方程"><a href="#二阶常系数齐次线性方程" class="headerlink" title="二阶常系数齐次线性方程"></a>二阶常系数齐次线性方程</h3><p>形式$y’’+py’+qy=0$ 有特征方程$\lambda^2+p\lambda+q=0  $</p><table><thead><tr><th style="text-align:center">特征根</th><th style="text-align:center">通解</th></tr></thead><tbody><tr><td style="text-align:center">相异实根$\lambda_1 ,\lambda_2$</td><td style="text-align:center">$c_1e^{\lambda_1x}+c_2e^{\lambda_2x}$</td></tr><tr><td style="text-align:center">相同实根$\lambda$</td><td style="text-align:center">$c_1e^{\lambda x}+c_2xe^{\lambda x}$</td></tr><tr><td style="text-align:center">共轭复根$\alpha ,\beta$</td><td style="text-align:center">$c_1e^{\alpha x}cos\beta x+c_2e^{\alpha x}sin\beta x$</td></tr></tbody></table><p>高于二阶的方程 以此类推</p><h1 id="空间解析几何"><a href="#空间解析几何" class="headerlink" title="空间解析几何"></a>空间解析几何</h1><p>此章主要是计算，就不多写了</p><p>混合积$(\vec{a} \times \vec{b})·\vec{c}=|\vec{a} \times\vec{b}||\vec{c}|cos\theta(\vec{a} \times\vec{b},\vec{c}) $几何意义：以$\vec{a},\vec{b},\vec{c}$为同顶点三条棱的平行六面体的体积</p><p>叉乘预算律：反交换律，结合律，分配律</p><p>异面直线距离$d=\frac{|(\vec{s_1} \times \vec{s_2})\overrightarrow{p_1 p_2}}{|\vec{s_1} \times \vec{s_2}|}$</p><p>点到直线距离$d=\frac{|\overrightarrow{p_1 p_2}\times\vec{s}|}{|\vec{s}|}$</p><h1 id="多变量函数的微分学"><a href="#多变量函数的微分学" class="headerlink" title="多变量函数的微分学"></a>多变量函数的微分学</h1><p>拓扑学相关暂不列举（）</p><h2 id="多变量函数的极限"><a href="#多变量函数的极限" class="headerlink" title="多变量函数的极限"></a>多变量函数的极限</h2><p>对$\forall \varepsilon &gt;0$，当$M(x,y)\in D,\exist \delta&gt;0$,满足$0&lt;\rho(M,M_0)&lt;\delta$或者$0&lt;|x-x_0|&lt;\delta,0&lt;|y-y_0|&lt;\delta$时，有$|f(M)-a|&lt;\varepsilon$ 记为$\lim\limits_{M\rightarrow M_0} f(x)=a$</p><p>常用结论：$\lim\limits_{x\rightarrow 0,y \rightarrow 0}\frac{xy}{x+y}$不存在 令$y=-x+kx^2$得到极限为$-\frac{1}{k}$</p><p>$\lim\limits_{x\rightarrow 0,y \rightarrow 0}\frac{x^2y}{x^4+y^2}$不存在，令$y=kx,y=x^2$</p><p>$\lim\limits_{x\rightarrow 0,y \rightarrow 0}\frac{xy}{x^2+y^2}$不存在，令$y=kx$ 但有累次极限</p><p>累次极限：若存在首次极限，$\phi(x)=\lim\limits_{y\rightarrow y_0} f(x,y),\lim\limits_{x\rightarrow x_0} \phi(x)=a$则称其累次极限为a，记为$\lim\limits_{x \rightarrow x_0}\lim\limits_{y\rightarrow y_0} f(x,y)=a$</p><p><strong>技巧</strong>：遇到$x^2+y^2$ 形式的，令$x=rcos\theta,y=rsin\theta$来计算极限</p><h2 id="多变量函数的连续性"><a href="#多变量函数的连续性" class="headerlink" title="多变量函数的连续性"></a>多变量函数的连续性</h2><p>定义：$\forall \varepsilon &gt;0,\exist \delta&gt;0,\forall M\in B(M_0,\delta)=|f(M)-f(M_0)|&lt;\varepsilon$,即$\lim\limits_{M\rightarrow M_0} f(M)=f(M_0)$则称$f(M)$在$M_0$连续</p><p>类似的还有一致连续性，参考数分I就不列举了</p><h2 id="多变量函数的微分"><a href="#多变量函数的微分" class="headerlink" title="多变量函数的微分"></a>多变量函数的微分</h2><h3 id="偏微商"><a href="#偏微商" class="headerlink" title="偏微商"></a>偏微商</h3><p>偏导数定义：$f_x(x,y)=\lim\limits_{\Delta x \rightarrow 0}\frac{f(x_0+ \Delta x,y_0)-f(x_0,y_0)}{\Delta x}$ </p><p>可偏导未必连续,其他的东西再后面一并写出</p><p>定理：若$f(x,y)$的二阶混合偏导数在 $(x,y)$连续，则$f_{xy}’’(x,y)=f_{yx}’’(x,y)$</p><h3 id="可微性"><a href="#可微性" class="headerlink" title="可微性"></a>可微性</h3><p>全微分：$df(x,y)=f_x’(x,y)dx+f_y’(x,y)dy$</p><p>判断是否可微 $\lim \limits_{\Delta x \rightarrow 0,\Delta y \rightarrow 0} \frac{f(x+\Delta x,y+\Delta y)-f(x,y)-f_x’( x,y)\Delta x-f_y’( x, y)\Delta y}{\sqrt{\Delta x^2+\Delta y^2}} =0$ 则可微</p><p>若不存在或者不为0，则不可微</p><p>这几个概念的关系如图</p><p><img src="/2021/04/23/数学分析II总结/数学分析II总结\0.jpg" alt=""></p><h2 id="方向导数和梯度"><a href="#方向导数和梯度" class="headerlink" title="方向导数和梯度"></a>方向导数和梯度</h2><p>方向导数的定义：设$\vec{e}=(cos \alpha,cos\beta)$, 函数在点$(x_0,y_0)$处沿e的方向导数的定义：$\frac{\eth f}{\eth \vec{e}}(x_0,y_0)=\lim \limits_{t \rightarrow 0}\frac{f(x_0+tcos\alpha,y_0+tcos\beta)-f(x_0,y_0)}{t}$ </p><p>若f<strong>可微</strong>，$\frac{\eth f}{\eth \vec{e}}(x_0,y_0)=f_x’(x_0,y_0)cos\alpha+f_y’(x_0,y_0)cos\beta$</p><p>梯度定义：$grad f(x_0,y_0)=(f_x’(x_0,y_0),f_y’(x_0,y_0))$</p><p><strong>梯度方向使方向导数取最大值时的方向，其模就是方向导数的最大值</strong></p><h2 id="复合函数的微分"><a href="#复合函数的微分" class="headerlink" title="复合函数的微分"></a>复合函数的微分</h2><p><strong>链式法则</strong> 懂得都懂，式子太长不写了</p><p>$Laplace$方程 $\frac{\eth^2u}{\eth^2 x} +\frac{\eth^2u}{\eth^2 y}+ \frac{\eth^2u}{\eth^2 z}=0 $</p><h2 id="向量值函数的微商和微分"><a href="#向量值函数的微商和微分" class="headerlink" title="向量值函数的微商和微分"></a>向量值函数的微商和微分</h2><p>定义：$r’(t)=\lim \limits_{\Delta t \rightarrow 0}\frac{r(t+\Delta t) -r(t)}{\Delta t}$</p><p>性质：</p><ol><li>$\frac{d}{dt}(fa)=f\frac{da}{dt}+\frac{df}{dt}a$</li><li>$\frac{d}{dt}(a·b)=\frac{da}{dt}·b+a·\frac{db}{dt}$</li><li>$\frac{d}{dt}(a \times b)=\frac{da}{dt} \times b+a \times \frac{db}{dt}$</li></ol><p>$Jacobi$行列式$J_x(f)=\frac{\eth(y_1,y_2,···,y_n)}{\eth(x_1,x_2,···,x_n)}$</p><h2 id="隐函数和逆映射定理"><a href="#隐函数和逆映射定理" class="headerlink" title="隐函数和逆映射定理"></a>隐函数和逆映射定理</h2><p>隐函数存在定理：F在$M(x_0,y_0)$邻域内有连续偏导，且$F_x’(x,y) \neq 0,F_y’(x,y) \neq 0，F(x_0,y_0)=0$ ，隐函数$y=f(x)$满足$F(x,f(x))=0,y_0=f(x_0)$ 则$\frac{dy}{dx}=-\frac{F_x’(x,y)}{F_y’(x,y)}$</p><p>有$\begin{cases} F(x,y,u,v)=0 \ G(x,y,u,v)=0\end{cases}$，存在隐映射$$\begin{cases} u=u(x,y) \ v=v(x,y) \end{cases}$$ 则</p><p>$\frac{\eth u}{\eth x}=-\frac{1}{J}\frac{\eth (F,G)}{\eth (x,v)}$$\frac{\eth u}{\eth y}=-\frac{1}{J}\frac{\eth (F,G)}{\eth (y,v)}$ $\frac{\eth v}{\eth x}=-\frac{1}{J}\frac{\eth (F,G)}{\eth (u,x)}$ $\frac{\eth u}{\eth x}=-\frac{1}{J}\frac{\eth (F,G)}{\eth (u,y)}$ </p><h2 id="参数曲线"><a href="#参数曲线" class="headerlink" title="参数曲线"></a>参数曲线</h2><h3 id="空间曲线切线-法平面"><a href="#空间曲线切线-法平面" class="headerlink" title="空间曲线切线/法平面"></a>空间曲线切线/法平面</h3><p>参数式 ：$x=x(t),y=y(t),z=z(t),\vec{\iota}=(x’(t),y’(t),z’(t))$</p><p>一般式：$\begin{cases} F(x,y,u,v)=0 \ G(x,y,u,v)=0\end{cases}，\vec{\iota}=(\frac{\eth(F,G)}{\eth(y,z)},\frac{\eth(F,G)}{\eth(z,x)},\frac{\eth(F,G)}{\eth(x,y)})$</p><h3 id="平面隐式曲线"><a href="#平面隐式曲线" class="headerlink" title="平面隐式曲线"></a>平面隐式曲线</h3><p>$F(x,y)=0,(x-x_0)F_x’+(y-y_0)Fy’=0$</p><h3 id="空间曲面切平面-法线"><a href="#空间曲面切平面-法线" class="headerlink" title="空间曲面切平面/法线"></a>空间曲面切平面/法线</h3><p>隐式：$F(x,y,z)=0,\vec{n}=(F’_x,F’_y,F’_z)$</p><p>显式：$z=f(x,y),\vec{n}=(f_x’,f_y’-1)$</p><p>参数式：$\begin{cases} x=x(u,v) \ y=y(u,v) \ z=z(u,v) \end{cases},\vec{n}=(\frac{\eth(y,z)}{\eth(u,v)},\frac{\eth(z,x)}{\eth(u,v)},\frac{\eth(x,y)}{\eth(u,v)})$ </p><h2 id="多元函数的Taylor公式与极值"><a href="#多元函数的Taylor公式与极值" class="headerlink" title="多元函数的Taylor公式与极值"></a>多元函数的Taylor公式与极值</h2><p>二元函数的微分中值定理：$f(x,y)$在凸区域D内有连续的偏导数，则对D内任何两点$(x_1,y_1),(x_2,y_2)$的直线段上一点$(\xi,\zeta)$有$f(x_2,y_2)-f(x_1,y_1)=(x_2-x_1)f_x’(\xi,\zeta)+(y_2-y_1)f_y’(\xi,\zeta)$</p><p>二元函数的Taylor展开公式：$f(x,y)=f(x_0+\Delta x,y_0+\Delta y)=\sum_{m=0}^{n}\frac{1}{m!}D^mf(x_0,y_0)+R_n,R_n=\frac{1}{(n+1)!}D^{n+1}f(x_0+\theta\Delta y,y_0+\theta\Delta y)$</p><p>其中$D=\Delta x \frac{\eth}{\eth x}+\Delta y \frac{\eth}{\eth y},0&lt;\theta &lt;1$</p><h3 id="二元函数的极值"><a href="#二元函数的极值" class="headerlink" title="二元函数的极值"></a>二元函数的极值</h3><h4 id="极值的必要条件"><a href="#极值的必要条件" class="headerlink" title="极值的必要条件"></a>极值的必要条件</h4><p>$f(x,y)$在$(x_0,y_0)$处取到极值，则$f’_x(x_0,y_0)=f’_y(x_0,y_0)=0$</p><h4 id="极值的充分条件"><a href="#极值的充分条件" class="headerlink" title="极值的充分条件"></a>极值的充分条件</h4><p>记Hesse矩阵 $H=\begin{pmatrix} A=f_{xx} &amp; B=f_{xy} \ B=f_{yx} &amp; C=f_{yy} \end{pmatrix}\ Q(h,k)=\begin{pmatrix} h &amp;k \end{pmatrix}H\begin{pmatrix} h \k \end{pmatrix}=Ah^2+2Bhk+Ck^2 ,\Delta=|H|=AC-B^2$</p><ol><li>当$\Delta &gt;0,A&gt;(&lt;)0$时，即Q为正（负）定矩阵，$(x_0,y_0)$为极小（极大）值</li><li>当$\Delta &lt;0$时，即Q为不定矩阵，$(x_0,y_0)$不是极值点</li><li>当$\Delta  =0$时，即Q为半定矩阵，判断失效</li></ol><h4 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h4><ul><li><p>直接法</p><p>如果可以从约束条件$\phi(x,y,z)=0$解出一个变量$z=z(x,y)$则可求$u=f(x,y,z(x,y))$的无条件极值</p></li><li><p>$Lagrange$乘数法</p><p>令$L(x,y,z)=f(x,y,z)+\lambda \phi(x,y,z)$ 求其无条件极值的必要条件，即</p><p>$\begin{cases} L’_x=0 \ L’_y=0 \ L’<em>z=0 \L’</em>\lambda=0 \end{cases}$</p></li></ul><h3 id="二元函数的最值"><a href="#二元函数的最值" class="headerlink" title="二元函数的最值"></a>二元函数的最值</h3><p>原则：有界闭区域上的可微函数的最值在内部驻点或边界点取到</p><p>实际：若在区域内取驻点唯一，此为最值点</p><p>一般就考虑边界和内部，分类讨论，或者一些特殊的没有偏导数的点</p><h2 id="向量场的微商"><a href="#向量场的微商" class="headerlink" title="向量场的微商"></a>向量场的微商</h2><p>$Nabla /Hamilta$算子 $\nabla \phi =grad\phi=\frac{\eth \phi}{\eth x}\vec{i}+\frac{\eth \phi}{\eth y}\vec{j}+\frac{\eth \phi}{\eth z}\vec{k}$</p><p>设有向量场$\vec {v}(x,y,z)=P(x,y,z)\vec{i}+Q(x,y,z)\vec{j}+R(x,y,z)\vec{k}$</p><p>散度定义：$div \vec{v}=\nabla ·\vec{v}=\frac{\eth P}{\eth x}+\frac{\eth Q}{\eth y}+\frac{\eth R}{\eth z}$</p><p>故向量场的散度为数量场</p><p>旋度定义：$rot\vec{v}=\nabla \times \vec{v}=\begin{vmatrix}\vec{i} &amp; \vec{j} &amp;\vec{k} \ \frac{\eth}{\eth x} &amp; \frac{\eth}{\eth y} &amp;\frac{\eth}{\eth z}  \ P &amp; Q &amp; R \end{vmatrix}$</p><p>故向量场的旋度为向量场</p><p>运算律：</p><ol><li>$\nabla(\phi +f)=\nabla \phi+\nabla f$</li><li>$\nabla ·(\vec{a}+\vec{b})=\nabla · \vec{a}+\nabla · \vec{b}$</li><li>$\nabla \times(\vec{a}+\vec{b})=\nabla \times \vec{a}+\nabla \times \vec{b}$</li><li>$\nabla (\phi f)=\phi \nabla f+f\nabla \phi $</li><li>$\nabla (\phi \vec{a})=\phi \nabla ·\vec{a}+\vec{a} ·\nabla \phi $</li><li>$\nabla (\vec{a}\times\vec{b})=\vec{b}·\nabla \times \vec{a}-\vec{a}·\nabla \times \vec{b}$</li><li>$\nabla \times (\phi \vec{a})=\nabla \phi \times \vec{a}+\phi \nabla  \times \vec{a}$</li></ol><h1 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h1><p>定义：$f(x,y)$在有界闭界上定义$D=[a,b]\times [c,d]$,若对其任取矩形分割$( (\varepsilon _i \eta <em>i)\in D</em>{ij}$总有$\lim \limits_{|T| \rightarrow 0}\sum_{i=1}^{n}\sum_{j=1}^{m}f(\varepsilon _i \eta <em>i)\Delta \sigma</em>{ij}=I$</p><p>性质：</p><ol><li>线性</li><li>可加性  </li><li>单调性 $f(x,y) \leq g(x,y),\iint_D f(x,y)d\sigma \leq \iint_D g(x,y)d\sigma$</li><li>绝对值不等式 $|\iint_D f(x,y)d\sigma| \leq \iint_D |f(x,y)|d\sigma$</li><li>中值定理 $f(x,y) \in C(D) ,\exist (\xi ,\eta ) \in D , \iint_Df(x,y)d\sigma =f(\xi,\eta)A_D$</li></ol><p>计算方法：$\iint_{[a,b]\times [c,d]}f(x,y)d\sigma = \int_a^bdx\int_c^df(x,y)dy$</p><p><strong>先画图，再划分区域</strong></p><h1 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常微分方程&quot;&gt;&lt;a href=&quot;#常微分方程&quot; class=&quot;headerlink&quot; title=&quot;常微分方程&quot;&gt;&lt;/a&gt;常微分方程&lt;/h1&gt;&lt;h2 id=&quot;常规解法&quot;&gt;&lt;a href=&quot;#常规解法&quot; class=&quot;headerlink&quot; title=&quot;常规解法&quot;</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="数学分析" scheme="http://yoursite.com/tags/数学分析/"/>
    
  </entry>
  
  <entry>
    <title>C&amp;C++复习笔记</title>
    <link href="http://yoursite.com/2021/01/29/C&amp;C++%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/01/29/C&amp;C++%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-29T21:11:08.000Z</published>
    <updated>2021-11-08T12:00:49.771Z</updated>
    
    <content type="html"><![CDATA[<p><del>清完稿子终于有时间来干正事了</del> 时隔快一个月俺终于开坑了</p><p>主要目的是复习一下C&amp;C++相关的知识</p><p>为下学期的cs100准备一下</p><p>顺便带上基础算法复习 排序算法(10种)，二分，堆栈模拟，贪心等</p><p>题目以模拟为主</p><p>首先是C&amp;C++部分的 比较预习x</p><p><del>以及因为懒栗子我基本照搬菜鸟教程（</del></p><p>会的东西不会提及大概是注重以前没注意过的</p><p>最近好像C#很流行？也许会顺带看一下</p><h1 id="C-amp-C"><a href="#C-amp-C" class="headerlink" title="C&amp;C++"></a>C&amp;C++</h1><p>首先个人认为表面上看这俩最大区别是STL库</p><p>c++因为有了很多快捷的算法和函数之类的东西</p><p>还是先复习变量</p><p><strong>ps：如果是c和c++共通的东西，会用c来举例子</strong></p><p>如果不同会分两种写的</p><h2 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h2><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">char</td><td style="text-align:left">通常是一个字节（八位）, 这是一个整数类型。</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">整型，4 个字节，取值范围 -2147483648 到 2147483647。</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。<img src="/2021/01/29/C&C++复习笔记/1.png" alt="img"></td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">双精度浮点值。双精度是1位符号，11位指数，52位小数。<img src="/2021/01/29/C&C++复习笔记/2.png" alt="img"></td></tr><tr><td style="text-align:left">void</td><td style="text-align:left">表示类型的缺失。</td></tr><tr><td style="text-align:left">long long</td><td style="text-align:left">- 9223372036854775808 ~ 9223372036854775807（20位十进制数）</td></tr></tbody></table><h2 id="关于C-amp-C-的关键字"><a href="#关于C-amp-C-的关键字" class="headerlink" title="关于C&amp;C++的关键字"></a>关于C&amp;C++的关键字</h2><p><img src="/2021/01/29/C&C++复习笔记/15.png" alt=""></p><p><img src="/2021/01/29/C&C++复习笔记/16.jpg" alt=""></p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><h3 id="1．转换说明符"><a href="#1．转换说明符" class="headerlink" title="1．转换说明符"></a>1．转换说明符</h3><p>   %a(%A)   浮点数、十六进制数字和p-(P-)记数法(C99)<br>   %c       字符<br>   %d       有符号十进制整数<br>   %f       浮点数(包括float和double)<br>   %e(%E)   浮点数指数输出[e-(E-)记数法]<br>   %g(%G)   浮点数不显无意义的零”0”<br>   %i       有符号十进制整数(与%d相同)<br>   %u       无符号十进制整数<br>   %o       八进制整数  e.g.   0123<br>   %x(%X)   十六进制整数<br>   %p       指针<br>   %s       字符串<br>   %%      “%”</p><h3 id="2．标志"><a href="#2．标志" class="headerlink" title="2．标志"></a>2．标志</h3><p>   左对齐：”-“  e.g.  “%-20s”<br>   右对齐：”+” e.g.  “%+20s”<br>   空格：若符号为正，则显示空格，负则显示”-“  e.g.  “% “<br>   #：对c,s,d,u类无影响；对o类，在输出时加前缀o；对x类，在输出时加前缀0x；<br>      对e,g,f 类当结果有小数时才给出小数点。</p><h3 id="3．格式字符串（格式）"><a href="#3．格式字符串（格式）" class="headerlink" title="3．格式字符串（格式）"></a>3．格式字符串（格式）</h3><p>   ［标志］［输出最少宽度］［．精度］［长度］类型<br>   “％-md” ：左对齐，若m比实际少时，按实际输出。<br>   “%m.ns”：输出m位，取字符串(左起)n位，左补空格，当n&gt;m or m省略时m=n<br>           e.g.  “%7.2s”  输入CHINA<br>                 　      输出”   CH”<br>   “%m.nf”：输出浮点数，m为宽度，n为小数点右边数位<br>           e.g.  “%”  输入3852.99<br>                        输出3853.0<br>   长度：为ｈ短整形量,ｌ为长整形量</p><p>printf的格式控制的完整格式：<br>% - .n l或h 格式字符<br>下面对组成格式说明的各项加以说明：<br>①%：表示格式说明的起始符号，不可缺少。<br>②-：有-表示左对齐输出，如省略表示右对齐输出。<br>③0：有0表示指定空位填0,如省略表示指定空位不填。<br>④m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。N指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n=6位。<br>⑤l或h:l对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。</p><h2 id="关于extern"><a href="#关于extern" class="headerlink" title="关于extern"></a>关于extern</h2><p>extern用于声明某一个变量而并非定义</p><p>个人感觉和py的global很像，很tm适合出题？？</p><p>但好像只有这一个extern是用来声明全局变量？基本就是一个global的感觉</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token comment" spellcheck="true">// 函数外定义变量 x 和 y</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">addtwonum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 函数内声明变量 x 和 y 为外部变量</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给外部变量（全局变量）x 和 y 赋值</span>    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> result<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用函数 addtwonum</span>    result <span class="token operator">=</span> <span class="token function">addtwonum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"result 为: %d\n"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3</span>    <span class="token comment" spellcheck="true">// 1 2</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依旧感觉没什么卵用md</p><p>但感谢菜鸟教程告诉我了一个用途，在引用自己写的类似包？的时候的用的</p><p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p><p>addtwonum.c 文件代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token comment" spellcheck="true">/*外部变量声明*/</span> <span class="token keyword">extern</span> <span class="token keyword">int</span> x <span class="token punctuation">;</span> <span class="token keyword">extern</span> <span class="token keyword">int</span> y <span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">addtwonum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>test.c 文件代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>   </span><span class="token comment" spellcheck="true">/*定义两个全局变量*/</span> <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">addtwonum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> result<span class="token punctuation">;</span>        result <span class="token operator">=</span> <span class="token function">addtwonum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"result 为: %d\n"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当上面的代码被编译和执行时，它会产生下列结果：</p><pre class="line-numbers language-cpp"><code class="language-cpp">$ gcc addtwonum<span class="token punctuation">.</span>c test<span class="token punctuation">.</span>c <span class="token operator">-</span>o main$ <span class="token punctuation">.</span><span class="token operator">/</span>mainresult 为<span class="token operator">:</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="文件的读入与写入"><a href="#文件的读入与写入" class="headerlink" title="文件的读入与写入"></a>文件的读入与写入</h2><p>c++的话很方便</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">,</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很简单在main的开头加两句就行</p><p>c的话有点麻烦</p><p><strong>写入文件</strong></p><p>首先是有几个模式</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">r</td><td style="text-align:left">打开一个已有的文本文件，允许读取文件。</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td style="text-align:left">r+</td><td style="text-align:left">打开一个文本文件，允许读写文件。</td></tr><tr><td style="text-align:left">w+</td><td style="text-align:left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td style="text-align:left">a+</td><td style="text-align:left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 先是创建一个文件指针？</span>   fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"/tmp/test.txt"</span><span class="token punctuation">,</span> <span class="token string">"w+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"This is testing for fprintf...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"This is testing for fputs...\n"</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两种用法</span>   <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读入文件</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"/tmp/test.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个遇到第一个空格和换行符时，它会停止读取。</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1: %s\n"</span><span class="token punctuation">,</span> buff <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//This</span>   <span class="token function">fgets</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>FILE<span class="token operator">*</span><span class="token punctuation">)</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2: %s\n"</span><span class="token punctuation">,</span> buff <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//is testing for fprintf...</span>   <span class="token function">fgets</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>FILE<span class="token operator">*</span><span class="token punctuation">)</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3: %s\n"</span><span class="token punctuation">,</span> buff <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//This is testing for fputs...</span>   <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于和字符，字符串有关的读入复习</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常用的字符读入，读到空格为止，空格不会被跳过</span><span class="token function">gets</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//读到换行符为止，不读换行符会跳过</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这几个一起读入的时候，适当getchar()来处理空格问题</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%7s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只读前7位，后面输入的不管</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//一直读入，知道遇到EOF为止，在windows里面是CTRL+Z</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>就是常用的if语句，简短精炼，但可读性极差</p><p>复习一下规则</p><p><img src="/2021/01/29/C&C++复习笔记/3.png" alt=""></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>C中一个很神奇的定义，虽然我觉得用处不大，但是没有见过还是写一下</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">enum</span> DAY <span class="token comment" spellcheck="true">//名称可以省略</span><span class="token punctuation">{</span>      MON<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> TUE<span class="token punctuation">,</span> WED<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> FRI<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> SAT<span class="token punctuation">,</span> SUN<span class="token comment" spellcheck="true">//默认后一个值为前一个+1，徐洪剑可以跳跃赋值</span><span class="token punctuation">}</span> day<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1 2 3 4 10 11 12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际调用如下</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">enum</span> DAY<span class="token punctuation">{</span>      MON<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> TUE<span class="token punctuation">,</span> WED<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> FRI<span class="token punctuation">,</span> SAT<span class="token punctuation">,</span> SUN<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">enum</span> DAY day<span class="token punctuation">;</span>    day <span class="token operator">=</span> WED<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>day<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>day <span class="token operator">=</span> MON<span class="token punctuation">;</span> day <span class="token operator">&lt;=</span> SUN<span class="token punctuation">;</span> day<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"枚举元素：%d \n"</span><span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//只有连续的枚举可以遍历</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>每一个储存的变量，都有一个与其对应的储存地址，指针便是指向这个地址，调用该地址的用途</p><p>简单的例子</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span>  var <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 实际变量的声明 */</span>   <span class="token keyword">int</span>  <span class="token operator">*</span>ip<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 指针变量的声明 */</span>   ip <span class="token operator">=</span> <span class="token operator">&amp;</span>var<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 在指针变量中存储 var 的地址 */</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"var 变量的地址: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>var  <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 在指针变量中存储的地址 */</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ip 变量存储的地址: %p\n"</span><span class="token punctuation">,</span> ip <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 使用指针访问值 */</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*ip 变量的值: %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>ip <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//var 变量的地址: 0x7ffeeef168d8</span>    <span class="token comment" spellcheck="true">//ip 变量存储的地址: 0x7ffeeef168d8</span>    <span class="token comment" spellcheck="true">//*ip 变量的值: 20</span>    <span class="token comment" spellcheck="true">//sizeof(&amp;var) 查询指针的大小</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NULL指针"><a href="#NULL指针" class="headerlink" title="NULL指针"></a>NULL指针</h3><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p><p>NULL 指针是一个定义在标准库中的值为零的常量。</p><p>举个栗子</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span>  <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ptr 的地址是 %p\n"</span><span class="token punctuation">,</span> ptr  <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//ptr 的地址是 0x0</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h3><p>指针支持++，–，+，- 总的来说就是可以对地址进行加减来实现遍历作用</p><p>举个栗子</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span>  var<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">int</span>  i<span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 指针中的数组地址 */</span>   ptr <span class="token operator">=</span> var<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最开始默认为一个数字的位置</span>   <span class="token comment" spellcheck="true">//ptr = &amp;var[MAX-1];最后一个位置</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"存储地址：var[%d] = %p\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> ptr <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"存储值：var[%d] = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>ptr <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 指向下一个位置 */</span>      ptr<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针可以用关系运算符进行比较，如 ==、&lt; 和 &gt;</p><p>这个很好理解 不解释了</p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>数组的地址就是储存第一位的地址</p><p>指针指向的内容可以是数字或者字符</p><p>都可以自己定义</p><p>试了一下好像如果是数字不能随便乱搞？</p><p>int指向int是不行的，反正有问题 ，要用只能用系统的地址不能瞎搞</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span>  var<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>var<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 赋值为整数的地址 */</span>   <span class="token punctuation">}</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Value of var[%d] = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>names<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>                   <span class="token string">"Zara Ali"</span><span class="token punctuation">,</span>                   <span class="token string">"Hina Ali"</span><span class="token punctuation">,</span>                   <span class="token string">"Nuha Ali"</span><span class="token punctuation">,</span>                   <span class="token string">"Sara Ali"</span><span class="token punctuation">,</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义指针指向字符串</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Value of names[%d] = %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"loc of names[%d] = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//储存地址打印</span>   <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*Value of names[0] = Zara Ali    loc of names[0] = 90    Value of names[1] = Hina Ali    loc of names[1] = 72    Value of names[2] = Nuha Ali    loc of names[2] = 78    Value of names[3] = Sara Ali    loc of names[3] = 83*/</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很有趣的是用指针定义的字符串和直接用数组定义的字符串，他们两个的地址差距很大x</p><h3 id="多重指针"><a href="#多重指针" class="headerlink" title="多重指针"></a>多重指针</h3><p><img src="/2021/01/29/C&C++复习笔记/4.png" alt=""></p><p>总之还是很好理解的，能套很多层</p><h3 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a>函数与指针</h3><p>函数里也允许定义和传递指针，这个也很好理解</p><p>也允许函数的返回值是指针</p><p>但有一个要注意的地方</p><p><strong>C&amp;C++不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。</strong></p><p>栗子</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> </span><span class="token comment" spellcheck="true">/* 要生成和返回随机数的函数 */</span><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token function">getRandom</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">int</span>  r<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//必须这样写</span>   <span class="token keyword">int</span> i<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 设置种子 */</span>   <span class="token function">srand</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 要调用上面定义函数的主函数 */</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 一个指向整数的指针 */</span>   <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>   <span class="token keyword">int</span> i<span class="token punctuation">;</span>   p <span class="token operator">=</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*(p + [%d]) : %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。</p><p>因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。</p><p>除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。</p><p>感觉理解的不算很透彻，后期再继续补充</p><h3 id="手写swap"><a href="#手写swap" class="headerlink" title="手写swap"></a>手写swap</h3><p>用了指针的写法，反正很绕</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>         tmp<span class="token operator">=</span><span class="token operator">*</span>a<span class="token punctuation">;</span>         <span class="token operator">*</span>a<span class="token operator">=</span><span class="token operator">*</span>b<span class="token punctuation">;</span>         <span class="token operator">*</span>b<span class="token operator">=</span>tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h2 id="一个无语的东西"><a href="#一个无语的东西" class="headerlink" title="一个无语的东西"></a>一个无语的东西</h2><p>在写c代码的时候，无意中发现nmd为什么c不支持定义的时候直接赋值？？？实属弱智操作，每次写循环tmd都要把i放在外面写，乌鱼子 （原来是我没有c11,小丑竟是我自己（</p><p>补充,c没有class气死我了</p><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p><code>malloc()</code>函数，用于向系统申请内存</p><p><code>free()</code>释放<code>malloc</code>或<code>calloc、realloc</code>函数给指针变量分配的内存空间的函数使用后该指针变量一定要重新指向NULL，防止野指针出现，有效 规避误操作。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> <span class="token operator">*</span>pArray<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    pArray<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token operator">*</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将size大小的float空间赋给指针</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pArray<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token operator">*</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*access the array*/</span>    <span class="token function">free</span><span class="token punctuation">(</span>pArray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="算法复习"><a href="#算法复习" class="headerlink" title="算法复习"></a>算法复习</h1><p><strong>用于练习，不做特殊说明都用c来编写</strong></p><h2 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h2><p>首先写一下基本的相关定义</p><p>1、稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。</p><p>2、非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序。</p><p>3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</p><p>4、非原地排序：需要利用额外的数组来辅助排序。</p><p><a href="https://www.cnblogs.com/itsharehome/p/11058010.html" target="_blank" rel="noopener">参考1</a><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">参考2</a></p><p><strong>ps:由于原po很作死想写伪sort代替，于是引入了begin和end参数，导致某些过程变得十分复杂，大家千万不要学我</strong></p><p><strong>一下代码全部是原po自己手撸的，一定不是最简写法，也不好看，就是很好理解，简单来说就是：下面请欣赏Aoki_Umi用作死的c手撸十大排序算法~</strong></p><p>介绍也比较通俗XD</p><p>为什么缩进这么奇怪：\别问，问就是vs自带的</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>冒泡排序作为一种比较经典的算法也算是很好理解的，每次遍历找出最大的数把它依次排在末尾，找到最大的数的方式就是比较相邻两个数的大小，越大的数越往后面移动，全遍历找一遍就行了</p><p><img src="/2021/01/29/C&C++复习笔记/1.gif" alt=""></p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(n^2)$ 最优$O(n)$空间$O(1)$ 总的来说还是很慢的</p><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定排序  ，原地排序</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>普通版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort_Bubble</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> i<span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">></span> begin<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> j<span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> begin<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                           <span class="token punctuation">{</span>                                    <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>                                    tmp<span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                    num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                                    num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                           <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>                           <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化版本：</p><p>假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort_Bubble</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> i<span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">></span> begin<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> j<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> begin<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                           <span class="token punctuation">{</span>                                    <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>                                    tmp<span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                    num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                                    num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                                    flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                           <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>                     <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>                           <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法介绍-1"><a href="#算法介绍-1" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>冒泡排序是选最大往后堆，那么选择排序就是每次找最小的往前堆。找的方法为，把序列分为有序列$R1[1,2,…,i]$与无序列（没有排序过的原始序列）$R2[i+1,i+2,…,n]$两大段，每次找出无序列中最小的元素与无序列中第一个元素交换位置，如此有序列长度逐渐增加直到整个序列有序。</p><p><img src="/2021/01/29/C&C++复习笔记/2.gif" alt=""></p><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(n^2)$无论如何都是$O(n^2)$，空间$O(1)$，实在是慢</p><h4 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h4><p>非稳定排序  ，原地排序</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort_selection</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> i<span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> j<span class="token punctuation">,</span>min<span class="token punctuation">;</span>                  min <span class="token operator">=</span> i<span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>num<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span>                           <span class="token punctuation">{</span>                                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>                           <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>                  tmp <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                  num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>                  num<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法介绍-2"><a href="#算法介绍-2" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>这个算法形象说就是每次把后面一个没排过序的元素不断往有序的元素里面插，从后往前扫，<del>为啥觉得越来越低效了（bushi</del> 这玩意需要手写队列。。。。说实话用c++堆好像是不是好很多（其实就是快乐的优先队列）越来越复杂了x</p><p><img src="/2021/01/29/C&C++复习笔记/3.gif" alt=""></p><h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(n^2)$无论如何都是$O(n^2)$，空间$O(1)$，实在是慢</p><h4 id="稳定性-2"><a href="#稳定性-2" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定排序  ，原地排序</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort_insertion</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> i<span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> begin<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>                  tmp <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token keyword">int</span> j<span class="token punctuation">;</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token operator">></span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//由于我多了参数为了防止意外我写了特判x</span>                           j <span class="token operator">=</span> begin <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                  <span class="token keyword">else</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span>begin<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>                                    <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>tmp<span class="token punctuation">)</span>                                             <span class="token keyword">break</span><span class="token punctuation">;</span>                                             <span class="token punctuation">}</span>                  <span class="token comment" spellcheck="true">//j+1是要插入的位置</span>                  <span class="token keyword">int</span> k<span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">></span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span>                           num<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  num<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="算法介绍-3"><a href="#算法介绍-3" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>是插入排序的优化版本，每次把序列分成len/2组，每组跨元素相邻如图所示，每次按组来进行插入排序，以达到优化的效果</p><p><img src="/2021/01/29/C&C++复习笔记/4.jpg" alt=""></p><h4 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(n^{1.3})$最优$O(n)$最坏$O(n^2)$空间$O(1)$ 玄学的东西</p><h4 id="稳定性-3"><a href="#稳定性-3" class="headerlink" title="稳定性"></a>稳定性</h4><p>非稳定排序 ，原地排序</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>此代码我撸的异常艰辛，主要是因为，太绕了。。。，加了奇怪的参数后</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort_shell</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> gap<span class="token punctuation">;</span>         <span class="token keyword">void</span> <span class="token function">I_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> new_begin<span class="token punctuation">,</span><span class="token keyword">int</span> new_end<span class="token punctuation">,</span><span class="token keyword">int</span> g<span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> i<span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> new_begin<span class="token operator">+</span>g<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> new_end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>                           tmp <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                           <span class="token keyword">int</span> j<span class="token punctuation">;</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>new_begin<span class="token punctuation">]</span><span class="token operator">></span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                                    j <span class="token operator">=</span> new_begin <span class="token operator">-</span> g<span class="token punctuation">;</span>                           <span class="token keyword">else</span>                           <span class="token punctuation">{</span>                                    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token operator">-</span>g<span class="token punctuation">;</span> j <span class="token operator">>=</span>new_begin<span class="token punctuation">;</span>j<span class="token operator">-</span><span class="token operator">=</span>g<span class="token punctuation">)</span>                                             <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>tmp<span class="token punctuation">)</span>                                                      <span class="token keyword">break</span><span class="token punctuation">;</span>                                                      <span class="token punctuation">}</span>                           <span class="token comment" spellcheck="true">//j+1是要插入的位置</span>                           <span class="token keyword">int</span> k<span class="token punctuation">;</span>                           <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">></span> j <span class="token operator">+</span> g<span class="token punctuation">;</span>k<span class="token operator">-</span><span class="token operator">=</span>g<span class="token punctuation">)</span>                                    num<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>k <span class="token operator">-</span> g<span class="token punctuation">]</span><span class="token punctuation">;</span>                           num<span class="token punctuation">[</span>j <span class="token operator">+</span> g<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                  <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">int</span> len<span class="token punctuation">;</span>         len <span class="token operator">=</span> end <span class="token operator">-</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>gap<span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>gap<span class="token operator">/</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> begin<span class="token punctuation">,</span>j<span class="token operator">=</span>end<span class="token operator">-</span>gap<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> begin <span class="token operator">+</span> gap<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                           <span class="token function">I_sort</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> gap<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法介绍-4"><a href="#算法介绍-4" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>一款很线段树的排序算法x分治思想易于理解。</p><p>主要思路是把区间每次一分为二，不断拆分成小的区间，每次大区间由两个已经有序的小区间合并，不断变得有序的过程。</p><p>问题是如何实现合并呢，这里用到的就是两个队列了。由于子区间一定有序，每次只要比较两个队列队头的大小，将小的加入新队列并将其弹出，直到一个队列元素全部弹完停止循环，就很好理解。</p><p><img src="/2021/01/29/C&C++复习笔记/5.gif" alt=""></p><h4 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(nlogn)$空间$O(n)$<del>这很线段树</del></p><h4 id="稳定性-4"><a href="#稳定性-4" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定排序 ，非原地排序</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>一举成功，一气呵成，爽</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort_merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> fr1<span class="token punctuation">,</span> fr2<span class="token punctuation">,</span>tl1<span class="token punctuation">,</span>tl2<span class="token punctuation">;</span>                  fr1 <span class="token operator">=</span> l<span class="token punctuation">;</span>                  fr2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                  tl1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>                  tl2 <span class="token operator">=</span> r<span class="token punctuation">;</span>                  <span class="token keyword">int</span> new<span class="token punctuation">[</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span>flag<span class="token punctuation">;</span>                  flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>fr1<span class="token operator">></span>tl1<span class="token punctuation">)</span>                           <span class="token punctuation">{</span>                                    flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                           <span class="token punctuation">}</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>fr2<span class="token operator">></span>tl2<span class="token punctuation">)</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>fr1<span class="token punctuation">]</span><span class="token operator">></span>num<span class="token punctuation">[</span>fr2<span class="token punctuation">]</span><span class="token punctuation">)</span>                           <span class="token punctuation">{</span>                                    new<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>fr2<span class="token punctuation">]</span><span class="token punctuation">;</span>                                    fr2<span class="token operator">++</span><span class="token punctuation">;</span>                           <span class="token punctuation">}</span>                           <span class="token keyword">else</span>                            <span class="token punctuation">{</span>                                    new<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>fr1<span class="token punctuation">]</span><span class="token punctuation">;</span>                                    fr1<span class="token operator">++</span><span class="token punctuation">;</span>                           <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>fr1<span class="token operator">++</span><span class="token punctuation">)</span>                                    new<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>fr1<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">else</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>fr2<span class="token operator">++</span><span class="token punctuation">)</span>                                    new<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>fr2<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">int</span> j<span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                           num<span class="token punctuation">[</span>l <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> new<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">void</span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span>                           <span class="token keyword">return</span><span class="token punctuation">;</span>                  <span class="token keyword">int</span> mid<span class="token punctuation">;</span>                  mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                  <span class="token function">split</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">split</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">merge</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token function">split</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法介绍-5"><a href="#算法介绍-5" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>其实写这篇的主要原因就是你校夏令营面试的题目。。。。当初他让我介绍快速排序，然而我对快排一无所知。。于是就一直很想写一个排序算法介绍orz</p><p>快排是一个运用很广泛的排序算法吧，主要思想也是分治，但叙述起来比较麻烦。</p><p>主要分为三步：①找一个基准（普通来说直接选区间第一个）②通过位置的比较交换让该基准左边数都小于他，右边数都大于他，于是该数的位置就确定了③再把两边的区间重复这个操作直到每个数都找到自己的位置x</p><p>比较抽象的就是<strong>如何让他左边都大于自己，右边都小于自己</strong>（说实话下面这个图我看不懂）</p><p>我看到的另一种解释比较容易理解：将序列看作也该双端队列两个指针fr，tl分别指向队头和队尾，以及一个当前变量x。</p><p>首先令<code>x=a[fr]</code>也就是先把第一个当作基准</p><p>再从队尾往前扫找到比x小的第一个数，<code>a[fr]=a[tl]</code>将其放在之前x的位置</p><p>再从队头开始往后扫找到比x大的第一个数，<code>a[tl]=a[fr]</code>将其放在之前队尾指向的位置</p><p>如此不断循环直到<code>fr==tl,a[fr]=a[tl]=x</code>如此这般，x就找到位置了。</p><p>通俗来讲就是用小的数填充靠前的位置，大的数填充靠后的位置，最后剩下的就是x的位置了</p><p>这个就很好理解，手撸应该挺容易x</p><p><img src="/2021/01/29/C&C++复习笔记/6.gif" alt=""></p><h4 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(nlogn)$最坏$O(n^2)$空间$O(nlogn)$</p><h4 id="稳定性-5"><a href="#稳定性-5" class="headerlink" title="稳定性"></a>稳定性</h4><p>非稳定排序，原地排序</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p>有些头尾端点情况判断也要注意，稍微调一下就行</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort_quick</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> <span class="token function">find_place</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> x<span class="token punctuation">,</span> fr<span class="token punctuation">,</span> tl<span class="token punctuation">;</span>                  x <span class="token operator">=</span> num<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                  fr <span class="token operator">=</span> l<span class="token punctuation">;</span>                  tl <span class="token operator">=</span> r<span class="token punctuation">;</span>                  <span class="token keyword">while</span><span class="token punctuation">(</span>tl<span class="token operator">></span>fr<span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">while</span><span class="token punctuation">(</span>fr<span class="token operator">&lt;</span>tl<span class="token operator">&amp;&amp;</span>num<span class="token punctuation">[</span>tl<span class="token punctuation">]</span><span class="token operator">>=</span>x<span class="token punctuation">)</span>                                    tl<span class="token operator">--</span><span class="token punctuation">;</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>tl<span class="token operator">==</span>fr<span class="token punctuation">)</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                           num<span class="token punctuation">[</span>fr<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>tl<span class="token punctuation">]</span><span class="token punctuation">;</span>                           fr<span class="token operator">++</span><span class="token punctuation">;</span>                           <span class="token keyword">while</span><span class="token punctuation">(</span>fr<span class="token operator">&lt;</span>tl<span class="token operator">&amp;&amp;</span>num<span class="token punctuation">[</span>fr<span class="token punctuation">]</span><span class="token operator">&lt;=</span>x<span class="token punctuation">)</span>                                    fr<span class="token operator">++</span><span class="token punctuation">;</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>tl<span class="token operator">==</span>fr<span class="token punctuation">)</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                           num<span class="token punctuation">[</span>tl<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>fr<span class="token punctuation">]</span><span class="token punctuation">;</span>                           tl<span class="token operator">--</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  num<span class="token punctuation">[</span>fr<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>                  <span class="token keyword">return</span> fr<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">void</span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">>=</span>r<span class="token punctuation">)</span>                           <span class="token keyword">return</span><span class="token punctuation">;</span>                  <span class="token keyword">int</span> loc<span class="token punctuation">;</span>                  loc <span class="token operator">=</span> <span class="token function">find_place</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">split</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> loc<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">split</span><span class="token punctuation">(</span>loc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token function">split</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="算法介绍-6"><a href="#算法介绍-6" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>这个要运用二叉树，大根堆小根堆的知识了，属于比较高级的算法。</p><p>二叉树就不解释了，主要谈谈大根堆和小根堆 <a href="https://www.runoob.com/w3cnote/quick-sort.html" target="_blank" rel="noopener">优质博客</a></p><p><img src="/2021/01/29/C&C++复习笔记/5.png" alt=""></p><p><img src="/2021/01/29/C&C++复习笔记/6.png" alt=""></p><p>大顶堆：<code>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</code></p><p>小顶堆：<code>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</code></p><p>图非常好懂了就不解释了</p><p>而堆排序就是以此为基础的排序算法.</p><p>方法是:①首先以原始序列为基础构建大/小根堆,示例为大根堆.②每次将堆顶与为末尾的<strong>无序元素</strong>交换,并交换后重新调整堆的结构使其仍然是大根堆③不断重复此交换直到序列全部有序</p><p>但怎么建立一个大根堆呢?</p><p><img src="/2021/01/29/C&C++复习笔记/7.png" alt=""></p><p>我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 <code>arr.length/2-1=5/2-1=1</code>，也就是下面的6结点），从左至右，从下至上进行调整。像图例不断交换</p><p><img src="/2021/01/29/C&C++复习笔记/8.png" alt=""></p><p><img src="/2021/01/29/C&C++复习笔记/9.png" alt=""></p><p><img src="/2021/01/29/C&C++复习笔记/10.png" alt=""></p><p>下面是形象表示交换的过程w</p><p><img src="/2021/01/29/C&C++复习笔记/11.png" alt=""></p><p><img src="/2021/01/29/C&C++复习笔记/12.png" alt=""></p><p><img src="/2021/01/29/C&C++复习笔记/13.png" alt=""></p><p><img src="/2021/01/29/C&C++复习笔记/14.png" alt=""></p><h4 id="复杂度-6"><a href="#复杂度-6" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(nlogn)$空间$O(1)$</p><h4 id="稳定性-6"><a href="#稳定性-6" class="headerlink" title="稳定性"></a>稳定性</h4><p>非稳定排序，原地排序</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p>ps:由于个人习惯,堆还是以1开始编号</p><p>这玩意整了很久，，，因为有点忘了</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort_heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//由于堆的节点编号与其性质息息相关,把需要排序的部分切出来做排序会比较合适()</span>         <span class="token keyword">int</span> a<span class="token punctuation">[</span>end<span class="token operator">-</span>begin<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span>cnt<span class="token punctuation">;</span>         cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  a<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">void</span> <span class="token function">build_heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> ch<span class="token punctuation">;</span>                  ch <span class="token operator">=</span> p<span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> ch <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span>ch<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;=</span>len <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>ch<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>a<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">)</span>                                    ch<span class="token operator">++</span><span class="token punctuation">;</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">&lt;=</span>a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                           <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           p <span class="token operator">=</span> ch<span class="token punctuation">;</span>                  <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">int</span> p<span class="token punctuation">;</span>         p <span class="token operator">=</span> cnt <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> p<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>                  <span class="token function">build_heap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> cnt<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">build_heap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是所有比较型的排序都搞完了，接下来是计数型排序</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="算法介绍-7"><a href="#算法介绍-7" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>看完介绍，我：这算法也太tm暴力了吧。。。。就是开数组打标，看每个数出现的次数再把他全部排一遍。。。好家伙也太暴力了SOS </p><p>好家伙这玩意还不支持负数，太弱鸡了。。。</p><h4 id="复杂度-7"><a href="#复杂度-7" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(n+k)  $空间$O(k)  $ <del>MLE警告阿SOS</del></p><h4 id="稳定性-7"><a href="#稳定性-7" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定排序，非原地排序</p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><p>弱智代码.jpg</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort_count</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> maxx<span class="token punctuation">,</span>ans<span class="token punctuation">[</span>end<span class="token operator">-</span>begin<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">,</span>minn<span class="token punctuation">;</span>         maxx <span class="token operator">=</span> num<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>         minn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> i<span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>minn<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>minn<span class="token punctuation">,</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> flag<span class="token punctuation">[</span>maxx<span class="token operator">-</span>minn<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxx<span class="token operator">-</span>minn<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                  flag<span class="token punctuation">[</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minn<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>         cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxx<span class="token operator">-</span>minn<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">int</span> j<span class="token punctuation">;</span>                           <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                                    ans<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span>minn<span class="token punctuation">;</span>                  <span class="token punctuation">}</span>         cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="算法介绍-8"><a href="#算法介绍-8" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>感觉是比较迷惑的算法，据说很快很牛逼，确实也挺牛的。但由于我不会链表，俺还是用 c++ vector来实现。。</p><p>是计数排序的高级版，总的来说就是把序列所有数据的区间分段，相当于分为多个桶，然后把数据一次按区间分别放到各个桶中，在每个桶中分别排序，最后将其合并就完了。</p><p>至于怎么查找区间内的所有数，来人，上二分！x</p><p>感觉很玄学不知道为啥这样就快很多了，据说数据越多越快x</p><p><img src="/2021/01/29/C&C++复习笔记/9.jpg" alt=""></p><h4 id="复杂度-8"><a href="#复杂度-8" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(n+k)  $最坏$O(n^2)$空间$O(n+k)  $ </p><h4 id="稳定性-8"><a href="#稳定性-8" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定排序，非原地排序</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><p>注意奇怪的细节（</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort_bucket</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> len <span class="token operator">=</span> end <span class="token operator">-</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> maxx <span class="token operator">=</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> minn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  minn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minn<span class="token punctuation">,</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">int</span> d <span class="token operator">=</span> maxx <span class="token operator">-</span> minn<span class="token punctuation">;</span>         <span class="token keyword">int</span> bucket_cnt <span class="token operator">=</span> d <span class="token operator">/</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> bucket<span class="token punctuation">[</span>bucket_cnt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> list<span class="token punctuation">[</span>bucket_cnt<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bucket_cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> minn <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">int</span> loc <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>list <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> list <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> bucket_cnt<span class="token punctuation">,</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>list<span class="token number">-1</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>loc<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>loc<span class="token operator">++</span><span class="token punctuation">;</span>                   bucket<span class="token punctuation">[</span>loc<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">int</span> cnt <span class="token operator">=</span> begin<span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bucket_cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                   <span class="token function">sort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                           num<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="算法介绍-9"><a href="#算法介绍-9" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>总的来说也是一种比较神奇的桶排，然后呢也比较鸡肋，只适合小范围的数据排序。</p><p>准备10个桶分别代表数字0-9，以个位数为第一个基准，将所有的数据按个位数字投进10个桶中，再按0-9的顺序将数据倒出来，接下来按十位，百位，依次类推，直到最高位，就挺好玩的x</p><p>由于c没有动态数组，还是用c++写</p><p><img src="/2021/01/29/C&C++复习笔记/10.gif" alt=""></p><h4 id="复杂度-9"><a href="#复杂度-9" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间$O(nk)$空间$O(n+k)$</p><h4 id="稳定性-9"><a href="#稳定性-9" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定排序，非原地排序（只要是计数类都是这样）</p><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort_radio</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                  maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>mod<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>dev<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>maxx<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  maxx <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                  cnt<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> bucket<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>dev<span class="token operator">*</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>mod<span class="token operator">*</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> begin<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> dev<span class="token punctuation">;</span>                           bucket<span class="token punctuation">[</span>number<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">int</span> coc <span class="token operator">=</span> begin<span class="token punctuation">;</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>                                    num<span class="token punctuation">[</span>coc<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                           bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>终于都写完啦撒花~~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;del&gt;清完稿子终于有时间来干正事了&lt;/del&gt; 时隔快一个月俺终于开坑了&lt;/p&gt;
&lt;p&gt;主要目的是复习一下C&amp;amp;C++相关的知识&lt;/p&gt;
&lt;p&gt;为下学期的cs100准备一下&lt;/p&gt;
&lt;p&gt;顺便带上基础算法复习 排序算法(10种)，二分，堆栈模拟，贪心等&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="C&amp;C++" scheme="http://yoursite.com/categories/CS/C-C/"/>
    
    
    <category term="排序" scheme="http://yoursite.com/tags/排序/"/>
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="C&amp;C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>数学分析I总结归纳</title>
    <link href="http://yoursite.com/2020/11/12/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90I%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/11/12/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90I%E6%80%BB%E7%BB%93/</id>
    <published>2020-11-13T03:37:22.000Z</published>
    <updated>2021-04-23T11:29:45.795Z</updated>
    
    <content type="html"><![CDATA[<p>由于马上要数分考试了，所以赶紧来整理一波数分相关知识点来复习x</p><p>大概以每章节的大块知识点进行分类，然后分别围绕知识点总结和体型做法总结。</p><p><del>具体概念目前仅限部分概念的完全罗列x</del></p><h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><h2 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h2><h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><ol><li><p>实数公理 与 实数稠密性</p></li><li><p>数列极限的定义:</p><p> $\forall \varepsilon &lt;0,\exists N \in N_*$时 $\forall n&gt;N$ , 有$| a_n-a| &lt; \varepsilon$ 则称${a_n}$的极限为a，记为$lim a_n =a (n -&gt;\inf )$</p></li><li><p>数列有界，上确界和下确界</p></li><li><p>确界原理：非空上（下）有界集必有上（下）确界</p></li><li><p>区间套定理</p></li><li><p>$Stolz$定理</p></li><li><p>$Cauchy$第一定理：算数平均值的极限等于原极限，几何平均值的极限等于原极限</p></li><li><p>$Cauchy$第二定理</p></li></ol><h4 id="性质类"><a href="#性质类" class="headerlink" title="性质类"></a>性质类</h4><ol><li>收敛数列的性质</li></ol><ul><li>极限唯一</li><li>收敛数列必有界</li><li>无界数列必发散</li><li>不等式性（$lim a_n=a,lim b_n=b $ &amp; $a&gt;b$ 则 $a_n &gt; (a+b)/2 &gt; b_n$ )</li><li>保号性（$lim a_n=a,\exists N \in N_* $ 当$n&gt;N$ 有$|a_n &gt;|a|/2&gt;0$)</li><li>夹逼性</li><li>推论1</li><li>推论2</li></ul><ol start="2"><li><p>极限四则运算<strong>（必须为有限项）</strong></p></li><li><p>数列的子列收敛 $\Leftrightarrow$ 数列收敛</p></li><li><p>单调有界数列必收敛（从某项开始）</p></li></ol><h3 id="常用结论"><a href="#常用结论" class="headerlink" title="常用结论"></a>常用结论</h3><p>$$<br>\lim\limits_{x\rightarrow\infty} \sqrt[n]{a}=1(a&gt;0)<br>\lim\limits_{x\rightarrow\infty} \sqrt[n]{n}=1<br>$$</p><p>$$<br>\frac{1}{n+1} &lt;ln(1+\frac{1}{n}) &lt;\frac{1}{n}<br>$$</p><p>$$<br>\lim\limits_{x\rightarrow\infty} (1+\frac{1}{n})^{n} =e<br>$$</p><h2 id="函数极限"><a href="#函数极限" class="headerlink" title="函数极限"></a>函数极限</h2><ol><li>函数极限的定义：①左右极限②在点$x_0$③在正负无穷</li><li>性质：①唯一性②局部有界性③局部保号性④局部不等式性⑤夹逼性</li><li>四则运算（若有一个函数有未知极限也可以用</li><li>变量替换原则</li><li>$Heine$归并定理（常用于证明极限不存在）</li><li>$Cauchy$收敛准则</li><li>无穷大量与无穷小量</li><li>幂指函数求极限的公式</li><li>有理函数的极限公式</li></ol><p><strong>ps:以下替换只能用于乘除法，加减坚决不行，加减建议使用Taylor展开</strong><br>$$<br>x-&gt;0, x=sinx=tanx=ln(1+x)=e^x-1=arcsinx=arctanx<br>$$</p><p>$$<br>x-&gt;0,(1+x)^a=ax,1-cosx=\frac{1}{2}x^2<br>$$</p><h1 id="单变量函数的连续性"><a href="#单变量函数的连续性" class="headerlink" title="单变量函数的连续性"></a>单变量函数的连续性</h1><ol><li><p>连续的定义：$f:U(x_0)\rightarrow R,\lim\limits_{x\rightarrow x_0} f(x)=f(x_0) $</p></li><li><p>左连续与右连续的定义</p></li><li><p>间断点的定义与分类：①可去间断点：$ f(x_0+0)=f(x_0-0)\neq f(x_0)$②跳跃间断点$f(x_0+0)\neq f(x_0-0)$</p></li><li><p>运算法则：四则运算和代换都可以满足</p><p><strong>闭区间上连续函数的性质</strong></p><ol><li>零点定理：若$ f\in [a,b],f(a)*f(b)&lt;0,\exists  \varepsilon \in(a,b)f(\varepsilon)=0$</li><li>介值定理：若$ f\in [a,b],f(a)&lt;f(b),\forall \mu \in (f(a),f(b)),\exists  \varepsilon \in(a,b)使f(\varepsilon)=\mu$</li><li>有界性</li><li>最值性</li></ol></li></ol><h2 id="一致连续"><a href="#一致连续" class="headerlink" title="一致连续"></a>一致连续</h2><ol><li><p>定义：$\forall \varepsilon &gt;0,\forall x’,x’’ \in I,|x’-x’’|&lt;\delta,|f(x’)-f(x’’)|&lt;\varepsilon $  则f在I 上一致连续</p></li><li><p>$Cantor$定理：$f\in C[a,b] \rightarrow f\in U.C[a,b]$</p></li><li><p>$f \in U.C[a,b],\Leftrightarrow \exists f(a+0),f(b+0)$ </p></li><li><p>命题：$f \in C[a,\infty]\lim\limits_{x\rightarrow\infty} f(x)=A\in R$,则$ f \in U.C[A,\infty]$</p></li></ol><h1 id="单变量函数的微分学"><a href="#单变量函数的微分学" class="headerlink" title="单变量函数的微分学"></a>单变量函数的微分学</h1><p>此章节主要以罗列知识点为主</p><h2 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h2><ol><li>$Fermat$定理：若f在$x_0$取极值点且在此处可导，则$f’(x)=0$ 导数为0的点叫做驻点</li><li>$Rolle$定理：f在闭区间连续开区间可导则f能去掉区间最大最小值内所有的值</li><li>$Lagrange$（拉格朗日）中值定理：f在闭区间连续开区间可导区间 $\varepsilon \in[a,b]$ 使$ f’(\varepsilon)=\frac{f(b)-f(a)}{b-a}$<ul><li>推论：f在I上连续且对$\forall x$ 有f(x)=0,则f为常值函数</li><li>推论：$|f(x)|&lt;M,|f(x_2 )-f(x_1)|&lt;M|x_2 -x_1|$</li></ul></li><li>$Cauchy$中值定理：f在闭区间连续开区间可导，$\forall x \in(a,b) ,g’(x) \not=0 ,\exists \varepsilon\in(a,b) ,\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f’(\varepsilon)}{f(\varepsilon_)}  $</li><li>$Darboux$定理：$f \in D[a,b], f’(a)*f’(b)&lt;0 \exists \varepsilon \in(a,b) ,f’(\varepsilon)&gt;0$ </li><li>洛必达法则 0/0,$\infty /\infty$</li><li>$leibniz$法则（n阶导数）</li><li>反函数求导方法</li></ol><h2 id="函数的凸性"><a href="#函数的凸性" class="headerlink" title="函数的凸性"></a>函数的凸性</h2><ol><li>定义$\forall x_1,x_2 \in I,\forall a \in (0,1)f(ax_1+(1-a)x_2)\le af(x_1)+(1-a)f(x_2)$ </li><li>性质：f是区间上凸函数，则$\forall x \in I$ 斜率函数$k(x)=(f(x)-f(x_0))/(x-x_0)$ 在I上单增</li><li>第一充要条件：$f\in C[a,b],D[a,b]$则f(x)是[a,b]上的凸函数$\Leftrightarrow f’(x)$ 在(a,b)上单增</li><li>第二充要条件：f(x)是[a,b]上的凸函数且在[a,b]连续并二阶可导$\Leftrightarrow f’’(x)&gt;0$ </li><li>拐点定义：拐点两边有严格不同的凸凹性，只存在与二阶导数为0或不存在的点</li></ol><h2 id="Taylor展开"><a href="#Taylor展开" class="headerlink" title="Taylor展开"></a>Taylor展开</h2><ol><li><p>基本式子<br>$$<br>f(x)= \sum_{k=0}^n \frac{f^{(k)}(x_0)}{k！}(x-x_0)^k +o(x-x_0)^n   (peano余项)<br>$$</p><p>$$<br>+\frac{f^{(n+1)}(\varepsilon)}{(n+1)!}(x-x_0)^{n+1}(lagrange余项)<br>$$</p></li></ol><ol start="2"><li>$Maclaurin$公式<br>$$<br>f(x)=\sum_{k=0}^n \frac{f^{(k)}(0)}{k！}x^k+\begin{cases}o(x^n) &amp;(x-&gt;0)\ \frac{f^{(n+1)(\theta x)}}{(n+1)!x^{n+1} }&amp;(0&lt;\theta&lt;1)\end{cases}<br>$$</li></ol><ol start="3"><li>常见函数的Taylor展开式（自行手写）</li></ol><p><strong>应用</strong></p><ol><li>用Taylor展开化简求极限</li><li>将函数的n阶导数与原函数建立关系，证明不等式</li></ol><p><strong>ps :积分部分自行总结，东西太多自行手写（接下来上无穷级数</strong></p><h1 id="不定积分求法总结"><a href="#不定积分求法总结" class="headerlink" title="不定积分求法总结"></a>不定积分求法总结</h1><p>​    </p><p><strong>ps：定积分部分过于繁杂自行复习笔记</strong></p><h1 id="无穷级数"><a href="#无穷级数" class="headerlink" title="无穷级数"></a>无穷级数</h1><h2 id="判断级数是否收敛"><a href="#判断级数是否收敛" class="headerlink" title="判断级数是否收敛"></a>判断级数是否收敛</h2><h3 id="普通级数"><a href="#普通级数" class="headerlink" title="普通级数"></a>普通级数</h3><ol><li>$ Cauchy$判别法</li><li>部分和${S_n}$ 有上界</li><li>比较判别法（直接形式，极限形式，比值形式）</li><li>p-判别法（引入$x^p$）</li><li>开n次根号判别法 ($\sqrt[n]{a}$)</li><li>比值判别法（$a_{n+1}/a_n$)</li><li>$Rabbe$判别法</li><li>A-D判别法：①$b_n$单调有界，$a_n$收敛②$b_n$单调趋近于0，$a_n$部分有界</li></ol><h3 id="交错级数"><a href="#交错级数" class="headerlink" title="交错级数"></a>交错级数</h3><p>$leibniz$判别法：$a_n$ 单减且极限趋近于0</p><h3 id="一致收敛"><a href="#一致收敛" class="headerlink" title="一致收敛"></a>一致收敛</h3><ol><li>定义：$\forall  \varepsilon  &gt;0,\exists N=N( \varepsilon ) \in N^*,\forall n&gt;N,\forall x\in I,|f_n(x)-f(x)|&lt; \varepsilon $ 则$f_n(x)$一致收敛于f(x)</li></ol><p><strong>判别法</strong></p><ol><li>区别：点太收敛 $\forall x\in I,\forall  \varepsilon  &gt;0,\exists N=N( \varepsilon ,x) \in N^*,\forall n&gt;N,|f_n(x)-f(x)|&lt; \varepsilon $ 可见一致收敛的条件更严格</li><li>确界定理:  $\lim\limits_{n\rightarrow\infty} sup|f_n(x)-f(x)|=0 \Leftrightarrow$ $f_n(x)$ 一致收敛于$f(x)$ </li><li>$Cauchy$一致收敛准则$\forall  \varepsilon  &gt;0,\exists N=N( \varepsilon ) \in N^*,\forall n&gt;N,\forall p \in N,\forall x\in I,|f_{n+p}(x)-f_n(x)|&lt; \varepsilon $  </li><li>$Weierstrass$ 判别法：$|u_n(x)|&lt;a_n$ 且$ \sum a_n$收敛</li><li>A-D判别法：① $\sum u_n(x)$  <strong>一致</strong>收敛，$v_n(x)$关于n单调且<strong>一致</strong>有界②$\sum u_n(x)$ 的部分和函数$s_n(x)$在I <strong>一致</strong>有界，$\forall $固定$x \in I ,v_n(x)$关于n单减在I上<strong>一致</strong>趋于0</li></ol><p><strong>性质</strong></p><ol><li>连续性</li><li>逐项可积性</li><li>逐项可微性</li><li>部分可以满足极限内外交换（题目中一旦遇到，应该是可以的）</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>若级数收敛，则$a_n$的极限一定为0</li><li>条件收敛与绝对收敛</li><li>满足绝对收敛则一定条件收敛</li><li>级数收敛性有线性加减性</li><li>$Riemann$定理：收敛级数的更序级数仍然收敛</li><li>$Abel$变换</li><li>$Abel$引理</li></ol><h2 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h2><ol><li>$Abel$第一定理:幂函数在$x_0$收敛则当$|x|&lt;|x_0|$一致收敛，幂函数在$x_0$发散则当$|x|&gt;|x_0|$发散</li><li>幂函数收敛域的情况：①仅在x=0发散②在(-R,R)绝对收敛，在其他范围发散③在R发散</li><li>收敛半径的计算$p=\lim\frac{|a_n|}{|a_{n+1}|} 或\lim\frac{1}{ \sqrt[n]{|a_n|}}$</li><li>$Abel$第二定理</li><li>$Abel$第三定理:在趋于收敛半径极限极限可以内外交换</li></ol><p><strong>性质</strong></p><ol><li>连续性</li><li>逐项可积性</li><li>逐项可微性</li></ol><h3 id="如何求幂级数的和函数"><a href="#如何求幂级数的和函数" class="headerlink" title="如何求幂级数的和函数"></a>如何求幂级数的和函数</h3><ol><li>常见函数：</li></ol><p>$$<br>\sum_{n=1}^{\infty}\frac{x^n}{n}=ln\frac{1}{1-x}<br>\sum_{n=0}^{\infty}x^n=\frac{1}{1-x}<br>\sum_{n=1}^{\infty}x^n=\frac{x}{1-x}<br>$$</p><p>$$<br>\sum_{n=0}^{\infty}nx^n=\frac{x}{(1-x)^2}<br>$$</p><p>$$<br>\sum_{n=0}^{\infty}\frac{x^n}{n!}=e^x<br>$$</p><ol start="2"><li>方法：花式求导，逐项可导性的运用</li></ol><h3 id="如何求幂级数的Taylor展开式"><a href="#如何求幂级数的Taylor展开式" class="headerlink" title="如何求幂级数的Taylor展开式"></a>如何求幂级数的Taylor展开式</h3><ol><li>背熟常见函数的形式（过于复杂不想列举）</li><li>直接法：先求n阶导再进行推导</li><li>间接法：利用已知的函数展开式进行变形</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于马上要数分考试了，所以赶紧来整理一波数分相关知识点来复习x&lt;/p&gt;
&lt;p&gt;大概以每章节的大块知识点进行分类，然后分别围绕知识点总结和体型做法总结。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;具体概念目前仅限部分概念的完全罗列x&lt;/del&gt;&lt;/p&gt;
&lt;h1 id=&quot;极限&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="数学分析" scheme="http://yoursite.com/tags/数学分析/"/>
    
  </entry>
  
  <entry>
    <title>SP学习笔记——Matlab使用篇</title>
    <link href="http://yoursite.com/2020/10/19/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Matlab%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
    <id>http://yoursite.com/2020/10/19/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Matlab%E4%BD%BF%E7%94%A8%E7%AF%87/</id>
    <published>2020-10-19T06:50:08.722Z</published>
    <updated>2021-09-27T11:40:32.640Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习信号处理x</p><p>涉及到matlab的各种使用开坑记录学习</p><p>依旧采用python学习笔记的格式写法</p><hr><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>有很多读入方法</p><p>读入文件</p><pre class="line-numbers language-matlab"><code class="language-matlab"><span class="token function">load</span><span class="token punctuation">(</span>"xxxx<span class="token punctuation">.</span>mat"<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">% 一般是，matlabdata格式x</span><span class="token function">imread</span><span class="token punctuation">(</span>"xxx<span class="token punctuation">.</span>jpg"<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">% 读入图像，返回改图像的矩阵</span>img<span class="token operator">=</span><span class="token function">imread</span><span class="token punctuation">(</span>"xxx<span class="token punctuation">.</span>jpg"<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">img</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">;</span><span class="token operator">:</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">% -> R的矩阵格式</span><span class="token function">img</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">;</span><span class="token operator">:</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">% -> G的矩阵格式</span><span class="token function">img</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">;</span><span class="token operator">:</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">% -> B的矩阵格式</span>x<span class="token operator">=</span><span class="token function">xlsread</span><span class="token punctuation">(</span>"xxx<span class="token punctuation">.</span>xlsx"<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%读入excel</span><span class="token comment" spellcheck="true">%还有很多种读入</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户读入</p><pre class="line-numbers language-matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token function">input</span><span class="token punctuation">(</span>"You must write something here"<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%可以读入整数，字符，矩阵等</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre class="line-numbers language-matlab"><code class="language-matlab">figure <span class="token punctuation">,</span> <span class="token function">imshow</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token comment" spellcheck="true">% 打开一个窗口->figure 显示图像</span><span class="token comment" spellcheck="true">%普通显示数据只需要</span>x <span class="token comment" spellcheck="true">%不加分号自动显示</span><span class="token function">xlswrite</span><span class="token punctuation">(</span><span class="token string">'data.xlsx'</span><span class="token punctuation">,</span>ans<span class="token punctuation">,</span><span class="token string">'Sheet1'</span><span class="token punctuation">,</span><span class="token string">'C2'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">% 输出到表格，（文件名,变量,哪张表,第几行）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>matlab里面好像主要用矩阵比较多</p><p>也能直接生成等比数列构成的数组</p><pre class="line-numbers language-matlab"><code class="language-matlab">a<span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span> # <span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">9</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>  # <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span>  # <span class="token number">10</span> <span class="token number">9</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">6</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span># 以最后一次定义为准<span class="token function">a</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> # <span class="token number">1</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">;</span> # <span class="token number">1</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> # <span class="token number">10</span> <span class="token number">9</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">6</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token keyword">end</span><span class="token operator">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> # <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>矩阵是matlab作业里常用的东西 要熟练运用</p><p>首先是基本定义</p><pre class="line-numbers language-matlab"><code class="language-matlab">a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">% ;代表每一行的分割符</span><span class="token comment" spellcheck="true">% 1 2 3</span><span class="token comment" spellcheck="true">% 4 5 6</span>a<span class="token operator">=</span><span class="token function">zeros</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">% 创建一个几行几列全是0的矩阵</span>a<span class="token operator">=</span><span class="token function">ones</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">% 创建一个几行几列全是1的矩阵</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>数组运算<br><code>+ , - , .*, ./, .\</code><br>对元素执行。<br>x = A./B用 A 的每个元素除以 B 的对应元素。</p><p>x = A.\B 用 B 的每个元素除以 A 的对应元素。</p><p>矩阵运算<br><code>*, /, \, ^ ,‘</code> </p><p>和线性代数的运算规则相同</p><p>直接用x=A\B 算Ax=B 解方程</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><pre class="line-numbers language-matlab"><code class="language-matlab">a<span class="token operator">=</span><span class="token function">matrix</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token comment" spellcheck="true">% 例子</span>a<span class="token operator">=</span><span class="token function">matrix</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">% 第一到2行的3到4列</span>a<span class="token operator">=</span><span class="token function">matrix</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">% 同理 若有3个参数中间为步长两边为区间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>plot，创建 Y 中数据对 X 中对应值的二维线图。 如果 X 和 Y 都是向量，则它们的长度必须相同；<br>stem，绘制离散序列数据；<br>subplot</p><pre class="line-numbers language-matlab"><code class="language-matlab">t <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">0.1</span><span class="token punctuation">;</span>f <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">,</span>"Color"<span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span>"LineStyle"<span class="token punctuation">,</span>"<span class="token operator">-</span>"<span class="token punctuation">,</span>"LineWidth"<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> hold on<span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">,</span>"Color"<span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span>"LineStyle"<span class="token punctuation">,</span>"<span class="token operator">-</span><span class="token operator">-</span>"<span class="token punctuation">,</span>"LineWidth"<span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> hold off <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>p1    <span class="token function">stem</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>p2<span class="token function">stem</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">,</span>"filled"<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>p3<span class="token function">stem</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">,</span>"LineStyle"<span class="token punctuation">,</span>"<span class="token operator">-</span><span class="token operator">-</span>"<span class="token punctuation">,</span>"Marker"<span class="token punctuation">,</span>"<span class="token operator">*</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>p4<span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">plot</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">,</span>"Color"<span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span>"LineStyle"<span class="token punctuation">,</span>"<span class="token operator">-</span>"<span class="token punctuation">,</span>"LineWidth"<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">stem</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">,</span>"filled"<span class="token punctuation">)</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">stem</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">,</span>"LineStyle"<span class="token punctuation">,</span><span class="token string">'none'</span><span class="token punctuation">,</span>"Marker"<span class="token punctuation">,</span>"<span class="token operator">*</span>"<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>p5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/10/19/SP学习笔记——Matlab使用篇/1.png" alt=""></p><p>​                                                                                   p1</p><p><img src="/2020/10/19/SP学习笔记——Matlab使用篇/2.png" alt=""></p><p>​                                                                                    p2</p><p><img src="/2020/10/19/SP学习笔记——Matlab使用篇/3.png" alt=""></p><p>​                           </p><p>​                                                                                   p3</p><p>​                          <img src="/2020/10/19/SP学习笔记——Matlab使用篇/4.png" alt=""> </p><p>​                                                                                   p4</p><p><img src="/2020/10/19/SP学习笔记——Matlab使用篇/5.png" alt=""></p><p>​                                                                                   p5</p><h1 id="进阶学习"><a href="#进阶学习" class="headerlink" title="进阶学习"></a>进阶学习</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开始学习信号处理x&lt;/p&gt;
&lt;p&gt;涉及到matlab的各种使用开坑记录学习&lt;/p&gt;
&lt;p&gt;依旧采用python学习笔记的格式写法&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="SIGNAL_PROCESSING" scheme="http://yoursite.com/categories/CS/SIGNAL-PROCESSING/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="信号处理" scheme="http://yoursite.com/tags/信号处理/"/>
    
  </entry>
  
  <entry>
    <title>信号与系统学习笔记</title>
    <link href="http://yoursite.com/2020/10/08/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>http://yoursite.com/2020/10/08/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E7%AF%87/</id>
    <published>2020-10-09T02:19:51.814Z</published>
    <updated>2021-11-11T07:13:46.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="傅里叶变换Fourier-Transform"><a href="#傅里叶变换Fourier-Transform" class="headerlink" title="傅里叶变换Fourier Transform"></a>傅里叶变换Fourier Transform</h1><h2 id="引述"><a href="#引述" class="headerlink" title="引述"></a>引述</h2><p>傅里叶变换主要应用于将信号经过处理后变成不同频率的组成</p><p>大概就会将合成的频率组合拆分成单个信号</p><p>有点类似于棱镜对于光，白光透过棱镜会分成不同的彩光。</p><p>将傅里叶变换看做棱镜，信号看做光来理解就差不多</p><p><img src="/2020/10/08/SP学习笔记——理论篇/1.png" alt=""></p><h2 id="Types-of-Fourier"><a href="#Types-of-Fourier" class="headerlink" title="Types of Fourier"></a>Types of Fourier</h2><ul><li><p>Fourier series 傅里叶级数</p></li><li><p>Fourier transform 傅里叶变换</p></li><li><p>Continuous Fourier transform 持续傅里叶变换</p></li><li><p>Discrete-time Fourier transform 离散时间傅里叶变换</p></li><li><p>Discrete Fourier transform 离散傅里叶变换</p></li><li><p>Fast Fourier transform 快速傅里叶变换<del>（FFT 是法法塔！</del></p></li></ul><p>首先是傅里叶级数</p><h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><p><img src="/2020/10/08/SP学习笔记——理论篇/2.png" alt=""></p><p>傅里叶级数的公式<br>$$<br>u(t)=\frac{a_0}{2}+\sum_{n=1}^{\infty}(a_n\cos2\pi ft +b_n \sin 2\pi nft)<br>$$</p><p>$$<br>x(t) =\sum_{k=-\infty}^{\infty} a_{k}e^{jkw_{0}t}=\sum_{k=-\infty}^{\infty} a_{k}e^{jk\frac{2\pi}{T}t}<br>$$</p><p>$$<br>x[n] =\sum_{k \in \lt N \gt } a_{k}e^{jkw_{0}n}=\sum_{k \in \lt N \gt }a_{k}e^{jk\frac{2\pi}{T}n}<br>$$</p><p>$$<br>a_k =\sum_{n \in \lt N \gt} x[n]e^{-jkw_{0}n}=\sum_{x \in \lt N \gt}a_n e^{-jk\frac{2\pi}{T}n}<br>$$</p><h1 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h1><h2 id="拜尔滤镜-Bayer-Filter"><a href="#拜尔滤镜-Bayer-Filter" class="headerlink" title="拜尔滤镜(Bayer Filter)"></a>拜尔滤镜(Bayer Filter)</h2><p>主要把光分成红光</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;傅里叶变换Fourier-Transform&quot;&gt;&lt;a href=&quot;#傅里叶变换Fourier-Transform&quot; class=&quot;headerlink&quot; title=&quot;傅里叶变换Fourier Transform&quot;&gt;&lt;/a&gt;傅里叶变换Fourier Transfo</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="SIGNAL_PROCESSING" scheme="http://yoursite.com/categories/CS/SIGNAL-PROCESSING/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="信号处理" scheme="http://yoursite.com/tags/信号处理/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记</title>
    <link href="http://yoursite.com/2020/08/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-12T15:00:00.000Z</published>
    <updated>2021-04-28T11:03:51.961Z</updated>
    
    <content type="html"><![CDATA[<p>从今天起正式开始学习py！！！</p><p><del>咸鱼了这么多天了终于开始搞点东西了</del></p><p>以下为学习新语言py的学习笔记~ 大概学的是python3</p><p>MD为什么看了这么多教程基本没一个顺眼能第一次找到想写的东西）</p><p>*夹带私货注意</p><p>唯一顺眼的 -&gt;<a href="https://www.runoob.com/python3/python3-basic-syntax.html" target="_blank" rel="noopener">参考</a></p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>首先，语句末尾没有<strong>’;’</strong> <strong>划重点</strong></p><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>与c++不同，py里面是用缩进代替{}</p><p>例</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Answer"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"True"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Answer"</span><span class="token punctuation">)</span>  <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"False"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 缩进不一致，会导致运行错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>python的数字变量</p><ul><li><p><code>int</code> 整型 包括c++中的long long 舒服</p></li><li><p><code>bool</code> 布尔型 这个都熟悉0，1判断</p></li><li><code>float</code> 浮点数 包括c++中的float和double 应该没有精度限制</li><li><code>complex</code> 复数 应该是高中那个i c++里面没用过不太清楚</li></ul><p>python的字符串（以下为ctrl+c Ctrl+v)</p><ul><li>python中单引号和双引号使用完全相同。</li><li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li><li>转义符 ‘\’</li><li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li><li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python中的字符串不能改变。</li><li>Python <strong>没有单独的字符类型</strong>，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标]</strong></li></ul><p><img src="/2020/08/12/python学习笔记/o99aU.png" alt=""></p><p>例子 </p><pre class="line-numbers language-python"><code class="language-python">str<span class="token operator">=</span><span class="token string">'Runoob'</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># 输出字符串</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 输出第一个到倒数第二个的所有字符</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>              <span class="token comment" spellcheck="true"># 输出字符串第一个字符</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 输出从第三个开始到第五个的字符</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 输出从第三个开始后的所有字符</span><span class="token comment" spellcheck="true">#  str[起始：结束：步长]，范围包首不包尾</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串倒读技巧</p><p><code>str[::-1]</code></p><p>字符串常用函数</p><pre class="line-numbers language-python"><code class="language-python">str<span class="token operator">=</span><span class="token string">' Hello, world! '</span> <span class="token comment" spellcheck="true"># 以下函数均不会改变原有的字符串，需要一个新的string/list/tuple 来进行储存</span>new<span class="token operator">=</span><span class="token string">' '</span>newlist<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>new<span class="token operator">=</span>str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 'Hello, World!'</span><span class="token comment" spellcheck="true"># .lstrip()，删除左侧的空白字符 .rstrip()，删除末尾的空白字符</span>new<span class="token operator">=</span>str<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">,</span><span class="token string">'J'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 'Jello, world! ' 最后一个可以指定次数</span>newlist<span class="token operator">=</span>str<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ['Hello', ' World!'] split函数自动返回一个新的列表，以’st'为分割符号，生成新的列表</span>newlist<span class="token operator">=</span>list<span class="token punctuation">(</span>str<span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ['Hello',',',' world! ']</span><span class="token comment" spellcheck="true">#该函数自动返回tuple 需要转一下类型</span><span class="token comment" spellcheck="true">#该函数已指定字符做为一个部分，分割两边，生成三部分的字符串</span><span class="token comment" spellcheck="true"># .capitalize()，将字符串第一个首字母大写（其它都小写）</span><span class="token comment" spellcheck="true"># .title()，将字符串中所有单词首字母大写（其它都小写）</span><span class="token comment" spellcheck="true"># .lower()转换所有大写字符为小写</span><span class="token comment" spellcheck="true"># .upper()转换所有小写字符为大写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="python-关键字"><a href="#python-关键字" class="headerlink" title="python 关键字"></a>python 关键字</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token string">'False'</span><span class="token punctuation">,</span> <span class="token string">'None'</span><span class="token punctuation">,</span> <span class="token string">'True'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'as'</span><span class="token punctuation">,</span> <span class="token string">'assert'</span><span class="token punctuation">,</span> <span class="token string">'async'</span><span class="token punctuation">,</span> <span class="token string">'await'</span><span class="token punctuation">,</span> <span class="token string">'break'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">,</span> <span class="token string">'continue'</span><span class="token punctuation">,</span> <span class="token string">'def'</span><span class="token punctuation">,</span> <span class="token string">'del'</span><span class="token punctuation">,</span> <span class="token string">'elif'</span><span class="token punctuation">,</span> <span class="token string">'else'</span><span class="token punctuation">,</span> <span class="token string">'except'</span><span class="token punctuation">,</span> <span class="token string">'finally'</span><span class="token punctuation">,</span> <span class="token string">'for'</span><span class="token punctuation">,</span> <span class="token string">'from'</span><span class="token punctuation">,</span> <span class="token string">'global'</span><span class="token punctuation">,</span> <span class="token string">'if'</span><span class="token punctuation">,</span> <span class="token string">'import'</span><span class="token punctuation">,</span> <span class="token string">'in'</span><span class="token punctuation">,</span> <span class="token string">'is'</span><span class="token punctuation">,</span> <span class="token string">'lambda'</span><span class="token punctuation">,</span> <span class="token string">'nonlocal'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'pass'</span><span class="token punctuation">,</span> <span class="token string">'raise'</span><span class="token punctuation">,</span> <span class="token string">'return'</span><span class="token punctuation">,</span> <span class="token string">'try'</span><span class="token punctuation">,</span> <span class="token string">'while'</span><span class="token punctuation">,</span> <span class="token string">'with'</span><span class="token punctuation">,</span> <span class="token string">'yield'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> keyword<span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="读入"><a href="#读入" class="headerlink" title="读入"></a>读入</h2><p><code>input()</code>函数，感觉类似快读<code>read()</code> 其实只是长得像罢了</p><p>找了半天才了解到py读入默认字符串模式</p><p>要输入<code>int</code> 需要<code>a=int(input())</code></p><p><strong>py读入默认数字换行输入，不能空格 </strong></p><p>空格输入读入方法</p><p><code>x, y = map(int, input().split())</code></p><h4 id="关于文件读入方式"><a href="#关于文件读入方式" class="headerlink" title="关于文件读入方式"></a>关于文件读入方式</h4><ol><li>整个文件读入（包括换行符）</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f <span class="token punctuation">:</span>    data<span class="token operator">=</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># read() 所有一起读包括'\n'</span>         f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># readlines() 一行行读入 不读换行符 自动去掉</span>         f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># readline() 读入'\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>py输出默认换行输出</p><p><code>print()</code>注意不是<code>printf</code></p><p>若不需要换行则<code>end=&quot; &quot;</code></p><h4 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h4><pre class="line-numbers language-python"><code class="language-python">doc<span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'out.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">,</span>file<span class="token operator">=</span>doc<span class="token punctuation">)</span>doc<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'out.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 和read()相似 输出含'\n'</span><span class="token comment" spellcheck="true"># 其他运用的例子</span>f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'test1.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#    此时test1.txt的内容为:123</span>f<span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'test1.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1\n"</span><span class="token punctuation">,</span> <span class="token string">"2\n"</span><span class="token punctuation">,</span> <span class="token string">"3\n"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#    此时test1.txt的内容为:</span><span class="token comment" spellcheck="true">#    1</span><span class="token comment" spellcheck="true">#    2        </span><span class="token comment" spellcheck="true">#    3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>py所有常量赋值不论什么类型都直接= 可以自己识别</p><p>例 </p><pre class="line-numbers language-python"><code class="language-python">counter <span class="token operator">=</span> <span class="token number">2020</span>          <span class="token comment" spellcheck="true"># 整型变量</span>miles   <span class="token operator">=</span> <span class="token number">2020.0803</span>       <span class="token comment" spellcheck="true"># 浮点型变量</span>name    <span class="token operator">=</span> <span class="token string">"AokiUmi"</span>     <span class="token comment" spellcheck="true"># 字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>c++</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">2020</span>          # 整型变量<span class="token keyword">double</span> miles<span class="token operator">=</span> <span class="token number">2020.0803</span>       # 浮点型变量<span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"AokiUmi"</span>     # 字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>允许多变量赋值 </p><p>例<code>a=b=c=2020</code> 或<code>a,b,c=2020.0803,&#39;AokiUmi&#39;,2020</code></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>三种语法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 单行</span><span class="token triple-quoted-string string">'''多行'''</span><span class="token triple-quoted-string string">"""多行2"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>number 和 string介绍过了</p><p>特别的是</p><ul><li>List（列表）可变</li><li>Tuple（元组）不可变</li><li>Set（集合）可变</li><li>Dictionary（字典）可变</li><li>Number（数字）不可变 这就意味着如果改变数字数据类型的值，将重新分配内存空间。<code>id()</code>用于查询储存地址，若改变数值id会变 其实还是可以变</li><li>String（字符串）不可变</li></ul><p>这里的可变不可变指一次赋值完成后就不能再改</p><h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h3><p>这个玩意好像很牛逼啊</p><p>可以数字，字符串混用6666</p><p>日常偷图 梅开二度</p><p><img src="/2020/08/12/python学习笔记/o99aU.png" alt=""></p><p><img src="/2020/08/12/python学习笔记/list_slicing1.png" alt=""><strong>变量[头下标:尾下标]</strong></p><p>这里注意单点更改/输出 看上面两行</p><p>区间更改/输出 看下面两行</p><p>和字符串一样+连接   * 复读</p><p>例如</p><pre class="line-numbers language-python"><code class="language-python">list<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">'error'</span><span class="token punctuation">,</span><span class="token number">2333.333</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#      0   1    2      3</span><span class="token comment" spellcheck="true">#    :   1    2     3       : </span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># a</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ['a',20] : -> 2 指区间list[0] -> list[1]</span>list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'AOKI'</span><span class="token punctuation">,</span><span class="token string">'UMI'</span><span class="token punctuation">,</span><span class="token string">'0315'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 玄学操作出现了 py经竟能凭空插入列表,长度乱改 牛逼！</span><span class="token comment" spellcheck="true">#    ['a', 'AOKI', 'UMI', '0315', 'error', 2333.333] 此时列表凭空变长</span><span class="token comment" spellcheck="true">#   :     1       2      3       4       5         :</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># ['a', 'AOKI', 'UMI', '0315', 'error', 2333.333]</span>list<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'AOKI'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># ['UMI', '0315', 'AOKI', 2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>乱搞到这里py牛逼！</p><p>这就是py吗 i了i了  这比c++牛逼到哪里去了（bushi</p><p><strong>List中的元素是可以改变的</strong>  这是重点 ，真滴好用。所以字符串，数字为啥改不了？挺迷惑的</p><p>list和string截取还有一种写法 ，引入了步长（长度参数）</p><pre class="line-numbers language-python"><code class="language-python">lovelive <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#            0   1   2   3   4   5   6   7</span><span class="token comment" spellcheck="true">#                ---------</span><span class="token keyword">print</span><span class="token punctuation">(</span>lovelive<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ['o','e']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此写法不是截取一整段区间，而是打印出头尾字符</p><p><strong>ps：该长度不包含最尾</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>lovelive<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>lovelive<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出都是['o']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>del删除函数，能删除列表中的东西</p><p>既能单点也能区间</p><p><code>len(a)</code> 求长度函数</p><pre class="line-numbers language-python"><code class="language-python">list<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 增加元素</span><span class="token comment" spellcheck="true"># 常用遍历方法</span><span class="token keyword">for</span> x <span class="token keyword">in</span> list<span class="token punctuation">:</span>   <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有很多函数就不列举了<a href="https://www.runoob.com/python3/python3-list.html" target="_blank" rel="noopener">参考</a></p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">list.append(x)</td><td style="text-align:left">把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。</td></tr><tr><td style="text-align:left">list.extend(L)</td><td style="text-align:left">通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。</td></tr><tr><td style="text-align:left">list.insert(i, x)</td><td style="text-align:left">在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td></tr><tr><td style="text-align:left">list.remove(x)</td><td style="text-align:left">删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td></tr><tr><td style="text-align:left">list.pop([i])</td><td style="text-align:left">从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）pop(1)删除第二个元素</td></tr><tr><td style="text-align:left">list.clear()</td><td style="text-align:left">移除列表中的所有项，等于del a[:]。</td></tr><tr><td style="text-align:left">list.index(x)</td><td style="text-align:left">返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td></tr><tr><td style="text-align:left">list.count(x)</td><td style="text-align:left">返回 x 在列表中出现的次数。</td></tr><tr><td style="text-align:left">list.sort()</td><td style="text-align:left">对列表中的元素进行排序。</td></tr><tr><td style="text-align:left">list.reverse()</td><td style="text-align:left">倒排列表中的元素。</td></tr><tr><td style="text-align:left">list.copy()</td><td style="text-align:left">返回列表的浅复制，等于a[:]。</td></tr></tbody></table><h3 id="元祖Tuple"><a href="#元祖Tuple" class="headerlink" title="元祖Tuple"></a>元祖Tuple</h3><p>据说这玩意和列表差不多，就是不能改？</p><p>定义方法 list用 []框起来，而元祖用()</p><p> 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><p>例</p><pre class="line-numbers language-python"><code class="language-python">tup<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'love'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'aoki'</span><span class="token punctuation">,</span><span class="token number">315</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'live'</span><span class="token punctuation">,</span><span class="token number">12345</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 套娃牛逼</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和list一样数字字符混用</p><p>额外语法</p><pre class="line-numbers language-python"><code class="language-python">tup<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 空</span>tup2<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 一个元素，需要在元素后添加逗号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="notice："><a href="#notice：" class="headerlink" title="notice："></a>notice：</h4><ul><li><p>与字符串一样，元组的元素不能修改。</p></li><li><p>元组也可以被索引和切片，方法一样。</p></li><li>元组也可以使用+操作符进行拼接。</li></ul><p><del>讲真这玩意不支持修改，真的有啥大用处吗？列表他不香吗？</del></p><h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><p>定义方法 list用 []框起来，而set用{} 或者用<code>set()</code>用函数创建</p><p>例 <code>a=set(&#39;1234567&#39;)</code> ps: 此写法支持者一个长字符串</p><p>首先若是用{}来定义，套娃支持set套tup,list，dic</p><p>同时<code>set()</code>自带去重，自带字符串匹配算法。<del>kmp白学啦爽啦！</del></p><p>例</p><pre class="line-numbers language-python"><code class="language-python">b<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token string">'aabbccdd'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># {'b', 'a', 'c', 'd'}</span>a<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token string">'abcdaaasdsdscvcdcc'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># {'c', 'b', 'a', 'v', 's', 'd'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说实话我没有看懂这个输出顺序以及set去重的算法原理，可能找人去问问）搞明白之后再写清楚</p><p>我在piazza上提问后我得到了明确的答复！</p><p>老师原文：</p><p><code>set</code> in Python is implemented with the hash table as you mentioned [1]. It is basically a <em>weaken</em> version of <code>dict</code> which allows single values to be stored in it instead of key-value pairs.</p><p>Both the Python language specification and the semantics of the data structure hash table do not require <code>set</code> to be operated in a predictable order (i.e., deterministic). In the implementation [2] of the initializer of <code>set</code>, function <code>set_update_internal</code> is called to update the set you are creating with the iterable supplied. In the function, the interpreter is basically doing the hashing operation and insert the objects to the set. For security reasons [3], a randomized hash function is used in the interpreter which gives the object a non-deterministic property. The interesting thing is that the security fix is originally for the <code>dict</code> type. Since most of the implementation of <code>set</code> is just some kind of copy-paste from the implementation of <code>dict</code>, the fix that is originally for <code>dict</code> is kept in <code>set</code>. For <code>dict</code>, starting from version 3.6, a new implementation is proposed and used that could preserve the insertion order of KV pairs. But for some reason, the new implementation is not yet applied to <code>set</code>.</p><p>In short, the non-deterministic property is caused by the randomized hash function used in the CPython interpreter. The language specification does not guarantee you as a user to expect a deterministic <code>set</code> implementation. But the situation may change from version to version.</p><p>翻译成人话就是用的确实是hash就是用了随机化数组输出，为了保证用户安全啥啥玩意 挺离谱的）</p><p>关于字符串匹配内置算法</p><pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token string">'aabbccdd'</span><span class="token punctuation">)</span>b <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token string">'abcdaaasdsdscvcdcc'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a和b的差集 </span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">|</span>b<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a和b的并集</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a和b的交集</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">^</span>b<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a和b中不同时存在的元素</span><span class="token comment" spellcheck="true"># set() 若是b-a则是 {'s', 'v'}</span><span class="token comment" spellcheck="true"># {'s', 'a', 'v', 'd', 'b', 'c'}</span><span class="token comment" spellcheck="true"># {'c', 'a', 'b', 'd'}</span><span class="token comment" spellcheck="true"># {'s', 'v'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个运算应该是直接根据set去重之后的结果进行简单的比较打标比较就完了用不到字典树，kmp这种高级玩意）</p><p>集合同样支持删除和增加</p><p><code>s.update() s.add()</code></p><p><code>s.remove()</code>如果元素不存在，则会发生错误。</p><p><code>s.discard()</code> 如果元素不存在，不会发生错误</p><p><code>s.pop()</code> 随机删元素？md绝了，你当我抽卡呢？</p><p>更多函数请见 <a href="https://www.runoob.com/python3/python3-set.html" target="_blank" rel="noopener">教程</a></p><p><strong>set不支持遍历，下标读取等操作，需要谨慎使用</strong></p><h3 id="字典dictionary"><a href="#字典dictionary" class="headerlink" title="字典dictionary"></a>字典dictionary</h3><p>dictionary与list区别看一看做list就是可以装各种东西的数组，下表都是固定的从0-？话说这些类似数组的东西储存空间有多大啊）突然迷惑</p><p>dictionary给我的感觉就是更加智能的数组，下标自定义，装的东西也非常丰富，好牛。</p><pre class="line-numbers language-python"><code class="language-python">dic<span class="token punctuation">[</span><span class="token string">'aoki'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">315</span>dic<span class="token punctuation">[</span><span class="token string">'园田海未'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'wife'</span> <span class="token comment" spellcheck="true"># 单点命名</span>dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'aoki'</span><span class="token punctuation">:</span> <span class="token number">315</span><span class="token punctuation">,</span><span class="token string">'园田海未'</span><span class="token punctuation">:</span> <span class="token string">'wife'</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># 多点命名</span>dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'aoki'</span><span class="token punctuation">,</span><span class="token number">315</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'园田海未'</span><span class="token punctuation">,</span><span class="token string">'wife'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 此函数 直接输出用好像 </span>dict<span class="token punctuation">(</span>aoki<span class="token operator">=</span><span class="token number">315</span><span class="token punctuation">,</span>umi<span class="token operator">=</span>wife<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 此函数 直接输出用好像 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内置函数介绍</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出键 下标</span><span class="token keyword">print</span><span class="token punctuation">(</span>dic<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出内容</span>dic<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 清楚 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>感觉这几个很像c++的string ，指函数写法</p><p>用字典来打标</p><pre class="line-numbers language-python"><code class="language-python">dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    dic<span class="token punctuation">[</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># dic套list写法 初始化先把list都赋值</span>    dic<span class="token punctuation">[</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span> <span class="token comment" spellcheck="true"># 普通的初始化</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    dic<span class="token punctuation">[</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+=</span>x    dic<span class="token punctuation">[</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span> <span class="token comment" spellcheck="true">#这样就能打标了</span><span class="token comment" spellcheck="true"># ps list,tuple不能用来打标） list不好搞 tuple不能改变</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="notice：-1"><a href="#notice：-1" class="headerlink" title="notice："></a>notice：</h4><ul><li>字典的关键字必须为不可变类型，且不能重复。好理解下标嘛</li><li>创建空字典使用 <strong>{ }</strong>。</li></ul><h4 id="list与dic添加操作区分"><a href="#list与dic添加操作区分" class="headerlink" title="list与dic添加操作区分"></a>list与dic添加操作区分</h4><pre class="line-numbers language-python"><code class="language-python">list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># append一个值是可以重复添加的</span>dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span>x dic<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>ch <span class="token punctuation">:</span>x<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># dic中的key不可改变 若多次update相同的key 就会覆盖掉前面的</span><span class="token comment" spellcheck="true"># 所以dic能用来打标 list不行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于这几个类似数组的东西的储存空间</p><p>好像都是电脑默认最大储存值，和c++ (1&lt;&lt;30)那个不太一样吧，可能py没有爆空间的忧虑，很方便</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>常规与c++ 一致 不同的有</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>** 乘方（自带ksm？）</p><p>//  取整除</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p> **= 乘方赋值</p><p> //= 取整除赋值</p><p>:=  海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</p><p>例子 <code>if (n := len(a)) &gt; 10:</code></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>新增 <code>is</code>&amp;<code>is not</code> 能比较数值和类型</p><p><code>==</code> 只比较数值 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1.0</span> <span class="token boolean">True</span> <span class="token number">1</span> <span class="token keyword">is</span> <span class="token number">1.0</span> <span class="token boolean">False</span> <span class="token number">1</span> <span class="token operator">!=</span><span class="token number">1.0</span> <span class="token boolean">False</span>  <span class="token number">1</span> <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token number">1.0</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li><p>&amp; binary AND – For a digit, if any number is 0, result is 0 </p></li><li><p>| binary OR – For a digit, if any number is 1, result is </p></li></ul><p>和c++一样呢懒得翻译了（bushi</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>在python里面，0、’’、[]、()、{}、None为假，其它任何东西都为真</strong></p><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">逻辑表达式</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">and</td><td style="text-align:left">x and y</td><td style="text-align:left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td style="text-align:left">(a and b) 返回 20。</td></tr><tr><td style="text-align:left">or</td><td style="text-align:left">x or y</td><td style="text-align:left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td style="text-align:left">(a or b) 返回 10。</td></tr><tr><td style="text-align:left">not</td><td style="text-align:left">not x</td><td style="text-align:left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td style="text-align:left">not(a and b) 返回 False</td></tr></tbody></table><p>优先级or&gt;and&gt;not</p><p>not优先级低于非布尔运算符</p><h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>in 判断该成员是否在制定序列中 </p><p>not in同理</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">指数 (最高优先级)</td></tr><tr><td style="text-align:left">~ + -</td><td style="text-align:left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td style="text-align:left">* / % //</td><td style="text-align:left">乘，除，求余数和取整除</td></tr><tr><td style="text-align:left">+ -</td><td style="text-align:left">加法减法</td></tr><tr><td style="text-align:left">&gt;&gt; &lt;&lt;</td><td style="text-align:left">右移，左移运算符</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">位 ‘AND’</td></tr><tr><td style="text-align:left">^ \</td><td style="text-align:left"></td><td>位运算符</td></tr><tr><td style="text-align:left">&lt;= &lt; &gt; &gt;=</td><td style="text-align:left">比较运算符</td></tr><tr><td style="text-align:left">== !=</td><td style="text-align:left">等于运算符</td></tr><tr><td style="text-align:left">= %= /= //= -= += *= **=</td><td style="text-align:left">赋值运算符</td></tr><tr><td style="text-align:left">is is not</td><td style="text-align:left">身份运算符</td></tr><tr><td style="text-align:left">in not in</td><td style="text-align:left">成员运算符</td></tr><tr><td style="text-align:left">not and or</td><td style="text-align:left">逻辑运算符</td></tr></tbody></table><h2 id="整型相关函数"><a href="#整型相关函数" class="headerlink" title="整型相关函数"></a>整型相关函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">int(x)</td><td style="text-align:left">将x转换为一个整数</td></tr><tr><td style="text-align:left">float(x)</td><td style="text-align:left">将x转换到一个浮点数</td></tr><tr><td style="text-align:left">complex(x)</td><td style="text-align:left">创建一个复数</td></tr><tr><td style="text-align:left">complex(x, y)</td><td style="text-align:left">将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</td></tr><tr><td style="text-align:left">str(x)</td><td style="text-align:left">将对象 x 转换为字符串</td></tr><tr><td style="text-align:left">repr(x)</td><td style="text-align:left">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:left">eval(s)</td><td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:left">tuple(s)</td><td style="text-align:left">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:left">list(s)</td><td style="text-align:left">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:left">set(s)</td><td style="text-align:left">转换为可变集合</td></tr><tr><td style="text-align:left">dict(d)</td><td style="text-align:left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td style="text-align:left">frozenset(s)</td><td style="text-align:left">转换为不可变集合</td></tr><tr><td style="text-align:left">chr(x)</td><td style="text-align:left">将一个整数转换为一个字符</td></tr><tr><td style="text-align:left">ord(x)</td><td style="text-align:left">将一个字符转换为它的整数值</td></tr><tr><td style="text-align:left">hex(x)</td><td style="text-align:left">将一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:left">oct(x)</td><td style="text-align:left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">返回值 ( 描述 )</th></tr></thead><tbody><tr><td style="text-align:left">abs(x)</td><td style="text-align:left">返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td style="text-align:left">ceil(x)</td><td style="text-align:left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td style="text-align:left">cmp(x, y)</td><td style="text-align:left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td style="text-align:left">exp(x)</td><td style="text-align:left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td style="text-align:left">fabs(x)</td><td style="text-align:left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td style="text-align:left">floor(x)</td><td style="text-align:left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td style="text-align:left">log(x)</td><td style="text-align:left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td style="text-align:left">log10(x)</td><td style="text-align:left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td style="text-align:left">max(x1, x2,…)</td><td style="text-align:left">返回给定参数的最大值，参数可以为序列。</td></tr><tr><td style="text-align:left">min(x1, x2,…)</td><td style="text-align:left">返回给定参数的最小值，参数可以为序列。</td></tr><tr><td style="text-align:left">modf(x)</td><td style="text-align:left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td style="text-align:left">pow(x, y)</td><td style="text-align:left">x**y 运算后的值。</td></tr><tr><td style="text-align:left">round(x [,n])</td><td style="text-align:left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td style="text-align:left">sqrt(x)</td><td style="text-align:left">返回数字x的平方根。</td></tr></tbody></table><p>其他见<a href="https://www.runoob.com/python3/python3-number.html" target="_blank" rel="noopener">不常用函数</a></p><h1 id="进阶编写"><a href="#进阶编写" class="headerlink" title="进阶编写"></a>进阶编写</h1><p><strong>所有东西后面：很重要千万别忘了</strong></p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ul><li>for循环</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># = for(int i=1;i&lt;10;i+=3) </span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># for(int i=0;i&lt;10;i++)</span>a<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Aoki'</span><span class="token punctuation">,</span><span class="token string">'Umi'</span><span class="token punctuation">,</span><span class="token string">'0315'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 遍历list 很慢千万别用）</span><span class="token keyword">for</span> i <span class="token keyword">in</span> a <span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 这个好</span><span class="token comment" spellcheck="true"># : 别忘了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>while循环</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> a<span class="token operator">&lt;=</span><span class="token number">10</span> <span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># operation</span><span class="token keyword">else</span> <span class="token punctuation">:</span>     <span class="token keyword">break</span>    <span class="token keyword">continue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> a <span class="token operator">>=</span><span class="token number">2</span> <span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># operation</span><span class="token keyword">elif</span> a<span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># operation</span><span class="token keyword">else</span> <span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># operation</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数自定义"><a href="#函数自定义" class="headerlink" title="函数自定义"></a>函数自定义</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">aoki</span><span class="token punctuation">(</span>umi<span class="token punctuation">,</span> wife<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 变量</span>    <span class="token comment" spellcheck="true"># operation</span>    <span class="token keyword">return</span><span class="token keyword">def</span> <span class="token function">aoki</span><span class="token punctuation">(</span>umi <span class="token punctuation">:</span>str <span class="token punctuation">,</span>wife <span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 定义变量类型</span><span class="token keyword">def</span> <span class="token function">aoki</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#放入list or tuple</span><span class="token keyword">def</span> <span class="token function">aoki</span><span class="token punctuation">(</span><span class="token operator">**</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 放入字典形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h2 id="assert断言"><a href="#assert断言" class="headerlink" title="assert断言"></a>assert断言</h2><p>断言顾名思义</p><p>就是如果你的判断语句返回是否，程序终止进行并输出你想要的语句 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">Div</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">assert</span> y<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"denominator is 0"</span>    <span class="token keyword">return</span> x<span class="token operator">/</span>y<span class="token keyword">print</span><span class="token punctuation">(</span>Div<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Traceback (most recent call last):</span><span class="token comment" spellcheck="true">#   File "d:\personal\homework\try\try.py", line 4, in &lt;module></span><span class="token comment" spellcheck="true">#     print(Div(1,0))</span><span class="token comment" spellcheck="true">#   File "d:\personal\homework\try\try.py", line 2, in Div     </span><span class="token comment" spellcheck="true">#     assert y!=0,"denominator is 0"</span><span class="token comment" spellcheck="true"># AssertionError: denominator is 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><code>lambda</code>匿名函数，目前觉得在排序中用的很多 可以处理多key排序</p><p>主要是list，dic里面排序用的</p><p>首先list自带排序</p><pre class="line-numbers language-python"><code class="language-python">ans<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> s<span class="token punctuation">:</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">,</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>revese<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 先按s[1],再s[0] revese表示升序还是降序，默认升序</span>ans<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> s<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">-</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">,</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># s[1]降 s[0]升</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><p>py中的结构体 称class 定义比c++麻烦很多，但仍然需要掌握</p><p><strong>类的属性：封装性，继承性，多态性</strong></p><p>判断一个对象是不是一个class <code>isinstance(x,demo)</code> <code>isinstance(demo,type)</code></p><h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">aoki</span><span class="token punctuation">:</span>     value<span class="token operator">=</span><span class="token string">"aoki_umi"</span> <span class="token comment" spellcheck="true">#类变量 </span>    <span class="token keyword">def</span> __init__ <span class="token punctuation">(</span>self <span class="token punctuation">,</span>name <span class="token punctuation">,</span>age <span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name<span class="token operator">=</span>name            self<span class="token punctuation">.</span>age<span class="token operator">=</span>age <span class="token comment" spellcheck="true"># 初始化自定义结构体的数值</span>    <span class="token keyword">def</span> __init__ <span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name<span class="token operator">=</span>None        self<span class="token punctuation">.</span>age<span class="token operator">=</span>None <span class="token comment" spellcheck="true"># 与前者的区别是后者数据可以为空</span>    <span class="token keyword">def</span> __init__ <span class="token punctuation">(</span>self<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 推荐写法</span>        self<span class="token punctuation">.</span>name<span class="token operator">=</span>v         self<span class="token punctuation">.</span>value<span class="token operator">=</span><span class="token string">'AOKI_UMI'</span>     <span class="token keyword">def</span> <span class="token function">pri</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 类中自定义函数 这个self好像必须写上去</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>name<span class="token keyword">def</span> <span class="token function">opr</span><span class="token punctuation">(</span>x <span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#在外面定义函数使用class aoki</span>    x<span class="token punctuation">.</span>name<span class="token operator">=</span>v <span class="token comment" spellcheck="true">#class的自定义属性可以动态改变</span><span class="token comment" spellcheck="true">#以第三种写法为例</span>AOKI<span class="token operator">=</span>aoki<span class="token punctuation">(</span><span class="token string">'umi'</span><span class="token punctuation">)</span>AOKI<span class="token punctuation">.</span>love<span class="token operator">=</span><span class="token string">'love'</span><span class="token keyword">print</span><span class="token punctuation">(</span>AOKI<span class="token punctuation">.</span>love<span class="token punctuation">,</span>AOKI<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#不会报错</span><span class="token keyword">del</span> AOKI<span class="token punctuation">.</span>name<span class="token keyword">print</span><span class="token punctuation">(</span>AOKI<span class="token punctuation">.</span>love<span class="token punctuation">,</span>AOKI<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#会报错</span><span class="token keyword">print</span><span class="token punctuation">(</span>aoki<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># aoki_umi</span><span class="token keyword">print</span><span class="token punctuation">(</span>AOKI<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># AOKI_UMI</span>opr<span class="token punctuation">(</span>AOKI<span class="token punctuation">,</span><span class="token string">'2323'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>python支持不同类的套娃调用，还能支持多次套娃调用</p><p>很牛逼的地方就在于它的多次调用，这里面多次调用的内置顺序就是dfs和bfs</p><p>该说明搬运<a href="https://www.cnblogs.com/chengd/articles/7287528.html" target="_blank" rel="noopener">参考</a></p><p>传统的类的调用使用dfs</p><p>新类（object）使用bfs</p><p>盗的图x</p><p><img src="/2020/08/12/python学习笔记/272315068126604.jpg" alt=""></p><h4 id="标准类"><a href="#标准类" class="headerlink" title="标准类"></a>标准类</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar_D</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'D.bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar_C</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'C.bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar_B</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'B.bar'</span> <span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar_A</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'A.bar'</span><span class="token punctuation">)</span>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 执行bar方法时</span><span class="token comment" spellcheck="true"># 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错</span><span class="token comment" spellcheck="true"># 所以，查找顺序：A --> B --> D --> C</span><span class="token comment" spellcheck="true"># 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了</span>a<span class="token punctuation">.</span>bar_B<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新类"><a href="#新类" class="headerlink" title="新类"></a>新类</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar_D</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'D.bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar_C</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'C.bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar_B</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'B.bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar_A</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'A.bar'</span><span class="token punctuation">)</span>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 执行bar方法时</span><span class="token comment" spellcheck="true"># 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错</span><span class="token comment" spellcheck="true"># 所以，查找顺序：A --> B --> C --> D</span><span class="token comment" spellcheck="true"># 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了</span>a<span class="token punctuation">.</span>bar_C<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p><strong>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</strong></p><p>就是说不同的类里面可以用相同的自带函数名</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#多态：同一种事物的多种形态，动物分为人类，猪类（在定义角度）</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> AttributeError<span class="token punctuation">(</span><span class="token string">'子类必须实现这个方法'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'人正在走'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Pig</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'pig is walking'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'dog is running'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>ANIMAL<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#参数animal就是对态性的体现</span>   ANIMAL<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>people1<span class="token operator">=</span>People<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#产生一个人的对象</span>pig1<span class="token operator">=</span>Pig<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#产生一个猪的对象</span>dog1<span class="token operator">=</span>Dog<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#产生一个狗的对象</span>func<span class="token punctuation">(</span>people1<span class="token punctuation">)</span>func<span class="token punctuation">(</span>pig1<span class="token punctuation">)</span>func<span class="token punctuation">(</span>dog1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>以下为可以重载的函数（运算符）</p><h4 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h4><p><code>__init__</code><br><code>__del__</code></p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p><code>__call__</code></p><h4 id="打印操作"><a href="#打印操作" class="headerlink" title="打印操作"></a>打印操作</h4><p><code>__str__</code><br><code>__repr__</code><br>str(x), print(X)：会先尝试<code>__str__</code>方法，然后尝试<code>__repr__</code>方法；repr(X)或交互模式下输入X，只会尝试<code>__repr__</code>方法。</p><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><p><code>__getattr__</code>：只有类中没有定义的属性点号运算才会尝试该方法<br><code>__setattr__</code>：类中所有属性的赋值语句都会尝试该方法，<code>self.attr=val</code>会变<code>self.setattr(&#39;attr&#39;,val)</code></p><p><code>__delattr__</code><br><code>__getattribute__</code>：类中所有属性的点号运算都会尝试该方法</p><h4 id="索引与分片"><a href="#索引与分片" class="headerlink" title="索引与分片"></a>索引与分片</h4><p><code>__getitem__</code><br><code>__setitem__</code><br><code>__delitem__</code></p><h4 id="迭代环境"><a href="#迭代环境" class="headerlink" title="迭代环境"></a>迭代环境</h4><p><code>__iter__</code><br><code>__next__</code><br>在所有的迭代环境中，会先尝试<code>__iter__</code>方法，然后在尝试<code>__getitem__</code>方法，但是注意迭代器根本没有重载索引表达式，所以如果需要通过while来根据下标手工迭代，那么需要定义<code>__getitem__</code>方法。</p><h4 id="成员测试"><a href="#成员测试" class="headerlink" title="成员测试"></a>成员测试</h4><p><code>__contains__</code><br>in成员测试会先尝试<strong>contains</strong>方法，然后是<code>__iter__</code>方法，最后是<code>__getitem__</code>方法。</p><h4 id="描述符属性"><a href="#描述符属性" class="headerlink" title="描述符属性"></a>描述符属性</h4><p><code>__get__</code><br><code>__set__</code><br><code>__delete__</code><br>主要这里是<code>__delete__</code>，也析构函数<code>__del__</code>是完全不同的。</p><h4 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h4><p><code>__lt__</code><br><code>__le__</code><br><code>__gt__</code><br><code>__ge__</code><br><code>__eq__</code>： !=和==都会尝试该方法，所以需要确保两个运算符都正确地作用。<br>请看下面的实例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> value    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>  self<span class="token punctuation">.</span>data <span class="token operator">==</span> valuex <span class="token operator">=</span> X<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x <span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为</p><pre><code>FalseTrue</code></pre><h4 id="数学运算操作"><a href="#数学运算操作" class="headerlink" title="数学运算操作"></a>数学运算操作</h4><p><code>__add__</code>, <code>__iadd__</code>, <code>__radd__</code><br><code>__sub__</code>, <code>__isub__</code>, <code>__rsub__</code><br><code>__mul__</code>, <code>__imul__</code>：乘法<br><code>__neg__</code>, <code>__pos__</code>：表示-obj， +obj<br><code>__abs__</code><br><code>__floordiv__</code>, <code>__ifloordiv__</code>, <code>__truediv__</code>, <code>__itruediv__</code><br><code>__mod__</code>, <code>__imod__</code>, <code>__imod__</code><br><code>__pow__</code>, <code>__ipow__</code><br>a += b会尝试增强加法<code>__iadd__</code>，然后尝试普通加法<code>__add__</code><br>x = b + obj：如果b不是类实例时，会调用右侧加法<code>__radd__</code><br>当我们把两个实例相加的时候，Python运行<code>__add__</code>，它反过来通过简化左边的运算数来触发<code>__radd__</code>。</p><h4 id="对象运算操作"><a href="#对象运算操作" class="headerlink" title="对象运算操作"></a>对象运算操作</h4><p><code>__concat__</code>：比如序列a,b的加法a+b<br><code>__iconcat__</code></p><h4 id="位运算符-1"><a href="#位运算符-1" class="headerlink" title="位运算符"></a>位运算符</h4><p><code>__and__</code>, <code>__iand__</code><br><code>__or__</code>, <code>__ior__</code>, <code>__xor__</code>, <code>__ixor__</code><br><code>__inv__</code>, <code>__invert__</code> : ~obj<br><code>__lshift__</code>, <code>__ilshift__</code>, <code>__rshift__</code>, <code>__irshift__</code><br>a &amp;=b：会先尝试<code>__iand__</code>，然后尝试<code>__add__</code></p><h4 id="布尔测试"><a href="#布尔测试" class="headerlink" title="布尔测试"></a>布尔测试</h4><p><code>__bool__</code><br><code>__len__</code><br>布尔测试会先尝试一个特定的<code>__bool__</code>方法，然后在尝试<code>__len__</code>方法。在Python2.6中使用的名称不是<code>__bool__</code>，而是<code>__nonzero__</code></p><h4 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h4><p>主要是用于with语句的上下文管理。<br><code>__enter__</code><br><code>__exit__</code></p><h4 id="用来定义类"><a href="#用来定义类" class="headerlink" title="用来定义类"></a>用来定义类</h4><p><code>__new__</code><br>这个函数会在类初始化函数<code>__init__</code>之前调用</p><h4 id="整数值"><a href="#整数值" class="headerlink" title="整数值"></a>整数值</h4><p><code>__index__</code><br>如果在<code>bin(X), hex(X), oct(X), O[X], O[X:]</code>等需要传入一个数字、索引、分片的值时传入一个对象，那么该对象的<code>__index__</code>会被调用。<br>主要是用来替代Python2.x中的<code>__oct__</code>， <code>__hex__</code></p><p><strong>举个栗子</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 第一个写法是加入了保护变量的写法</span><span class="token keyword">class</span> <span class="token class-name">Vector</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__value<span class="token operator">=</span>v        self<span class="token punctuation">.</span>__length<span class="token operator">=</span>len<span class="token punctuation">(</span>v<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>index<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__value<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>index<span class="token punctuation">,</span>item<span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__value<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">=</span>item    <span class="token keyword">def</span> <span class="token function">getDim</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__length    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span> <span class="token punctuation">:</span>        target<span class="token operator">=</span>self<span class="token punctuation">.</span>__value<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__length<span class="token punctuation">)</span> <span class="token punctuation">:</span>            target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>other<span class="token punctuation">.</span>__value<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> Vector<span class="token punctuation">(</span> target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__sub__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span> <span class="token punctuation">:</span>        target<span class="token operator">=</span>self<span class="token punctuation">.</span>__value<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__length<span class="token punctuation">)</span> <span class="token punctuation">:</span>            target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span>other<span class="token punctuation">.</span>__value<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> Vector<span class="token punctuation">(</span> target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__mul__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span> <span class="token punctuation">:</span>        target<span class="token operator">=</span>self<span class="token punctuation">.</span>__value<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__length<span class="token punctuation">)</span> <span class="token punctuation">:</span>            target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>other        <span class="token keyword">return</span> Vector<span class="token punctuation">(</span> target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__truediv__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span> <span class="token punctuation">:</span>        target<span class="token operator">=</span>self<span class="token punctuation">.</span>__value<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__length<span class="token punctuation">)</span> <span class="token punctuation">:</span>            target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/=</span>other        <span class="token keyword">return</span> Vector<span class="token punctuation">(</span> target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">getlength</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">:</span>        l<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> self<span class="token punctuation">.</span>__value <span class="token punctuation">:</span>            l<span class="token operator">+=</span>i        <span class="token keyword">return</span> l    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">:</span>        s<span class="token operator">=</span><span class="token string">''</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__length<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>            s<span class="token operator">+=</span><span class="token string">'{'</span><span class="token operator">+</span>str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'},'</span>        s<span class="token operator">+=</span><span class="token string">'{'</span><span class="token operator">+</span>str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'}'</span>        <span class="token keyword">return</span> <span class="token string">'Vector('</span><span class="token operator">+</span>s<span class="token operator">+</span><span class="token string">')'</span><span class="token comment" spellcheck="true"># 第二个不带锁定</span><span class="token keyword">class</span> <span class="token class-name">Vector</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>value<span class="token operator">=</span>v        self<span class="token punctuation">.</span>length<span class="token operator">=</span>len<span class="token punctuation">(</span>v<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span> <span class="token punctuation">:</span>        target<span class="token operator">=</span>self<span class="token punctuation">.</span>value<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">:</span>            target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>other<span class="token punctuation">.</span>value<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> Vector<span class="token punctuation">(</span> target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__sub__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span> <span class="token punctuation">:</span>        target<span class="token operator">=</span>self<span class="token punctuation">.</span>value<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">:</span>            target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span>other<span class="token punctuation">.</span>value<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> Vector<span class="token punctuation">(</span> target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__mul__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span> <span class="token punctuation">:</span>        target<span class="token operator">=</span>self<span class="token punctuation">.</span>value<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">:</span>            target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>other        <span class="token keyword">return</span> Vector<span class="token punctuation">(</span>target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__truediv__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span> <span class="token punctuation">:</span>        target<span class="token operator">=</span>self<span class="token punctuation">.</span>value<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">:</span>            target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/=</span>other        <span class="token keyword">return</span> Vector<span class="token punctuation">(</span> target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">getlength</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">:</span>        l<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> self<span class="token punctuation">.</span>value <span class="token punctuation">:</span>            l<span class="token operator">+=</span>i        <span class="token keyword">return</span> l    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">:</span>        s<span class="token operator">=</span><span class="token string">''</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>            s<span class="token operator">+=</span><span class="token string">'{'</span><span class="token operator">+</span>str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'},'</span>        s<span class="token operator">+=</span><span class="token string">'{'</span><span class="token operator">+</span>str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'}'</span>        <span class="token keyword">return</span> <span class="token string">'Vector('</span><span class="token operator">+</span>s<span class="token operator">+</span><span class="token string">')'</span>A<span class="token operator">=</span>Vector<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>B<span class="token operator">=</span>Vector<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token operator">+</span>B<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token operator">-</span>B<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>B<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>getlength<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Try使用"><a href="#Try使用" class="headerlink" title="Try使用"></a>Try使用</h2><p>try也可以看成是一种if条件语句</p><p>但try有很多错误类型可以根据以下Exception hierarchy中类型进行判断</p><h3 id="Exception-hierarchy"><a href="#Exception-hierarchy" class="headerlink" title="Exception hierarchy"></a>Exception hierarchy</h3><pre class="line-numbers language-python"><code class="language-python">Exception hierarchy （异常继承关系）<span class="token comment" spellcheck="true">###########################################################################</span>BaseException （基本异常） <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SystemExit （系统退出） <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> KeyboardInterrupt （键盘中断） <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> GeneratorExit （生成器退出） <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> Exception （异常）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> StopIteration （停止迭代）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> StopAsyncIteration （停止不同步迭代）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ArithmeticError （代数错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FloatingPointError （浮点错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> OverflowError （溢出错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ZeroDivisionError （除零错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> AssertionError （声明错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> AttributeError （属性错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BufferError （缓冲错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> EOFError （文件结束符错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ImportError （导入错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ModuleNotFoundError （模块没有找到错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> LookupError （查找错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IndexError （索引错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> KeyError （关键字错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> MemoryError （内存错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NameError （命名错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnboundLocalError （没有边界局域错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> OSError （操作系统错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BlockingIOError （锁定IO错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ChildProcessError （子进程错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionError （连接错误）      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BrokenPipeError （打破管道错误）      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionAbortedError （连接失败错误）      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionRefusedError （连接拒绝错误）      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionResetError （连接重置错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FileExistsError （文件存在错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FileNotFoundError （文件没有找到错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> InterruptedError （中断错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IsADirectoryError （是目录错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NotADirectoryError （不是目录错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> PermissionError （允许错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ProcessLookupError （进程查找错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TimeoutError （超时错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ReferenceError （参考错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RuntimeError （运行时错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NotImplementedError （不是应用错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RecursionError （递归错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SyntaxError （格式错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IndentationError （缩进错误）      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TabError （Tab错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SystemError （系统错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TypeError （格式错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ValueError （值错误）      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeError （U编码错误）      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeDecodeError （U解编码错误）      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeEncodeError （U编码错误）      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeTranslateError （U翻译错误）      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> Warning （警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> DeprecationWarning （反对警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> PendingDeprecationWarning （挂起反对警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RuntimeWarning （运行警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SyntaxWarning （格式警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UserWarning （用户警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FutureWarning （未来警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ImportWarning （导入警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeWarning （U编码警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BytesWarning （字节警告）           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ResourceWarning （资源警告）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运用实例"><a href="#运用实例" class="headerlink" title="运用实例"></a>运用实例</h4><p>try的判断好像很有趣 比如下面例子在除0时遇到错误，foo里面不会执行<code>print(&quot;try-2&quot;)</code>语句</p><p>会跳转到except里面判断错误类型是否符合若符合则进入except，但无论如何finally里面语句都会执行</p><p>用来证明该try判断已经执行过了</p><p>挺有趣的</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        x<span class="token operator">=</span>a<span class="token operator">/</span>b        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"try-2"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span>     AssertionError <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"except-A"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">finally</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"final-1"</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    foo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">except</span> ZeroDivisionError <span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"except-2"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"else-2"</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finally-2"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不实用的东西global-amp-nonlocal"><a href="#不实用的东西global-amp-nonlocal" class="headerlink" title="不实用的东西global&amp;nonlocal"></a>不实用的东西global&amp;nonlocal</h2><p>global 定义变量表示所有函数外的全局变量</p><p>nonlocal 定义上一个在函数中定义的x <strong>nonlocal不能调用global 会报错哦</strong></p><p>反正就这意思 懂得都懂应付考试用的</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">global</span> y<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x<span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x<span class="token operator">=</span><span class="token number">2</span>        <span class="token keyword">def</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal x            <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 2</span>            <span class="token keyword">global</span> y            y<span class="token operator">=</span><span class="token number">3</span>        baz<span class="token punctuation">(</span><span class="token punctuation">)</span>    bar<span class="token punctuation">(</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3</span><span class="token keyword">global</span> y<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x<span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal x            <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 1</span>        baz<span class="token punctuation">(</span><span class="token punctuation">)</span>    bar<span class="token punctuation">(</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="常用包介绍"><a href="#常用包介绍" class="headerlink" title="常用包介绍"></a>常用包介绍</h1><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>numpy好像是主要在多维数组，大数据的处理上有非常大的用处</p><p>ndarray，具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npdata<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>a<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># array([[1, 2, 3, 4],</span><span class="token comment" spellcheck="true"># [5, 6, 7, 8]])</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个5行6列的0数组</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [[2, 3, 4], [4, 5, 6]]</span>a<span class="token punctuation">.</span>ndim <span class="token comment" spellcheck="true">#dimension 2</span>a<span class="token punctuation">.</span>shape <span class="token comment" spellcheck="true"># 2x4</span>a<span class="token punctuation">.</span>dtype <span class="token comment" spellcheck="true">#int64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="究极乱搞"><a href="#究极乱搞" class="headerlink" title="究极乱搞"></a>究极乱搞</h1><p>py这种神仙东西只用来写普通代码不搞事真的是太浪费了）</p><p>乱搞的小型爬虫</p><p>爬我自己 博客文章标题）只支持一页页的爬</p><p>我爬我自己</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSouptitle <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>small_thing <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">getHTMLText</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>        r<span class="token punctuation">.</span>raise_for_status<span class="token punctuation">(</span><span class="token punctuation">)</span>        r<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span>        <span class="token keyword">return</span> r<span class="token punctuation">.</span>text    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token keyword">def</span> <span class="token function">fillUnivList</span><span class="token punctuation">(</span>soup<span class="token punctuation">)</span><span class="token punctuation">:</span>    tit <span class="token operator">=</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'h2'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> h2 <span class="token keyword">in</span> tit<span class="token punctuation">:</span>        title<span class="token punctuation">.</span>append<span class="token punctuation">(</span>h2<span class="token punctuation">.</span>string<span class="token punctuation">)</span>    cate<span class="token operator">=</span>soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'h6'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> h6 <span class="token keyword">in</span> cate<span class="token punctuation">:</span>         small_thing<span class="token punctuation">.</span>append<span class="token punctuation">(</span>h6<span class="token punctuation">.</span>string<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">printUnivList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    doc <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'out.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token operator">=</span>title<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>file<span class="token operator">=</span>doc<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>small_thing<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>small_thing<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>file<span class="token operator">=</span>doc<span class="token punctuation">)</span>    doc<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_title</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    html <span class="token operator">=</span> getHTMLText<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">"html.parser"</span><span class="token punctuation">)</span>    fillUnivList<span class="token punctuation">(</span>soup<span class="token punctuation">)</span>    printUnivList<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    get_title<span class="token punctuation">(</span><span class="token string">'https://aokiumi.github.io'</span><span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从今天起正式开始学习py！！！&lt;/p&gt;
&lt;p&gt;&lt;del&gt;咸鱼了这么多天了终于开始搞点东西了&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;以下为学习新语言py的学习笔记~ 大概学的是python3&lt;/p&gt;
&lt;p&gt;MD为什么看了这么多教程基本没一个顺眼能第一次找到想写的东西）&lt;/p&gt;
&lt;p&gt;*夹</summary>
      
    
    
    
    <category term="CS" scheme="http://yoursite.com/categories/CS/"/>
    
    <category term="PYTHON" scheme="http://yoursite.com/categories/CS/PYTHON/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>再见了，我的高中；你好，我的十八岁</title>
    <link href="http://yoursite.com/2020/08/03/%E5%86%8D%E8%A7%81%E4%BA%86%EF%BC%8C%E6%88%91%E7%9A%84%E9%AB%98%E4%B8%AD%EF%BC%9B%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%88%91%E7%9A%84%E5%8D%81%E5%85%AB%E5%B2%81/"/>
    <id>http://yoursite.com/2020/08/03/%E5%86%8D%E8%A7%81%E4%BA%86%EF%BC%8C%E6%88%91%E7%9A%84%E9%AB%98%E4%B8%AD%EF%BC%9B%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%88%91%E7%9A%84%E5%8D%81%E5%85%AB%E5%B2%81/</id>
    <published>2020-08-03T05:00:00.000Z</published>
    <updated>2023-09-18T21:37:58.001Z</updated>
    
    <content type="html"><![CDATA[<p>Ⅰ Ⅱ Ⅲ Ⅳ Ⅴ</p><p>高中三年转瞬即逝，一转眼之间，就来到了2020这个特殊的一年。</p><p>感觉高中三年过得非常的充实，但却又总觉得缺了点什么。</p><p>可能一心就在学校学习，没有同好，没有初中那种快乐（）</p><p>但高中确实也应该以学习为主，所以其实也有很多收获。</p><p>在高中我遇到了OI，遇到了许多有趣的老师同学，学到了很多知识，体验了不一样的高中生活。</p><p>但我觉得自己仿佛还是初中的那个我，没有很大的改变，甚至可以说小学毕业的我。</p><p>我的想法一直没有怎么改变过，确实很奇怪。</p><p>在这个炎炎夏日，我走出高考考场的那一刻，心情十分平和，几乎没有什么波动。</p><p>直到现在回想起来，高考仿佛也就是一个平常而普通的考试罢了。唯一高兴地是我终于有暑假了！</p><p>借此篇博文，不仅想给自己的高中三年做个了结，也是对自己18岁的展望。</p><p><img src="https://i.loli.net/2020/07/29/Mf5lmkD2CNIcOdn.jpg" alt="0016.jpg"></p><h1 id="Ⅰ-邂逅-Encounter"><a href="#Ⅰ-邂逅-Encounter" class="headerlink" title="Ⅰ 邂逅 Encounter"></a>Ⅰ 邂逅 Encounter</h1><p>刚踏入武钢三中的校园时，其实我也没有特别抱有期待？毕竟和最好的朋友分开了，对高中生活没有什么期望。对我这种严重社恐来说，交到什么特别深交的朋友可能性小之又小（）</p><p>再者武钢三中这么个破学校，也没什么值得期待的（迫真）</p><p>但我有幸遇到了OI，遇到了我真正非常喜欢的东西。</p><p>这也是我去其他学校可能不会拥有的契机，所以我也从不后悔自己的选择，这一点我很早也表达过。虽然没有那么完美的高中生活，但我也从未后悔与沮丧。</p><p>遇到OI，不仅为我以后的专业选择奠定了基础，也让我重新认识了自我。</p><p>再者，我遇到了一批不同的初中老师的一群可爱而有趣的高中老师。至今我见到phw也不会十分尴尬，就像朋友一样，感觉没有很大隔阂，和初中老师疏远的感觉完全不同。</p><p>我也挺喜欢我的主科老师。</p><p>qd虽然嘴臭但其实我很佩服他，毕竟他是这么多年我第一个觉得语文课能听进去的老师，而且事实说明他也有点东西x</p><p>lkc老要努力了 作为啥都不管的憨憨班主任也没啥说的（）数学教的也中规中矩的，口音挺搞笑的。</p><p>hzx最帅老师没得说的，看着爽就完了（什 物理教的怎么说，水平在那里，但讲课划水就另一码事了x</p><p>phw最牛的不解释</p><p>说到换了三个的英语老师，想念xzm .jpg zl做事老认真了，可水平不太行啊x cxm中规中矩吧x 还是xzm牛逼，真的牛逼。。</p><p>高中同学也。。。。挺假的。。。假，就硬假。。各个牛逼的一批，天天假别人（害）当代OIer现状。</p><p>感觉其实也都挺有趣的，二次猿浓度颇高（bushi 挺难得了 老二刺猿不禁流下泪水。</p><p><del>草越写越不正经了啊喂x</del></p><p>虽然没有深交的朋友，没有同好，但总归和他们一起很开心，学习挺快乐的。虽然总是孤单一人，也不觉得非常寂寞，习惯了就好（害）老社恐了。</p><p>虽然很多同学至今可能没说过话，没说过几句话，但也。。（害）是我社交圈小，没办法。希望几年之后同学聚会大家不会忘记我x</p><p>总之，</p><blockquote><p>有幸能邂逅你，OI</p></blockquote><blockquote><p>有幸能遇到这么多有趣的灵魂</p></blockquote><p><img src="https://i.loli.net/2020/07/29/jytuA3Zs8hC5f4E.jpg" alt="1.jpg"></p><h1 id="Ⅱ-历练-Challenge"><a href="#Ⅱ-历练-Challenge" class="headerlink" title="Ⅱ 历练 Challenge"></a>Ⅱ 历练 Challenge</h1><p>高中三年，就从初三暑假开始，就基本没有暑假了（</p><p>一直都在忙碌，基本从上高中来就没有暑假。初三高一暑假在机房，高一寒假在机房，高二暑假在学校补课，寒假在外面培训，所以基本就没有假期。。。</p><p>虽然其实在家里比较水，但我也觉这种比较高强度的学习也是一种历练和经历吧。牺牲假期时间不停地沉迷于学习其实也挺充实的。</p><p>在高中以及初中我的感觉就是如果没有在一天中做什么题，我就会觉得难受，有种做贼心虚的感觉（）然后就经常写也没写几道题，玩的也不尽兴，很奇怪。明明不愿意写题，但在玩的时候又有一种奇怪的罪恶感，挺离谱的。</p><p>估计这是初高中生的通病？有要好好学习的自知，却又不愿意一直学习放弃玩耍，还是会想玩。。</p><p>要说高中三年就是在题海中徜徉，天天泡在题目里，除了做题就是做题。高三更是如此，基本就没有其他的娱乐活动，每天就是一本书不断往后写，卷子不断的发。</p><p>讲实话，那么多卷子就没写多少，也不知道搞那么多资料干嘛x这本写几张，那本写几张的。</p><p>但其实说高三有多累，有多么的不同，我也没有觉得有什么特殊的。不就是考试多了点，压力稍微大了点。要说作业还没初三作业多呢）高中老师比较佛，考试很多时候都自己改，和初中完全不一样x</p><p>最大的差别就感觉高中相对初中是自主学习，老师管的比初中少很多，后期基本高三作业都是自己改或者没交也没有人说，主要靠自觉。不做没人说，自己对自己负责。</p><p>作业有时候也不会很多，额外刷题也看自己意愿。夜自习基本也看自觉，想偷偷玩手机是可以的，想认真学习也靠自己。</p><p>特别是临近高考那一个月，可以看到很多人都几乎处于崩溃状态，什么题都不想做，在学校也总想玩手机去休息，十分的疲惫痛苦。特别是今年考生，疫情对状态的影响极其巨大。</p><p>就我自己来说，网课时期心情极其的差，疫情加上肖战事件的影响，我一度无法集中精力学习，非常的烦躁不堪，就感觉大部分时间都花在了刷微博上，每天看这些鬼消息都想骂人。</p><p>以至于成绩也下滑非常厉害，网课真的害人。。本来上网课学习质量就极其差，再加上各种因素影响，网考易于作弊，成绩缺乏可信性，搞得人一度十分低迷。所以说真的，疫情害人不浅。肖战是真的恶心吐了。</p><p>最后返校后成绩明显就回升了，网课真的离谱。。并且因为网课耽误，高考都被迫延期一个月，可想而知如果不延期，我又会考成什么鬼样子。</p><blockquote><p>这也许也是一种另类的考验，在这种乌烟瘴气的网络环境和低迷的心情里谁能坚持下来，不被外界影响，谁就能成为最后的赢家。</p></blockquote><p>显然，我就没有经受住考验，只能说227事件影响真的太大了，以至于我后面直接把微博卸了。</p><blockquote><p>远离微博，迎接美好的一天。</p></blockquote><p>也许也正是因为这特殊的历练，2020届毕业生也一定能在未来大放光彩，迎来光辉的人生。</p><h1 id="Ⅲ-认知-Cognition"><a href="#Ⅲ-认知-Cognition" class="headerlink" title="Ⅲ 认知 Cognition"></a>Ⅲ 认知 Cognition</h1><p>经历了高中三年的洗礼，我也对自己有了更清楚的认知。特别是通过OI的学习，我也对自己有了更深入的了解。</p><p>首先我个人理性&gt;感性，我做任何事情都喜欢逻辑严密的安排，没有逻辑的人我不愿意和他/她过多做无意义的争吵。撕逼，无意义的对骂是很无聊的事情。对面本来就是傻逼，没什么交流的余地。</p><p>在我这里逻辑可能高于很多东西，这也是OI里面逻辑严密性让我能真正认识到这一点。</p><p>尽管我刚开始对OI并不是很感兴趣，甚至想选择放弃，但当我真正退役了之后，没有了竞赛的压力，我才发现我无比喜欢对计科相关知识的研究。</p><p>比如这个博客，当初建立初衷其实也是跟随机房大佬的脚步，方便联赛复习，方便整理，搭博客其实真的很麻烦，各种奇怪的问题，美化也十分艰难，git莫名其妙抽风，github日常连不上。</p><p>但其实退役后，我也仍然在继续”经营”这个博客，发一些学习相关的东西，能有一个个人网站，在现在网络环境如此恶劣的情况下有个人自由表达的空间。</p><p>我现在也对网页设计方面有一定兴趣，但让我更坚定想选择软件工程的原因，应该也是我非常享受自己创造，自行设计，在自我创造中获得满足的感觉。</p><p>有了一个小程序/app构想，就很想知道实现它的方法，<del>比如我现在其实就想设计一个全自动排谷小程序（什）</del></p><p>最后，我发现我真的十分享受自我自由支配时间的感觉，我会非常喜欢自习课，自己制定计划，自己安排时间，自己寻找所需要刷的题。有自己主导不受他人约束的感觉真的很爽。</p><p>当一起都按计划实施，按自己安排的方案实施的时候，感到极度的满足。就如我写自主复习计划，只要我写了我一定会照做。<del>但如果我没写出来，很可能就无事发生</del> </p><p>可以说我的自我意识相当的强，很不喜欢被他人左右，可能有时候确实听不进去他人意见。</p><p>但其实也不是完全这样，有用的意见我会默默记住，但我可能不会表现出来，记住了不等于实践（）有很多不可控的因素我记住了不代表我会照做）</p><p>特别是对方态度越差，越表示你怎么总不听别人意见，我也是为你好之类道德绑架，我就会越不想理，潜意识无比排斥和拒绝，有了这样的前提，基本我听到了也会当没听到。</p><p>我也知道要这么做，但没这么做总有我自己的个人原因并不代表我没听到。有些事情说一遍就够了，我也不是不知道，天天说我</p><p>就只会逐渐烦躁，越来越没有好态度。/望周知</p><p><img src="https://i.loli.net/2020/07/29/EiNu8wfrLZYaDxy.jpg" alt="0022.JPG"></p><h1 id="Ⅳ-经验-Experience"><a href="#Ⅳ-经验-Experience" class="headerlink" title="Ⅳ 经验 Experience"></a>Ⅳ 经验 Experience</h1><p>再浅谈一下自己关于高考或者学习的一些经验。</p><p>首先我觉得高中学习以自主学习为主，选择怎样学习完全靠自己。你可以上课不听讲，可以不写作业，可以不学习；你也可以认真听讲，主动完成作业，积极学习。</p><p>可以说你不好好学习会被查水表，但真正到最后，其实老师也不会频繁管你了，毕竟大家也都是人生中的过客，自己的未来只能由自己掌控，你考的好不好也与他没多大关系。</p><p>但总归还是应该珍惜这三年的机会，虽然高考不是唯一出路，但真正大多数人都是从高考作为人生的起点。有的人可能确实不好好学习能有好的未来，但这也是极少数人，你不能肯定你就是那万分之一。好好学习终究对你只是有利无弊罢了。</p><p>讲这么多废话，进入正题。</p><p>我的建议首先上课还是认真听讲，跟着老师走 <del>（前提是你学校确实还不错x）</del></p><p>一个好的老师一定有多年的教学经验，他知道如何学好这门课，如何避开别人走错的老路，跟着他的教学进度走一定是一条捷径，能让你少走不少弯路。</p><p>话是这么说，其实很多理科生对语文英语都不以为然（我也一样），<strong>但我觉得如果你的老师真的很优秀，真的有水平，这课必须还是要听的</strong>。比如我们高二英语老师，听一节课就知道他贼牛逼，他的课堂笔记受用整个英语学习，不仅是高中。<del>可惜高三换了海灵</del> 还有语文老师，好的语文老师自己也有自己的教育体系，讲题思路清晰。这种老师讲的课建议还是听会更好x</p><p>我个人觉得数学课，如果你真的全都会做，这类题高考能100%不出错，你可以不听。前提是你真的有这个水平，题目熟练且一遍就对。一旦要犹豫，就是你掌握的还是有漏洞，需要听讲解思路和方法。再就是多做题，见多识广。</p><p>化学生物属于细节非常多的学科，笔记一定要滚动复习，讲评一定要听，你会的也要听，老师会把一道题讲透，不只限于这个题选什么。<strong>有任何选项有细节不清楚的一定要问，勇于去问问题把不知道的搞清楚非常重要，这样才能避免失分</strong>。</p><p>物理和数学感觉差不多，需要做题，但不用很多，主要掌握思路和方法，<strong>练习思维模式，敢于举一反三，不思考自己的弱点做针对训练，做多少题都没有用的</strong>。</p><p>答题规范也要十分注意，每道题都要思考为什么你和标答写的不一样，如何表达地更加规范，避免不必要的失分。2020高考就是很好的例子x</p><p>最后高考前重要的是心态，<strong>只有心态调整好了才能发挥出最高水平</strong>！不要过于紧张，也不要太放松，平常心就好。我觉得我高考心态挺好的基本就当成普通的考试去应对，这样就能考得好。</p><h1 id="Ⅴ-展望-Expectation"><a href="#Ⅴ-展望-Expectation" class="headerlink" title="Ⅴ 展望 Expectation"></a>Ⅴ 展望 Expectation</h1><p>目前现在其实大学已经确定了，我终究还是来到了上海，我曾今很早就说过自己想去上海上大学，阴差阳错之间本来以为只是口嗨，还真的能去上海上大学。</p><p>我之前还坚定的以为自己和SUSTech会比较有缘分，毕竟SHTech面试就没给我加分，我也没放在眼里。</p><p>哎，谁知道呢，命运弄人）</p><p>谁还能想到我高一还在口嗨我华武保底呢（）我现在就想笑笑，真就17分空手送人呗）笑死，多那17分我也许就不会选择SHTech，虽然也不好说就是了。</p><p>上海对我来说是无比向往的城市，新星科技，展会云集，做梦也想生在上海（）如今真的能过去了，在SHTech这样一所优秀的大学上学我真的赚暴！</p><p>据说SHTech的课程很繁重，但我本来也不是天天混日子的人，更有压力的课程，更好的教学环境，真的非常令人向往不已，可以说我对我的大学生活充满了无限期待。</p><p>对于计算机专业课程我也十分好奇，能选择真的感兴趣的专业真的非常难得，况且还是在师资力量如此优秀的学校。</p><p>希望自己的大学生活能十分丰富多彩。</p><h2 id="上海，我来了！"><a href="#上海，我来了！" class="headerlink" title="上海，我来了！"></a>上海，我来了！</h2><h2 id="Hello-SHTech"><a href="#Hello-SHTech" class="headerlink" title="Hello SHTech!"></a>Hello SHTech!</h2><p><img src="https://i.loli.net/2020/07/29/9M5dVJ3xGfFQrah.jpg" alt="0021.JPG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ⅰ Ⅱ Ⅲ Ⅳ Ⅴ&lt;/p&gt;
&lt;p&gt;高中三年转瞬即逝，一转眼之间，就来到了2020这个特殊的一年。&lt;/p&gt;
&lt;p&gt;感觉高中三年过得非常的充实，但却又总觉得缺了点什么。&lt;/p&gt;
&lt;p&gt;可能一心就在学校学习，没有同好，没有初中那种快乐（）&lt;/p&gt;
&lt;p&gt;但高中确实也应该以学习为主</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="Aoki_umi" scheme="http://yoursite.com/tags/Aoki-umi/"/>
    
    <category term="congratulations" scheme="http://yoursite.com/tags/congratulations/"/>
    
  </entry>
  
  <entry>
    <title>自主复习计划</title>
    <link href="http://yoursite.com/2020/06/24/%E8%87%AA%E4%B8%BB%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2020/06/24/%E8%87%AA%E4%B8%BB%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2020-06-25T02:21:21.000Z</published>
    <updated>2020-06-29T13:12:35.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于自主复习5天"><a href="#关于自主复习5天" class="headerlink" title="关于自主复习5天"></a>关于自主复习5天</h3><p>计划一下自主复习每日计划</p><p>说实话直到现在仍然没有什么复习思路，看了一下感觉做题时间会比较多？</p><p>但我觉得我很多东西感觉都不太记得，复习还是蛮重要的？</p><p>不知道是否有必要看一下一轮复习资料的东西再看一下知识细节啥的，特别是化学细节特别多，我最近看生物的力度比较大，可能还是需要加强化学基本知识点的巩固与复习。</p><p>物理感觉还是要看公式，选修啥的，保持选择题手感？</p><p>生物看书，看笔记，背书，背东西。</p><p>数学做题就完了，复习错题本，复习公式，大概就行。</p><p>语文背书，文常？要背的部分背一下？</p><p>然后之前有些积压的问题要问一下？</p><p>记得把化学物理的书找出了，最后阶段做题没那么重要了，方法基本已经记在心里了。可卷子太多了还是要做啊）））</p><p>然后就是制定每天具体的计划，时间安排，我发现只有计划定的足够详细，我才能高效学习）</p><p>然后每天就只提前一天制定计划，根据情况可以一直改动。</p><p>计划是每天都要保持每科一定的手感，看书+做题结合应对（数学除外x</p><p>每天若完成请打勾 未完成请打叉</p><h1 id="计划列表"><a href="#计划列表" class="headerlink" title="计划列表"></a>计划列表</h1><p><strong>需要做的卷子</strong></p><p>语文 冲刺训练7，冲刺训练8？</p><p>数学 华师一压轴卷，本来要考的周考卷，其他卷子选择性挑选要做的题目</p><p>英语 高考真题（待定）</p><p>物理 两套理综卷子的物理单科 其他待定</p><p>化学 一套二模7+4 理综两套卷子单科？</p><p>生物 训练十 理综单科？</p><p><strong>单科复习任务</strong></p><p>语文 重新滚动复习必背古诗词（重点看批注，字，翻译，理解），每日古诗词还是要写下去找问题和漏洞 以及写某人出的卷子x</p><p>数学 主要以刷题训练为主，注重导数的非常规做法，复习笔记本改错本</p><p>英语 适当做高考题目，复习<strong>单词</strong>和语法点 重点词组继续加强复习</p><p>物理 选修课本系统复习，加适当单科训练 ，及时补救复习弱点体型</p><p>化学 一轮复习书<strong>薄弱知识点加强记忆</strong>，复习知识细节，遗忘点补救，加适量单科训练，回归选修课本</p><p>生物 回归课本必备知识点，关注课本细节，课后习题，加适量单科训练</p><h2 id="·-6-25"><a href="#·-6-25" class="headerlink" title="· 6.25"></a>· 6.25</h2><h3 id="早上-（8-00-11-40"><a href="#早上-（8-00-11-40" class="headerlink" title="早上 （8 :  00-11 :  40)"></a>早上 （8 :  00-11 :  40)</h3><ol><li>做完语文限时训练7（大概1个小时左右，作文写大纲）√</li><li>语文古诗词系统性复习+古诗词默写训练（30-40分钟左右）应该还剩余大概1个半小时 √ <del>可能要问物理题</del> ×</li><li>数学做卷子 √</li></ol><h3 id="下午（14-00-17-00"><a href="#下午（14-00-17-00" class="headerlink" title="下午（14:  00- 17:  00)"></a>下午（14:  00- 17:  00)</h3><ol><li>化学回归书本复习+练习 ×（没时间了）</li><li>物理回归课本+练习 √</li></ol><p>晚上 总结错题+英语单词复习+做题？</p><p>大概先这么安排一天试试？</p><p>萎了啊，语文直接超了30分钟，物理就搞了一下午，太惨了人没了</p><p>晚上准备生物十写完，再复习一下</p><h2 id="·-6-26"><a href="#·-6-26" class="headerlink" title="· 6.26"></a>· 6.26</h2><h3 id="早上-（8-00-11-40-1"><a href="#早上-（8-00-11-40-1" class="headerlink" title="早上 （8:  00-11:  40)"></a>早上 （8:  00-11:  40)</h3><ol><li><p>7:  50-8:  20 例行语文古诗文复习和默写训练 √</p></li><li><p>8:  30-10:  10 化学单科7+4训练+课本回归复习 √</p></li><li><p>10:  10-11:  40 英语套题训练+部分词组复习 √</p><p>上午估计要找胡问题目 √</p></li></ol><h3 id="下午（14-00-17-00-1"><a href="#下午（14-00-17-00-1" class="headerlink" title="下午（14:  00- 17:  00)"></a>下午（14:  00- 17:  00)</h3><ol><li>14:  00-15:  00 数学华师一押题卷训练（能做多少是多少）√ 基本该写的都写了</li><li>15:  00-15:  15英语听力 √</li><li>剩余时间 物理单科训练 √</li></ol><p><del>晚上估计看牙齿 回家整理错题 那估计从6.27开始晚上去学校自习？</del> </p><p>晚上去学校看了qd视频 +写完了物理单科+生物单科</p><p>最近写了 两套物理单科 两套生物单科 零碎的数学 一套语文 一套英语 </p><p>明天准备减少做题量 回归课本为主复习</p><h2 id="·-6-27"><a href="#·-6-27" class="headerlink" title="· 6.27"></a>· 6.27</h2><h3 id="早上-（8-00-11-40-2"><a href="#早上-（8-00-11-40-2" class="headerlink" title="早上 （8:  00-11:  40)"></a>早上 （8:  00-11:  40)</h3><ol><li>7:  55-8:  25 例行语文古诗文复习和默写训练 √</li><li>8:  25-9:  45 语文冲刺训练8 √</li><li>9:  50-10:  40 化学7+4单科训练 √</li><li>剩余时间 化学回归课本复习总结 √</li></ol><h3 id="下午（14-00-17-00-2"><a href="#下午（14-00-17-00-2" class="headerlink" title="下午（14:  00- 17:  00)"></a>下午（14:  00- 17:  00)</h3><ol><li>14:  10-15:  00 物理回归课本复习选修 （做题暂时停止）√</li><li>15:  00-15:  15英语听力 √</li><li>剩余时间做数学石家庄模拟题 √</li></ol><h3 id="晚上（18-00-20-00或延长"><a href="#晚上（18-00-20-00或延长" class="headerlink" title="晚上（18:  00- 20:  00或延长)"></a>晚上（18:  00- 20:  00或延长)</h3><ol><li><p>18:  00-19: 00 生物笔记本复习 适当选择题目 ×</p></li><li><p>剩余时间 英语阅读等题目手感训练+ 复习单词+背范文 做了一套题 √</p><p>今天快乐的自习到了9点</p></li></ol><h2 id="6-28"><a href="#6-28" class="headerlink" title="6.28"></a>6.28</h2><h3 id="早上-（8-00-11-40-3"><a href="#早上-（8-00-11-40-3" class="headerlink" title="早上 （8:  00-11:  40)"></a>早上 （8:  00-11:  40)</h3><ol><li>7:  55-8:  25 例行语文古诗文复习和默写训练 √</li><li>8:  25-9:  45 物理单科训练 √</li><li>剩余时间生物复习+适当练习 √</li></ol><h3 id="下午（14-00-17-00-3"><a href="#下午（14-00-17-00-3" class="headerlink" title="下午（14:  00- 17:  00)"></a>下午（14:  00- 17:  00)</h3><ol><li>14:  10-15:  00 化学知识点复习 √</li><li>15:  00-15:  15英语听力 √</li><li>英语阅读完型训练+词组复习 √</li></ol><h3 id="晚上（18-00-20-00"><a href="#晚上（18-00-20-00" class="headerlink" title="晚上（18:  00- 20:  00)"></a>晚上（18:  00- 20:  00)</h3><ol><li>18:  00-19: 30数学题目选做 （剩下卷子不是很多x √</li><li>剩余时间 改错本笔记本复习 生物选修复习 其实是复习试卷x</li></ol><p>今天有事回来早点 我发现我复习顺序完全错的xx</p><h2 id="6-29（最后一天）"><a href="#6-29（最后一天）" class="headerlink" title="6.29（最后一天）"></a>6.29（最后一天）</h2><h3 id="早上-（8-00-11-40-4"><a href="#早上-（8-00-11-40-4" class="headerlink" title="早上 （8:  00-11:  40)"></a>早上 （8:  00-11:  40)</h3><ol><li>7:  55-8:  30 例行语文古诗文复习和默写训练 √</li><li>8:  30-10:  00 数学选做题目 √</li><li>剩余时间 生物选修复习 √</li></ol><h3 id="下午（14-00-17-00-4"><a href="#下午（14-00-17-00-4" class="headerlink" title="下午（14:  00- 17:  00)"></a>下午（14:  00- 17:  00)</h3><ol><li>14:  10-15:  00 化学7+4练手 √</li><li>15:  00-15:  15英语听力 √</li><li>剩余时间 物理题目复习改错本总结 </li></ol><h3 id="晚上（18-00-21-00"><a href="#晚上（18-00-21-00" class="headerlink" title="晚上（18:  00- 21:  00)"></a>晚上（18:  00- 21:  00)</h3><p>  各科复习总结 没复习完的一起看一下</p><p>目前自主复习告一段落了 继续努力吧x</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于自主复习5天&quot;&gt;&lt;a href=&quot;#关于自主复习5天&quot; class=&quot;headerlink&quot; title=&quot;关于自主复习5天&quot;&gt;&lt;/a&gt;关于自主复习5天&lt;/h3&gt;&lt;p&gt;计划一下自主复习每日计划&lt;/p&gt;
&lt;p&gt;说实话直到现在仍然没有什么复习思路，看了一下感觉做题</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
  <entry>
    <title>高三考试试卷分析汇总</title>
    <link href="http://yoursite.com/2020/05/17/%E9%AB%98%E4%B8%89%E8%AF%95%E5%8D%B7%E5%88%86%E6%9E%90%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/05/17/%E9%AB%98%E4%B8%89%E8%AF%95%E5%8D%B7%E5%88%86%E6%9E%90%E6%B1%87%E6%80%BB/</id>
    <published>2020-05-18T00:57:22.000Z</published>
    <updated>2020-09-04T14:49:16.550Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前排提示：本分析写给自己 并不适合长时间阅览）</strong></p><h1 id="武汉市四月调考总结"><a href="#武汉市四月调考总结" class="headerlink" title="武汉市四月调考总结"></a>武汉市四月调考总结</h1><p>额因为考得实在是稀烂所以真的需要总结一下各科的问题顺便制定一下后期的目标的对策</p><p>首先是试卷分析</p><h2 id="分析和总结"><a href="#分析和总结" class="headerlink" title="分析和总结"></a>分析和总结</h2><hr><h3 id="·-语文"><a href="#·-语文" class="headerlink" title="· 语文"></a>· 语文</h3><p>首先我仍未知道最近语文为何真的稀烂无比</p><p>这次考试首先是选择题错的还是多了，无脑错的大概是第一题，还真没发现均字有什么问题，但总觉得价值取向怪怪的害。接着题目出的不好的有2,4，设误点着实比较迷惑，出题人脑子有坑系列。。。然后就是文言文第10题，是我自己没理解对我承认，最后两道题确实有难度，关联没注意调序就一起蒙了。。</p><p>再是文字题，首先出的确实有点问题。。但小说分和翻译并不低哈，最后古诗题是我没解读清楚，我的锅。最后两道文字题。。。答案着实迷惑，逻辑欠妥，我真写不出来着答案。改错题可能有段时间没做我本来就不擅长找这种错，需要加强训练。</p><p>作文我以为必须以诗歌为中心，看来好像并不是这样，，全文中心还是抗疫我佛了。</p><p><strong>总结</strong>： 重视选择题训练，锻炼手感，后三题保证语感，掌握技巧。文字题逻辑理清楚，分条分点先总后分。总之还是要多练吧。。。。永远捉摸不透出题人在想什么，可能高考题还是正常一些。。。</p><h3 id="·-数学"><a href="#·-数学" class="headerlink" title="· 数学"></a>· 数学</h3><p>首先这次真的没发挥好，没什么不会的题，说真的。。选择题那个属于莫名搞错了x 第一个大题没注意A的下限，后面解析几何弱智算错了。。。倒数题估计是觉得我第一问做的不好吧。。。画图明明很清楚。。。</p><p><strong>总结</strong>：加强准确率！！！！</p><h3 id="·-英语"><a href="#·-英语" class="headerlink" title="· 英语"></a>· 英语</h3><p>不行我英语又翻车了。。。锤死自己</p><p>首先3.5的低级错误佛了。。看错选项和词也是醉了、、、、</p><p>听力可能是我没感受到她的愤怒。。。。以为她对这个电影讲什么很迷惑，实则人只关注前面人挡着她了。</p><p>阅读A我可能不认识英尺，以为没有大的表现，实则也没有specially-designed的表述。。。</p><p>B篇我的锅，我以为他grandson20多岁了。。实则是儿子20多岁，写一起用的定语从句真的误导人啊喂。。。我真的佛了，可能我一直在啃那句话没注意后面grow up 虽然我觉得20多岁grow up没啥问题。。。</p><p>D篇至今不能说服我，我觉得branch很形象啊一个分支=&gt;一个领域一个全新问题。。。different places明显不对啊佛了 每次将阅读永远往答案上扯，，，难受的很</p><p>完型我可能理解有点偏差导致刚好选反过来了。。。</p><p>作文。。。。我觉得我写的挺真实的扯高大尚有啥用。。。。佛了以后就往全球发展扯就完了</p><p><strong>总结</strong>：加强阅读，七选五，改错的训练，感觉前段时间过于忽略原文，这段时间ptsd又开始疯狂抠原文导致两边不讨好，可能就平衡度没有掌握好导致翻车。。。什么时候阅读能对我口味我真的迷惑了。。。。</p><h3 id="·-物理"><a href="#·-物理" class="headerlink" title="· 物理"></a>· 物理</h3><p>物理错的最后一道题当时因为题目看错了可能就慌了导致搞错了orz 实验摆长只能用刻度尺x我傻逼了实验怪我啊啊啊选修也是我的锅orz</p><p><strong>总结</strong>：加强弱点训练具体下文说</p><h3 id="·-化学"><a href="#·-化学" class="headerlink" title="· 化学"></a>· 化学</h3><p>化学选择那个就不提了，其实大题后两道海星吧，第一道题主要是被他的图误导了，对的改成错的之后错上加错，再是细节没处理好害，有机真的恶心吐了我太难了</p><p><strong>总结</strong>：加强训练提升能力吧害，可能也有需要强化的点（五一放假整理）</p><h3 id="·-生物"><a href="#·-生物" class="headerlink" title="· 生物"></a>· 生物</h3><p>生物又双叒叕翻车了我死了</p><p>选择题是我睿智了orz，植物不能吸收有机物我又忘记了啊啊啊</p><p>大题第一题表述不规范我的锅已经学习了选修又翻车 ，我忘了检查灭菌是否合格的表述了啊啊啊 然后我理解错选菌落的意思了我以为要生存的久，结果是要分解的快</p><p><strong>总结</strong>：落实基础，回归课本，表述规范</p><h2 id="对策与计划"><a href="#对策与计划" class="headerlink" title="对策与计划"></a>对策与计划</h2><hr><ol><li>语文重视起日常作业，不放过每一个题目。</li><li>英语每天刷几道阅读后面的题目，锻炼手感。</li><li>物理我觉得加强光电效应，选修，动量大题的解题手感，电磁感应难题要会做，反正要做到熟练，具体模块可能需要具体到细节之类的需要详细琢磨。</li><li>化学加强训练，可能化工流程需要加强训练，具体还需总结。</li><li>生物可能需要继续回归课本，必备知识点必须牢记，时时回顾orz</li></ol><h1 id="武汉市八校第二次联考试卷分析"><a href="#武汉市八校第二次联考试卷分析" class="headerlink" title="武汉市八校第二次联考试卷分析"></a>武汉市八校第二次联考试卷分析</h1><p>最近连着一起考了两次试，真的是起起落落，感觉还是有必要总结一下，害离高考没多久了，真的要好好找问题了。</p><h2 id="分析和总结-1"><a href="#分析和总结-1" class="headerlink" title="分析和总结"></a>分析和总结</h2><h3 id="·-语文-1"><a href="#·-语文-1" class="headerlink" title="· 语文"></a>· 语文</h3><p>这两次语文发挥的都不错，终于不是倒数了（bushi，以至于之前一度让我疯狂怀疑人生。</p><p>希望只要作业认认真真做，积极问问题语文还是可以正常发挥的害，继续加油吧！！哭鸟</p><h3 id="·-数学-1"><a href="#·-数学-1" class="headerlink" title="· 数学"></a>· 数学</h3><p>这两次数学考得也还行，说实话也没啥特别多说的（草太混了吧）</p><p>不过感觉还是有很多漏洞啊，你看这次周考不就原形毕露（妈咪!.jpg)(泪，射了出来.jpg)</p><p>感觉数学真的就是多做题就行，方法啥的都是做题做出来的，也没什么巧）</p><p>然后还是希望继续提高准确率，提高作业质量！希望不要再犯傻逼错误害</p><h3 id="·-英语-1"><a href="#·-英语-1" class="headerlink" title="· 英语"></a>· 英语</h3><p>事实证明我的英语问题仍然很大orz 我好难，每次阅读题都和出题人理解有出入（轻轻跪下.jpg)</p><p>如何才能把脑回路摆正了，是理科生的通病吗，自从疯狂不关注原文到疯狂扒原文细节理解感觉不会犯睿智错误了，以至于我每次选错都觉得自己有理有据（什）</p><p>以至于疯狂开始问问题（ 还好有外援人家不嫌我烦555555，海玲我真的不敢问啊x问了也讲不清楚（bushi</p><p>太难了希望还是能在最后把脑回路掰正（</p><p>感觉自己还是对一些单词的理解记忆啥的有偏差，我仍然记得那个之前考试arbitrary和autonomous的惨剧（凋谢.jpg)可能是平时记单词都是过一眼的锅x</p><p>百词斩轮一遍完估计还是在高考前集中再把容易记忆偏差的单词再搞一遍？</p><p>希望能有所帮助555555</p><h3 id="·-物理-1"><a href="#·-物理-1" class="headerlink" title="· 物理"></a>· 物理</h3><p>您好这边物理又双叒叕翻车了呢（</p><p><del>至于物理没考好是怎么一回事呢？物理相信大家都很熟悉，但是物理没考好又是怎么回事呢？下面</del> </p><p>拖出去打死x 首先我物理学史这块一直有不太清楚的地方，所以这周专门做了一个十分详细的整理，希望以后不会在这题栽跟头x</p><p>感觉选择题可能还是做的太快没有思考清楚就选了）还是不要太追求速度x太过于追求速度也没好结果x只是还是有漏洞orz，之前总结的东西会刷刷选择专项和必刷题来训练的x</p><p>以及虽然我最后一题是混的，但其实也没有算错两遍x就是没算平抛罢了，恰巧平抛那段不影响结果而已x</p><p>选修那个光学我之前就错过，这次又在棱角的折射上出了问题，亏我考试前还特意看了草这。。。</p><h3 id="·-化学-1"><a href="#·-化学-1" class="headerlink" title="· 化学"></a>· 化学</h3><p>您好这边化学又双叒叕翻车了呢（ 好了打住x</p><p>考的烂的原因让我回忆下x首先是自己睿智，做的比较快容易忽略一些东西）然后也是有一些基本操作记忆不清，于是又严重失误 太惨了</p><p>然后就是题目看清楚再做，不要擅自怀疑题目（bushi 感觉化学也是各种细节很多的学科，做起来也很麻烦，细节很容易忽略，希望能变得更细致一些）</p><p>然后就是每道题还是要想清楚为什么这样写，把逻辑链理清楚吧害</p><p>说实话还是不清楚化学要怎么样提升呢，让我再想想办法x</p><h3 id="·-生物-1"><a href="#·-生物-1" class="headerlink" title="· 生物"></a>· 生物</h3><p>这次生物终于翻身了！！yeah！！开心了</p><p>其实主要还是因为比较简单吧（ 难一点照样还是会错，而且选择题再做的时候还是没有完全弄清楚，说明还是有错的可能x</p><p>这次做生物没以前那么粗糙了？还是继续加油，生物一堆要背的东西真的贼难受x会继续加油的(妈咪.jpg)</p><hr><p>好了我水完一篇总结了x</p><p>对策基本上面已经说了就不列一遍了orz</p><p>以后基本每次大考考完都会利用星期天写总结x</p><h1 id="武汉市五月调考试卷分析"><a href="#武汉市五月调考试卷分析" class="headerlink" title="武汉市五月调考试卷分析"></a>武汉市五月调考试卷分析</h1><p>终于又考了一次大考，害极其难受到自闭）吐血了</p><h2 id="分析与总结"><a href="#分析与总结" class="headerlink" title="分析与总结"></a>分析与总结</h2><h3 id="·-语文-2"><a href="#·-语文-2" class="headerlink" title="· 语文"></a>· 语文</h3><p>语文又烂了（ 主要是选择题弱智了害（</p><p>起码多错了两个，加上古诗默写令人窒息一共10分我吐了</p><p>真的不是我不会背，我是真的没搞清楚要考哪句话x吐了 这个作文也是迷惑的一批）</p><p>希望尽量不要错弱智选择题，古诗不能错了真的不能错了x</p><p>简单题也只能靠命了</p><h3 id="·-数学-2"><a href="#·-数学-2" class="headerlink" title="· 数学"></a>· 数学</h3><p>不说了翻车最惨的就是数学</p><p>首先本来选择题就有不会的，然后可能因为我看题太急了，没动笔心算还把题看错了（是说怎么这么简单？</p><p>然后就是第8题不等式这个我又蒙圈了（ 可能需要加强不等式练习？</p><p>然后最后那个12题我本来是会做的，不知道在搞啥又搞错了x服了</p><p>填空题第2题，草，lg5=lg2+lg3不愧是我哈哈哈哈 甚至忘了lg5+lg2=1。。。</p><p>16题确实不会x当时就没想</p><p>你看看5个选填是人错的？25分白给？</p><p>再说17题，我十分优秀的做出来了，结果第一问求了个角度就走了？啊这）</p><p>18题够简单了吧，行吧法向量正负号写错一个 牛逼啊</p><p>果然脑子已经锈掉了哈哈哈哈哈哈哈</p><p>19题优秀啊 唯一一个全对答题））））））</p><p>20题 害考虑掉了最后只剩一个不用再检测了）</p><p>21题就不说了太秀了</p><p>22题简直毒瘤东西，极坐标大吃亏</p><p>希望能加强练习吧</p><h3 id="·-英语-2"><a href="#·-英语-2" class="headerlink" title="· 英语"></a>· 英语</h3><p>英语仍然是老问题了，还是想的太多，已经交流过了会尽量改正的）</p><p>难受了）</p><p>主要还是不能主观臆断，虽然确实很迷惑。。。。我再也不想做高中英语阅读了，四级阅读做的都比这强</p><h3 id="·-物理-2"><a href="#·-物理-2" class="headerlink" title="· 物理"></a>· 物理</h3><p>物理还是害 实验算错了太多，数据算错就尼玛离谱得很，选修选择题又翻车，这次也不小心错了</p><p>吐了 会加强训练的 物理还是又很多地方不太熟练的</p><p>会针对性进行训练</p><h3 id="·-化学-2"><a href="#·-化学-2" class="headerlink" title="· 化学"></a>· 化学</h3><p>这次化学考得倒是还行，因为比较简单，会在训练中继续查漏补缺</p><h3 id="·-生物-2"><a href="#·-生物-2" class="headerlink" title="· 生物"></a>· 生物</h3><p>生物这次同理，也很简单，但自己概念还是有很多不熟悉的地方，会继续加强训练。</p><p>害水的不行，没心情写了orz</p><h1 id="武汉市六月第一套供题试卷分析"><a href="#武汉市六月第一套供题试卷分析" class="headerlink" title="武汉市六月第一套供题试卷分析"></a>武汉市六月第一套供题试卷分析</h1><p>最近考试真的频繁还是写一下分析继续找问题吧）））</p><h2 id="语文"><a href="#语文" class="headerlink" title="语文"></a>语文</h2><p>这次语文翻车大概在选择题？害这选择题确实比较恶心，就是没有计算没发现4C错了 但我觉得4B真的有问题吧，可能还要去问一下。</p><p>层层递进，看到首先再 对不起被蒙蔽了，为啥我真的没看出来比喻论证？？</p><p>断句不会orz 害挺迷惑的哈</p><p>作文这次难得有48 争气了（（（（太难了吧</p><p>语文就是这样，脑回路没对上真的没办法</p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>数学这次真就两个睿智选择题吧害）））说实话后面确实没有难点</p><p>17题范围写错都看出来真的改的挺仔细了，还好后面过程写的很详细没啥问题</p><p>以后确实写题还是每步都写清楚免得要扣分）））</p><p>希望继续保持，别再犯傻逼错误了</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>英语终于争气了害</p><p>总算掌握了一点阅读套路？？？？文章写啥就选啥 想多就错没有用的害</p><p>希望能继续保持感觉吧，英语真的天天对电波，真的难顶，会努力整好脑回路的）</p><h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><p>这次选修真的司马了吐了吐了我服了（（（（（</p><p>一开始没发现两个k不一样，懵逼了很久</p><p>结果发现是个数论题？？？？我？？？？？</p><p>后来只有3分钟了，啥也憋不出来了））））</p><p>电磁感应那个最后是我没分析清楚orz 模型不太记得，以为不一样）））</p><p>太惨了orz</p><h2 id="化学"><a href="#化学" class="headerlink" title="化学"></a>化学</h2><p>化学翻车说是难那是简单</p><p>说没就没</p><p>方程式写错一没就全没我死了</p><p>选修有机司马了</p><p>是我手抖啥也没看清楚（）（）（）（）我会看看结构的orz</p><p>主要这次结构第一题我也没看懂）</p><p>吐了真的佛了</p><p>orz</p><h2 id="生物"><a href="#生物" class="headerlink" title="生物"></a>生物</h2><p>生物老师改卷司马了）））））））</p><p>怎么遗传最后一问没分呢？？？？？草死了））））</p><p>什么垃圾题出的 吐了啊真的就恶心人吧</p><p>真的无语 生物出的什么东西好恶心人啊</p><p>nmsl</p><p>完了总结越写越水，有的时候真的刷题也不知道刷什么题，物理大概有方向，化学真的没有方向，生物也感觉很模糊不清 难顶 英语高考题大概也要多看看 太难顶了 现在真的什么地方都乌烟瘴气 吐了 不想上网了 喷子司马了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前排提示：本分析写给自己 并不适合长时间阅览）&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;武汉市四月调考总结&quot;&gt;&lt;a href=&quot;#武汉市四月调考总结&quot; class=&quot;headerlink&quot; title=&quot;武汉市四月调考总结&quot;&gt;&lt;/a&gt;武汉市四月调考总结&lt;/</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="paper_analysis" scheme="http://yoursite.com/tags/paper-analysis/"/>
    
  </entry>
  
  <entry>
    <title>高中相关资料整理汇总</title>
    <link href="http://yoursite.com/2020/05/17/%E9%AB%98%E4%B8%AD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/05/17/%E9%AB%98%E4%B8%AD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-17T19:44:11.000Z</published>
    <updated>2020-07-04T14:04:49.093Z</updated>
    
    <content type="html"><![CDATA[<p>最近也许会根据自己的问题整理一些学习资料，有需要的可以自取啦</p><p>高中物理学史总结→<a href="http://qatm6poz0.bkt.clouddn.com/%E9%AB%98%E4%B8%AD%E7%89%A9%E7%90%86%E5%AD%A6%E5%8F%B2%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93new.docx" target="_blank" rel="noopener">点击下载物理学史</a> </p><p>高中必背古诗→<a href="http://qatm6poz0.bkt.clouddn.com/%E9%AB%98%E4%B8%AD%E8%AF%AD%E6%96%8764%E7%AF%87%E5%BF%85%E8%83%8C%E5%8F%A4%E8%AF%97%E6%96%87.docx" target="_blank" rel="noopener">点击下载必背古诗</a>（ps：论语部分每年不太一样，请以当年为准，我这个有点问题懒得改了x）</p><p>老师整理的生物教材课后习题答案</p><p>必修一→<a href="http://qatm6poz0.bkt.clouddn.com/%E5%BF%85%E4%BF%AE1%E6%95%99%E6%9D%90%E8%AE%A8%E8%AE%BA%E3%80%81%E6%97%81%E6%A0%8F%E6%80%9D%E8%80%83%E9%A2%98%E3%80%81%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.doc" target="_blank" rel="noopener">点击下载</a></p><p>必修二→<a href="http://qatm6poz0.bkt.clouddn.com/%E5%BF%85%E4%BF%AE2%E7%AD%94%E6%A1%88%EF%BC%88%E6%8E%92%20%E7%89%886%E5%8F%B7%EF%BC%89.doc" target="_blank" rel="noopener">点击下载</a></p><p>必修三→<a href="http://qatm6poz0.bkt.clouddn.com/%E5%BF%85%E4%BF%AE3%E6%95%99%E6%9D%90%E8%AE%A8%E8%AE%BA%E3%80%81%E6%97%81%E6%A0%8F%E6%80%9D%E8%80%83%E9%A2%98%E3%80%81%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.doc" target="_blank" rel="noopener">点击下载</a></p><blockquote><p>7.4更新 由于买不起域名 还要备案，还想看的直接评论或者私信我qq吧x 2830760496</p></blockquote><blockquote><p>评论不常看orz</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近也许会根据自己的问题整理一些学习资料，有需要的可以自取啦&lt;/p&gt;
&lt;p&gt;高中物理学史总结→&lt;a href=&quot;http://qatm6poz0.bkt.clouddn.com/%E9%AB%98%E4%B8%AD%E7%89%A9%E7%90%86%E5%AD%A6%E5</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
  <entry>
    <title>每日学习打卡&amp;整理合集</title>
    <link href="http://yoursite.com/2020/04/29/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1&amp;%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2020/04/29/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1&amp;%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/</id>
    <published>2020-04-30T01:42:22.000Z</published>
    <updated>2020-06-24T11:38:30.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="具体计划与安排"><a href="#具体计划与安排" class="headerlink" title="具体计划与安排"></a>具体计划与安排</h2><hr><h3 id="物理模块（持续更新中）"><a href="#物理模块（持续更新中）" class="headerlink" title="物理模块（持续更新中）"></a>物理模块（持续更新中）</h3><ol><li>静电屏蔽等专题，感觉还是有点迷</li><li>多用电表电流表的量程大小比较</li><li>发现电磁感应大题仍有失误</li><li>发现动量大题综合计算仍然不熟练</li><li>需要加强选择题训练</li><li>力学分析小题总有欠缺</li><li>电学题目需要加强，需要针对性训练</li><li>核物理需要加强，看书复习</li></ol><h3 id="生物复习计划（持续更新中）"><a href="#生物复习计划（持续更新中）" class="headerlink" title="生物复习计划（持续更新中）"></a>生物复习计划（持续更新中）</h3><p>粗略的计划是从必修一第4章，开始每天1节，从今天4.29开始打卡，共50节</p><p>预计4.29–6.16号结束（无特殊情况不可不打卡）如每日单词要坚持到底</p><ul><li>4.29打卡完成第4章第1节物质跨膜运输的实例（找出了从前不知道的误区）</li><li>4.30打卡完成第4章第2节生物膜的流动镶嵌模型</li><li>5.1打卡完成第4章第3节物质的跨膜运输的方式</li><li>5.2打卡完成第5章第1节降低化学反应活化能的酶（这节比较长，巩固了蛮多的）</li><li>5.3打卡完成第5章第2节细胞能量的通货——ATP</li><li>5.4打卡完成第5章第3节ATP的主要来源——细胞呼吸</li><li>5.5打卡完成第5章第4节能量之源——光与光合作用的第一部分：捕获光能的色素和结构（因时间和内容较多的原因分为两天复习） </li><li>5.6打卡完成必修二第1章第一节孟德尔的豌豆杂交实验（一） （我的必修一忘带回来了orz） </li><li>5.7打卡完成必修一第5章第4节量之源——光与光合作用剩余部分 </li><li>5.8打卡完成第6章第1节细胞的增殖 </li><li>5.9由于没带生物书，今天暂且以看笔记本为主（习惯养成了太难改了😂</li><li>5.10打卡完成第6章第2节细胞的分化 </li><li>5.11打卡完成第6章第3节细胞的衰老和凋亡 </li><li>5.12打卡完成第6章第4节细胞的癌变 </li><li>5.13打卡完成必修二第1章第2节孟德尔的豌豆杂交实验（二）  </li><li>5.14打卡完成第2章第1节减数分裂和受精作用 </li><li>5.15打卡完成第2章第2节基因在染色体上 </li><li>又忘带书了下次一定）</li><li>5.17打卡完成第2章第3节伴性遗传 </li><li>5.18打卡完成第3章第1节DNA是主要的遗传物质 </li><li>5.19打卡完成第3章第2节DNA分子的结构 </li><li>5.20打卡完成第3章第3节DNA的复制 </li><li>5.21打卡完成第3章第4节基因是有遗传效应的DNA片段 </li><li>5.22打卡完成第3章后3节（遗传部分比较快x </li><li>5.23打卡完成第4章第1节基因指导蛋白质的合成（带书了！！</li><li>5.24打卡完成第4章剩余+第5章第一节基因突变和基因重组（我之前好像一起复习了？ </li><li>5.25打卡完成第5章第2节染色体变异 </li><li>5.26打卡完成第5章第3节人类遗传病 </li><li>5.27打卡完成第6章第1节杂交育种与诱变育种 </li><li>5.28打卡完成第6章第2节基因工程及其应用 </li><li>5.29打卡完成第6章第1节现代生物进化理论的主要内容 </li><li>5.30打卡完成第6章第2节第一部分种群基因频率的改变与生物进化</li><li>5.31打卡完成第6章第2节剩余部分 </li><li>6.1打卡完成必修三第1章第1节细胞生活的环境 </li><li>6.2打卡完成第1章第2节内环境稳态的重要性 </li><li>6.3打卡完成第3章第1节通过神经系统的调节 </li><li>6.4打卡完成第3章第2节激素调节部分内容） </li><li>6.5打卡完成第3章第2节激素调节剩余 </li><li>没带书orz</li><li>6.7打卡完成第2章第3节神经调节与体液调节的关系 </li><li>6.8打卡作业太多太困了免疫调节看了一点先睡了orz </li><li>6.9打卡完成第2章第4节免疫调节 </li><li>6.10打卡完成第3章第1节植物生长素的发现 </li><li>6.11打卡完成第3章后两节 </li><li>6.12打卡完成第4章第1节种群的特征</li><li>又没带书草x</li><li>6.14打卡完成第4章第2节种群数量的变化 </li><li>搞课改网太晚了））） </li><li>6.16打卡完成第4章第3节群落的结构 </li><li>6.17打卡完成第4章第4节群落的演替 </li><li>6.18打卡完成第5章第1节生态系统的结构 </li><li>6.19打卡完成第5章第2节生态系统的能量流动 </li><li>带错书了xxx </li><li>6.21打卡完成第5章后两节 </li><li>6.22打卡完成第6章生态环境的保护 </li></ul><h3 id="至此，生物三本必修终于复习完毕"><a href="#至此，生物三本必修终于复习完毕" class="headerlink" title="至此，生物三本必修终于复习完毕"></a>至此，生物三本必修终于复习完毕</h3><h3 id="化学模块（持续更新中）"><a href="#化学模块（持续更新中）" class="headerlink" title="化学模块（持续更新中）"></a>化学模块（持续更新中）</h3><p>· 实验大题中对一些装置作用的解答怎样写的全面准确</p><p>· 大题中各种对现象的解释有时候写不出来</p><p>· 平衡大题中什么时候从平衡的角度答，什么时候从反应速率来答</p><p>总体来说还是简单题问题大于计算吧，具体的太细了感觉找不出来只能大题概括一下x</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;具体计划与安排&quot;&gt;&lt;a href=&quot;#具体计划与安排&quot; class=&quot;headerlink&quot; title=&quot;具体计划与安排&quot;&gt;&lt;/a&gt;具体计划与安排&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;物理模块（持续更新中）&quot;&gt;&lt;a href=&quot;#物理模块（持续更新中）&quot; clas</summary>
      
    
    
    
    <category term="STUDY" scheme="http://yoursite.com/categories/STUDY/"/>
    
    
    <category term="study_notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
</feed>
